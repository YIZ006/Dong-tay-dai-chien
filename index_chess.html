<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ƒê√¥ng T√¢y ƒê·∫°i Chi·∫øn - Promotion Update</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --cell: 60px;
            --board-bg: #deb887;
            --river-color: #87ceeb;
            --bg-color: #1a1a1a;
            --panel-bg: #222;
            --text-gold: #f1c40f;
        }
        
        body {
            background: var(--bg-color);
            color: white;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            min-height: 100vh;
            user-select: none;
            overflow-x: hidden; /* Tr√°nh thanh cu·ªôn ngang */
            padding-bottom: 50px; /* Ch·ª´a ch·ªó cho footer */
        }

        /* --- LAYOUT --- */
        .game-wrapper {
            display: flex;
            flex-direction: column; /* X·∫øp d·ªçc */
            align-items: center;
            gap: 10px;
            margin-top: 5px;
        }

        /* --- TOP GRAVEYARD BAR --- */
        #graveyard-bar {
            width: calc(var(--cell) * 9 + 20px); /* B·∫±ng chi·ªÅu r·ªông b√†n c·ªù */
            background: #2a2a2a;
            border: 2px solid #555;
            border-radius: 8px;
            padding: 4px 8px;
            display: flex;
            flex-direction: column;
            gap: 3px;
            transition: transform 0.6s ease-in-out, flex-direction 0.6s ease-in-out;
        }
        .game-wrapper.board-rotated #graveyard-bar {
            transform: rotate(180deg);
            flex-direction: column-reverse;
        }

        .grave-row {
            height: 28px;
            display: flex;
            align-items: center;
            gap: 3px;
            background: rgba(0,0,0,0.3);
            padding: 0 8px;
            border-radius: 4px;
            flex-wrap: wrap;
        }
        
        /* Nh√£n cho h√†ng t√π binh */
        .grave-label {
            font-size: 8px; color: #888; width: 50px; flex-shrink: 0;
            text-transform: uppercase; font-weight: bold; line-height: 1.2;
        }

        /* Qu√¢n c·ªù trong t√π binh */
        .captured-piece {
            display: flex;
            align-items: center;
            gap: 2px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            padding: 2px 6px;
            flex-shrink: 0;
        }
        .captured-piece .piece-icon {
            width: 18px;
            height: 18px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .captured-piece.chess-side { 
            font-size: 12px !important; 
            color: #bbb; 
            text-shadow: none; 
        }
        .captured-piece.chess-side .piece-icon {
            font-size: 12px !important;
            color: #bbb;
        }
        .captured-piece.xq-side { 
            font-size: 10px !important; 
            color: #e74c3c; 
            border: 1px solid #8b0000; 
            background: #f5deb3; 
        }
        .captured-piece.xq-side .piece-icon {
            font-size: 10px !important;
            color: #e74c3c;
        }
        .captured-piece .count {
            font-size: 10px;
            color: #aaa;
            font-weight: bold;
            margin-left: 2px;
        }
        .captured-piece.xq-side .count {
            color: #8b0000;
        }

        /* --- BOARD --- */
        #board-container {
            padding: 10px; background: #5c4033; border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            position: relative;
            transition: transform 0.6s ease-in-out;
        }
        #board-container.rotated {
            transform: rotate(180deg);
        }
        #board {
            display: grid;
            grid-template-columns: repeat(9, var(--cell));
            grid-template-rows: repeat(10, var(--cell));
            transition: transform 0.6s ease-in-out;
        }
        #board-container.rotated #board {
            transform: rotate(180deg);
        }
        /* Pieces always face their player's perspective */
        /* Chess pieces (white) always face up (normal view) */
        .piece.chess-side {
            transform: rotate(0deg);
        }
        .piece.chess-side:hover {
            transform: rotate(0deg) scale(1.1);
        }
        .piece.chess-side.selected {
            transform: rotate(0deg) scale(1.15);
        }
        /* Xiangqi pieces (red) always face down (rotated view when board is normal) */
        .piece.xq-side {
            transform: rotate(180deg);
        }
        .piece.xq-side:hover {
            transform: rotate(180deg) scale(1.1);
        }
        .piece.xq-side.selected {
            transform: rotate(180deg) scale(1.15);
        }
        /* When board is rotated (Xiangqi player's view), reverse piece rotations */
        #board-container.rotated .piece.chess-side {
            transform: rotate(180deg);
        }
        #board-container.rotated .piece.chess-side:hover {
            transform: rotate(180deg) scale(1.1);
        }
        #board-container.rotated .piece.chess-side.selected {
            transform: rotate(180deg) scale(1.15);
        }
        #board-container.rotated .piece.xq-side {
            transform: rotate(0deg);
        }
        #board-container.rotated .piece.xq-side:hover {
            transform: rotate(0deg) scale(1.1);
        }
        #board-container.rotated .piece.xq-side.selected {
            transform: rotate(0deg) scale(1.15);
        }
        /* Rotate board elements when board is rotated */
        #board-container.rotated .square {
            transform: rotate(180deg);
        }
        #board-container.rotated .river span {
            transform: rotate(180deg);
        }
        #board-container.rotated .move-dot {
            transform: rotate(180deg);
        }
        #board {
            background: var(--board-bg);
            border: 2px solid #333;
            position: relative;
        }

        /* --- CONTROLS --- */
        #control-bar {
            margin-top: 10px; display: flex; gap: 10px; background: #333;
            padding: 8px 20px; border-radius: 50px; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .ctrl-btn {
            width: 40px; height: 40px; border-radius: 50%; border: none;
            background: #444; color: white; font-size: 1rem; cursor: pointer;
            transition: 0.2s; display: flex; justify-content: center; align-items: center;
        }
        .ctrl-btn:hover { background: #666; transform: scale(1.1); }
        .ctrl-btn:disabled { opacity: 0.3; cursor: not-allowed; transform: none; }
        .ctrl-btn.active-live { background: #e74c3c; box-shadow: 0 0 10px red; width: auto; padding: 0 20px; border-radius: 20px; font-weight: bold;}

        /* --- RULES SECTION (M·ªöI) --- */
        #rules-container {
            margin-top: 25px;
            width: 100%;
            max-width: 650px;
            background: #232323;
            border: 1px solid #444;
            border-radius: 12px;
            padding: 20px;
            box-sizing: border-box;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }
        .rules-title {
            text-align: center; color: var(--text-gold); margin-top: 0;
            border-bottom: 1px solid #444; padding-bottom: 10px; font-size: 1.4rem;
        }
        .rules-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px;
        }
        .rule-box h3 {
            color: #e74c3c; font-size: 1.1rem; margin-bottom: 10px; margin-top: 0;
            display: flex; align-items: center; gap: 8px;
        }
        .rule-box:first-child h3 { color: #dcdcdc; } /* M√†u ti√™u ƒë·ªÅ phe C·ªù Vua */
        .rule-box ul {
            padding-left: 20px; margin: 0; font-size: 0.9rem; color: #ccc; line-height: 1.6;
        }
        .rule-box li { margin-bottom: 6px; }
        .full-width {
            grid-column: span 2; border-top: 1px dashed #444; padding-top: 15px; margin-top: 5px;
        }
        @media (max-width: 700px) {
            .rules-grid { grid-template-columns: 1fr; }
            .full-width { grid-column: span 1; }
        }

        /* --- PROMOTION MODAL --- */
        #promotion-modal {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85); z-index: 50; border-radius: 8px;
            display: none; flex-direction: column; justify-content: center; align-items: center;
        }
        #promotion-modal h3 { color: var(--text-gold); margin-bottom: 20px; font-size: 1.5rem; }
        .promo-options { display: flex; gap: 20px; }
        .promo-btn {
            width: 60px; height: 60px; font-size: 40px; background: #444; color: #fdf5e6;
            border: 2px solid #fff; border-radius: 10px; cursor: pointer; transition: 0.2s;
        }
        .promo-btn:hover { background: #666; transform: scale(1.1); border-color: var(--text-gold); }

        /* --- VISUALS --- */
        .square { width: var(--cell); height: var(--cell); display: flex; justify-content: center; align-items: center; position: relative; }
        .square.dark { background: rgba(139, 69, 19, 0.3); }
        .river { background: var(--river-color) !important; position: relative; }
        .river span { position: absolute; width: 100%; text-align: center; font-size: 11px; color: #444; font-weight: bold; pointer-events: none; z-index: 0; }
        .last-move { background-color: rgba(255, 255, 0, 0.4) !important; box-shadow: inset 0 0 10px orange; }

        .xq-grid::before { content: ''; position: absolute; top: 50%; left: 0; right: 0; height: 1px; background: rgba(0,0,0,0.15); z-index: 0; }
        .xq-grid::after { content: ''; position: absolute; top: 0; bottom: 0; left: 50%; width: 1px; background: rgba(0,0,0,0.15); z-index: 0; }
        .palace-slash { background: linear-gradient(to bottom right, transparent calc(50% - 1px), rgba(0,0,0,0.2) 50%, transparent calc(50% + 1px)); }
        .palace-backslash { background: linear-gradient(to bottom left, transparent calc(50% - 1px), rgba(0,0,0,0.2) 50%, transparent calc(50% + 1px)); }

        .piece { width: 85%; height: 85%; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: transform 0.2s; position: relative; z-index: 10; }
        .in-check { background-color: rgba(255, 0, 0, 0.6) !important; box-shadow: 0 0 15px red; border-radius: 50%; }

        .piece.chess-side { font-size: 40px; color: #fdf5e6; text-shadow: 1px 1px 2px black; }
        .piece.xq-side { background: #f5deb3; border-radius: 50%; border: 3px solid #8b0000; color: #cc0000; font-family: "KaiTi", serif; font-weight: bold; font-size: 22px; box-shadow: 2px 2px 5px rgba(0,0,0,0.4); }
        .piece.xq-side::before { content: ''; position: absolute; top: 2px; left: 2px; right: 2px; bottom: 2px; border-radius: 50%; border: 1px dashed rgba(139, 0, 0, 0.3); }

        .move-dot { width: 16px; height: 16px; background: rgba(0, 255, 0, 0.6); border-radius: 50%; position: absolute; z-index: 20; pointer-events: none; box-shadow: 0 0 5px #fff; }

        #status-bar { display: flex; gap: 20px; align-items: center; margin-bottom: 5px; }
        .badge { padding: 5px 25px; border-radius: 15px; font-weight: bold; border: 2px solid #fff; width: 250px; text-align: center; font-size: 1.1rem; }
        
        #start-screen, #game-over { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        button.main-btn { padding: 10px 30px; font-size: 1.2rem; background: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 20px; }
        
        /* Player Info Styles */
        .player-info { 
            margin-top: 15px; 
            padding: 15px; 
            background: rgba(255,255,255,0.1); 
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 300px;
        }
        .player-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            border-radius: 6px;
            background: rgba(0,0,0,0.3);
        }
        .player-item.player1 {
            border-left: 4px solid #3498db;
        }
        .player-item.player2 {
            border-left: 4px solid #e74c3c;
        }
        .player-badge {
            font-weight: bold;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
        }
        .player-badge.player1 {
            background: #3498db;
            color: white;
        }
        .player-badge.player2 {
            background: #e74c3c;
            color: white;
        }
        .player-side {
            font-size: 0.9rem;
            color: #aaa;
        }
        
        /* Coin Flip Animation */
        .coin-container {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        .coin {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(135deg, #f1c40f 0%, #f39c12 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            box-shadow: 0 10px 30px rgba(241, 196, 15, 0.5);
            cursor: pointer;
            transition: transform 0.3s;
            position: relative;
            overflow: hidden;
        }
        .coin.flipping {
            animation: coinFlip 2s ease-in-out;
        }
        @keyframes coinFlip {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(1800deg) scale(1.2); }
            100% { transform: rotateY(3600deg); }
        }
        .coin-side {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            backface-visibility: hidden;
        }
        .coin-heads { background: linear-gradient(135deg, #f1c40f 0%, #f39c12 100%); }
        .coin-tails { background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%); transform: rotateY(180deg); }
        
        /* Dice Animation */
        .dice-container {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        .dice {
            width: 80px;
            height: 80px;
            background: white;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: transform 0.3s;
        }
        .dice.rolling {
            animation: diceRoll 1.5s ease-in-out;
        }
        @keyframes diceRoll {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(90deg) scale(1.1); }
            50% { transform: rotate(180deg) scale(0.9); }
            75% { transform: rotate(270deg) scale(1.1); }
        }
        .result-display {
            margin-top: 15px;
            padding: 15px;
            background: rgba(241, 196, 15, 0.2);
            border-radius: 8px;
            border: 2px solid #f1c40f;
            font-size: 1.1rem;
            font-weight: bold;
            color: #f1c40f;
            text-align: center;
        }
        .player-name-input {
            padding: 8px 12px;
            font-size: 0.9rem;
            border-radius: 5px;
            border: 2px solid #555;
            background: #333;
            color: white;
            width: 150px;
            margin-left: 10px;
        }
        .player-name-input::placeholder { color: #888; }

    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="color: var(--text-gold);">ƒê√îNG T√ÇY ƒê·∫†I CHI·∫æN</h1>
        <p style="color: #ccc;">Ch·∫ø ƒë·ªô: Phong C·∫•p T√πy Ch·ªçn</p>
        
        <!-- Player Info -->
        <div class="player-info" id="player-info">
            <div class="player-item player1">
                <div>
                    <span class="player-badge player1">PLAYER 1</span>
                    <input type="text" id="player1-name-input" class="player-name-input" placeholder="Nh·∫≠p t√™n" value="Ng∆∞·ªùi ch∆°i 1">
                </div>
                <div class="player-side" id="player1-side">-</div>
            </div>
            <div class="player-item player2">
                <div>
                    <span class="player-badge player2">PLAYER 2</span>
                    <input type="text" id="player2-name-input" class="player-name-input" placeholder="Nh·∫≠p t√™n" value="Ng∆∞·ªùi ch∆°i 2">
                </div>
                <div class="player-side" id="player2-side">-</div>
            </div>
        </div>
        
        <!-- Coin Flip Section (Choose Side) -->
        <div id="coin-flip-section" class="coin-container">
            <div style="font-size: 1.2rem; color: #f1c40f; font-weight: bold; margin-bottom: 10px;">
                ü™ô TUNG ƒê·ªíNG XU - CH·ªåN B√äN
            </div>
            <div style="font-size: 0.9rem; color: #aaa; margin-bottom: 15px; text-align: center;">
                Player 1 click v√†o ƒë·ªìng xu ƒë·ªÉ tung
            </div>
            <div class="coin" id="coin" onclick="flipCoin()">
                <div class="coin-side coin-heads">‚ôö</div>
                <div class="coin-side coin-tails">Â∏•</div>
            </div>
            <div id="coin-result" class="result-display" style="display: none;"></div>
        </div>
        
        <!-- Dice Section (Choose First Turn) -->
        <div id="dice-section" class="dice-container" style="display: none;">
            <div style="font-size: 1.2rem; color: #f1c40f; font-weight: bold; margin-bottom: 10px;">
                üé≤ TUNG X√öC X·∫ÆC - CH·ªåN NG∆Ø·ªúI ƒêI TR∆Ø·ªöC
            </div>
            <div style="font-size: 0.9rem; color: #aaa; margin-bottom: 15px; text-align: center;">
                C·∫£ 2 ng∆∞·ªùi ch∆°i ƒë·ªÅu tung x√∫c x·∫Øc. Ai c√≥ t·ªïng cao h∆°n s·∫Ω ƒëi tr∆∞·ªõc!
            </div>
            <div style="display: flex; gap: 20px; align-items: center;">
                <div>
                    <div style="font-size: 0.9rem; color: #3498db; margin-bottom: 5px;">Player 1</div>
                    <div class="dice" id="dice-player1" onclick="rollDice(1)">üé≤</div>
                    <div id="dice-result-player1" style="margin-top: 10px; color: #3498db; font-weight: bold; min-height: 20px;"></div>
                </div>
                <div style="font-size: 2rem; color: #f1c40f;">VS</div>
                <div>
                    <div style="font-size: 0.9rem; color: #e74c3c; margin-bottom: 5px;">Player 2</div>
                    <div class="dice" id="dice-player2" onclick="rollDice(2)">üé≤</div>
                    <div id="dice-result-player2" style="margin-top: 10px; color: #e74c3c; font-weight: bold; min-height: 20px;"></div>
                </div>
            </div>
            <div id="dice-final-result" class="result-display" style="display: none; margin-top: 20px;"></div>
        </div>
    </div>

    <div id="game-over" style="display: none;">
        <h1 id="winner-text" style="color: var(--text-gold);">WINNER</h1>
        <button class="main-btn" onclick="location.reload()">Ch∆°i L·∫°i</button>
    </div>

    <div id="status-bar">
        <div id="turn-badge" class="badge">...</div>
        <div id="player-info-bar" style="display: flex; gap: 20px; align-items: center;">
            <div style="font-size: 0.9rem; color: #3498db;">
                <strong>Player 1:</strong> <span id="current-player1-name">Ng∆∞·ªùi ch∆°i 1</span> 
                <span id="current-player1-side" style="margin-left: 5px;"></span>
            </div>
            <div style="font-size: 0.9rem; color: #e74c3c;">
                <strong>Player 2:</strong> <span id="current-player2-name">Ng∆∞·ªùi ch∆°i 2</span>
                <span id="current-player2-side" style="margin-left: 5px;"></span>
            </div>
        </div>
        <div id="message" style="color: red; font-weight: bold;"></div>
    </div>

    <div class="game-wrapper">
        
        <div id="graveyard-bar">
            <div class="grave-row" id="grave-top">
                <div class="grave-label">Qu√¢n Tr·∫Øng<br>B·ªã B·∫Øt</div>
                </div>
            <div class="grave-row" id="grave-bot">
                <div class="grave-label">Qu√¢n ƒê·ªè<br>B·ªã B·∫Øt</div>
                </div>
        </div>

        <div id="board-container">
            <div id="board"></div>
            
            <div id="promotion-modal">
                <h3>PHONG C·∫§P!</h3>
                <div class="promo-options">
                    <button class="promo-btn" onclick="promotePawn('queen')" title="H·∫≠u">‚ôõ</button>
                    <button class="promo-btn" onclick="promotePawn('rook')" title="Xe">‚ôú</button>
                    <button class="promo-btn" onclick="promotePawn('bishop')" title="T∆∞·ª£ng">‚ôù</button>
                    <button class="promo-btn" onclick="promotePawn('knight')" title="M√£">‚ôû</button>
                </div>
            </div>
        </div>
    </div>

    <div id="control-bar">
        <button class="ctrl-btn" id="btn-prev" onclick="reviewMove(-1)" title="L√πi l·∫°i"><i class="fa-solid fa-backward"></i></button>
        <button class="ctrl-btn" id="btn-next" onclick="reviewMove(1)" title="Ti·∫øn t·ªõi"><i class="fa-solid fa-forward"></i></button>
        <button class="ctrl-btn active-live" id="btn-live" onclick="returnToLive()" title="V·ªÅ tr·∫≠n ƒë·∫•u hi·ªán t·∫°i">LIVE</button>
    </div>

    <div id="rules-container">
        <h2 class="rules-title">üìú LU·∫¨T CH∆†I CHI TI·∫æT</h2>
        <div class="rules-grid">
            <div class="rule-box">
                <h3>üè∞ Phe C·ªù Vua (Tr·∫Øng)</h3>
                <ul>
                    <li><strong>Lu·∫≠t di chuy·ªÉn:</strong> Tu√¢n theo lu·∫≠t C·ªù Vua qu·ªëc t·∫ø.</li>
                    <li><strong>Phong c·∫•p T·ªët:</strong> T·ªët khi ƒëi ƒë·∫øn h√†ng cu·ªëi c√πng (h√†ng ƒë√°y b√™n phe ƒë·ªè) ƒë∆∞·ª£c ph√©p phong c·∫•p th√†nh: H·∫≠u, Xe, T∆∞·ª£ng ho·∫∑c M√£.</li>
                    <li><strong>ƒê·∫∑c quy·ªÅn:</strong> Qu√¢n C·ªù Vua kh√¥ng b·ªã gi·ªõi h·∫°n b·ªüi S√¥ng hay Cung T∆∞·ªõng.</li>
                    <li><strong>Nh·∫≠p th√†nh:</strong> ƒê∆∞·ª£c ph√©p n·∫øu Vua v√† Xe ch∆∞a di chuy·ªÉn v√† ƒë∆∞·ªùng ƒëi tho√°ng.</li>
                </ul>
            </div>
            <div class="rule-box">
                <h3>‚õ©Ô∏è Phe C·ªù T∆∞·ªõng (ƒê·ªè)</h3>
                <ul>
                    <li><strong>Lu·∫≠t di chuy·ªÉn:</strong> Tu√¢n theo lu·∫≠t C·ªù T∆∞·ªõng c∆° b·∫£n.</li>
                    <li><strong>T·ªët:</strong> Qua s√¥ng ƒë∆∞·ª£c ph√©p ƒëi ngang v√† th·∫≥ng (m·ªói l·∫ßn 1 √¥).</li>
                    <li><strong>H·∫°n ch·∫ø:</strong> T∆∞·ªõng v√† Sƒ© kh√¥ng ƒë∆∞·ª£c ra kh·ªèi Cung (√¥ vu√¥ng 3x3). T∆∞·ª£ng kh√¥ng ƒë∆∞·ª£c ƒëi qua s√¥ng.</li>
                    <li><strong>C·∫£n ch√¢n:</strong> M√£ v√† T∆∞·ª£ng tu√¢n th·ªß lu·∫≠t c·∫£n ch√¢n nh∆∞ b√¨nh th∆∞·ªùng.</li>
                </ul>
            </div>
            <div class="rule-box full-width">
                <h3>‚öîÔ∏è Quy T·∫Øc Chung & Th·∫Øng Thua</h3>
                <ul>
                    <li><strong>M·ª•c ti√™u:</strong> Chi·∫øu b√≠ T∆∞·ªõng (C·ªù T∆∞·ªõng) ho·∫∑c Vua (C·ªù Vua).</li>
                    <li><strong>Kh·ªüi ƒë·∫ßu:</strong> H·ªá th·ªëng tung x√∫c x·∫Øc ng·∫´u nhi√™n ƒë·ªÉ ch·ªçn phe ƒëi tr∆∞·ªõc.</li>
                    <li><strong>ƒÇn qu√¢n:</strong> Qu√¢n phe n√†y ƒëi v√†o √¥ qu√¢n phe kia ƒëang ƒë·ª©ng s·∫Ω ƒÉn qu√¢n ƒë√≥.</li>
                </ul>
            </div>
        </div>
    </div>

<script>
    // --- AUDIO ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        if (type === 'move') {
            osc.frequency.setValueAtTime(600, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.start(); osc.stop(audioCtx.currentTime + 0.1);
        } else {
            osc.type = 'square'; osc.frequency.setValueAtTime(150, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.2);
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            osc.start(); osc.stop(audioCtx.currentTime + 0.2);
        }
    }

    // --- CONFIG ---
    const ROWS = 10; const COLS = 9;
    const XQ_CHARS = { "xe": "Ëªä", "m√£": "È¶¨", "t∆∞·ª£ng": "Áõ∏", "sƒ©": "‰ªï", "t∆∞·ªõng": "Â∏•", "ph√°o": "ÁÇÆ", "t·ªët": "ÂÖµ" };
    
    // --- STATE ---
    let pieces = [];
    let deadChess = []; // Qu√¢n tr·∫Øng ch·∫øt
    let deadXQ = [];    // Qu√¢n ƒë·ªè ch·∫øt
    let currentTurn = "chess";
    let selectedPiece = null;
    let isGameOver = false;
    let lastMove = null; 
    let gameHistory = []; 
    let viewIndex = -1;
    
    // Player info
    let player1Name = "Ng∆∞·ªùi ch∆°i 1";
    let player2Name = "Ng∆∞·ªùi ch∆°i 2";
    let player1Side = null;
    let player2Side = null;
    let coinFlipped = false;
    let diceRolled = { player1: false, player2: false };
    let diceResults = { player1: null, player2: null };
    let boardRotated = false; // Track board rotation state
    let isReviewing = false;
    let pendingPromotion = null; // Qu√¢n T·ªët ƒëang ch·ªù phong c·∫•p

    // Elements
    const boardEl = document.getElementById("board");
    const turnBadge = document.getElementById("turn-badge");
    const msgEl = document.getElementById("message");
    const graveTop = document.getElementById("grave-top"); // Ch·ª©a qu√¢n tr·∫Øng ch·∫øt
    const graveBot = document.getElementById("grave-bot"); // Ch·ª©a qu√¢n ƒë·ªè ch·∫øt
    const btnPrev = document.getElementById("btn-prev");
    const btnNext = document.getElementById("btn-next");
    const btnLive = document.getElementById("btn-live");
    const promoModal = document.getElementById("promotion-modal");

    const INITIAL_SETUP = [
        { type: "rook", side: "chess", r: 0, c: 0, hasMoved: false }, { type: "knight", side: "chess", r: 0, c: 1 },
        { type: "bishop", side: "chess", r: 0, c: 2 }, { type: "queen", side: "chess", r: 0, c: 3 },
        { type: "king", side: "chess", r: 0, c: 4, hasMoved: false }, { type: "bishop", side: "chess", r: 0, c: 5 },
        { type: "knight", side: "chess", r: 0, c: 6 }, { type: "rook", side: "chess", r: 0, c: 7, hasMoved: false },
        ...Array.from({ length: 8 }, (_, i) => ({ type: "pawn", side: "chess", r: 1, c: i })),
        { type: "xe", side: "xiangqi", r: 9, c: 0 }, { type: "m√£", side: "xiangqi", r: 9, c: 1 },
        { type: "t∆∞·ª£ng", side: "xiangqi", r: 9, c: 2 }, { type: "sƒ©", side: "xiangqi", r: 9, c: 3 },
        { type: "t∆∞·ªõng", side: "xiangqi", r: 9, c: 4 }, { type: "sƒ©", side: "xiangqi", r: 9, c: 5 },
        { type: "t∆∞·ª£ng", side: "xiangqi", r: 9, c: 6 }, { type: "m√£", side: "xiangqi", r: 9, c: 7 },
        { type: "xe", side: "xiangqi", r: 9, c: 8 },
        { type: "ph√°o", side: "xiangqi", r: 7, c: 1 }, { type: "ph√°o", side: "xiangqi", r: 7, c: 7 },
        ...[0,2,4,6,8].map(c => ({ type: "t·ªët", side: "xiangqi", r: 6, c })),
    ];

    // --- COIN FLIP ---
    function flipCoin() {
        if (coinFlipped) return;
        
        const coin = document.getElementById('coin');
        const resultEl = document.getElementById('coin-result');
        
        coin.classList.add('flipping');
        coin.style.pointerEvents = 'none';
        
        setTimeout(() => {
            const result = Math.random() < 0.5 ? 'heads' : 'tails';
            coinFlipped = true;
            
            // Assign sides based on coin flip
            if (result === 'heads') {
                // Heads = C·ªù Vua
                player1Side = 'chess';
                player2Side = 'xiangqi';
            } else {
                // Tails = C·ªù T∆∞·ªõng
                player1Side = 'xiangqi';
                player2Side = 'chess';
            }
            
            const resultText = result === 'heads' 
                ? 'ü™ô M·∫∂T NG·ª∞A (C·ªù Vua) - Player 1 ch∆°i C·ªù Vua, Player 2 ch∆°i C·ªù T∆∞·ªõng'
                : 'ü™ô M·∫∂T T∆Ø·ªöNG (C·ªù T∆∞·ªõng) - Player 1 ch∆°i C·ªù T∆∞·ªõng, Player 2 ch∆°i C·ªù Vua';
            
            resultEl.textContent = resultText;
            resultEl.style.display = 'block';
            
            // Update player sides display
            document.getElementById('player1-side').textContent = player1Side === 'chess' ? 'üè∞ C·ªù Vua (Tr·∫Øng)' : '‚õ©Ô∏è C·ªù T∆∞·ªõng (ƒê·ªè)';
            document.getElementById('player2-side').textContent = player2Side === 'chess' ? 'üè∞ C·ªù Vua (Tr·∫Øng)' : '‚õ©Ô∏è C·ªù T∆∞·ªõng (ƒê·ªè)';
            
            // Show dice section
            setTimeout(() => {
                document.getElementById('coin-flip-section').style.display = 'none';
                document.getElementById('dice-section').style.display = 'block';
            }, 2000);
        }, 2000);
    }
    
    // --- DICE ROLL ---
    function rollDice(playerNum) {
        if (diceRolled[`player${playerNum}`]) return;
        
        const dice = document.getElementById(`dice-player${playerNum}`);
        const resultEl = document.getElementById(`dice-result-player${playerNum}`);
        
        dice.classList.add('rolling');
        dice.style.pointerEvents = 'none';
        
        setTimeout(() => {
            const player1Result = Math.floor(Math.random() * 6) + 1;
            const player2Result = Math.floor(Math.random() * 6) + 1;
            const total = player1Result + player2Result;
            
            diceRolled[`player${playerNum}`] = true;
            diceResults[`player${playerNum}`] = { player1Result, player2Result, total };
            
            resultEl.textContent = `${player1Result} + ${player2Result} = ${total}`;
            
            // Check if both players have rolled
            if (diceRolled.player1 && diceRolled.player2) {
                const total1 = diceResults.player1.total;
                const total2 = diceResults.player2.total;
                
                let firstTurn;
                let winnerName;
                
                if (total1 > total2) {
                    firstTurn = player1Side;
                    winnerName = player1Name;
                } else if (total2 > total1) {
                    firstTurn = player2Side;
                    winnerName = player2Name;
                } else {
                    // Tie - random
                    const randomWinner = Math.random() < 0.5 ? 1 : 2;
                    firstTurn = randomWinner === 1 ? player1Side : player2Side;
                    winnerName = randomWinner === 1 ? player1Name : player2Name;
                }
                
                currentTurn = firstTurn;
                const firstTurnSide = firstTurn === 'chess' ? 'üè∞ C·ªù Vua' : '‚õ©Ô∏è C·ªù T∆∞·ªõng';
                
                const finalResultEl = document.getElementById('dice-final-result');
                finalResultEl.innerHTML = `
                    <div>üéØ <strong>${winnerName}</strong> ƒëi tr∆∞·ªõc (${firstTurnSide})</div>
                    <div style="font-size: 0.9rem; margin-top: 10px; color: #aaa;">
                        Player 1: ${total1} | Player 2: ${total2}
                    </div>
                `;
                finalResultEl.style.display = 'block';
                
                // Start game after 2 seconds
                setTimeout(() => {
                    startGame();
                }, 2000);
            }
        }, 1500);
    }
    
    // --- START GAME ---
    function startGame() {
        // Get player names
        player1Name = document.getElementById('player1-name-input').value.trim() || 'Ng∆∞·ªùi ch∆°i 1';
        player2Name = document.getElementById('player2-name-input').value.trim() || 'Ng∆∞·ªùi ch∆°i 2';
        
        pieces = JSON.parse(JSON.stringify(INITIAL_SETUP));
        deadChess = []; 
        deadXQ = [];
        
        // Update player info bar
        document.getElementById('current-player1-name').textContent = player1Name;
        document.getElementById('current-player2-name').textContent = player2Name;
        document.getElementById('current-player1-side').textContent = player1Side === 'chess' ? '(üè∞ C·ªù Vua)' : '(‚õ©Ô∏è C·ªù T∆∞·ªõng)';
        document.getElementById('current-player2-side').textContent = player2Side === 'chess' ? '(üè∞ C·ªù Vua)' : '(‚õ©Ô∏è C·ªù T∆∞·ªõng)';
        
        // Rotate board for initial turn
        rotateBoardForTurn(currentTurn);
        
                    document.getElementById("start-screen").style.display = "none";
                    saveState();
                    drawBoard();
    }

    // --- LOGIC PHONG C·∫§P ---
    function promotePawn(newType) {
        if (!pendingPromotion) return;
        
        pendingPromotion.type = newType;
        playSound('capture'); // Sound effect
        promoModal.style.display = 'none';
        pendingPromotion = null;

        // Sau khi ch·ªçn xong m·ªõi k·∫øt th√∫c l∆∞·ª£t
        finishTurn();
    }

    function finishTurn() {
        selectedPiece = null;
        currentTurn = currentTurn === "chess" ? "xiangqi" : "chess";
        
        // Rotate board for new turn
        rotateBoardForTurn(currentTurn);

        if (isCheckmate(currentTurn)) {
            isGameOver = true;
            // Determine winner
            const winnerSide = currentTurn === "chess" ? "xiangqi" : "chess";
            let winnerName = '';
            if (player1Side && player2Side) {
                winnerName = winnerSide === player1Side ? player1Name : player2Name;
            }
            const winnerText = winnerName ? `${winnerName.toUpperCase()} TH·∫ÆNG!` : (winnerSide === "chess" ? "C·ªú VUA" : "C·ªú T∆Ø·ªöNG") + " TH·∫ÆNG!";
            document.getElementById("winner-text").innerText = winnerText;
            document.getElementById("game-over").style.display = "flex";
        }
        
        saveState();
        drawBoard();
    }

    // --- HISTORY ---
    function saveState() {
        const state = {
            pieces: JSON.parse(JSON.stringify(pieces)),
            deadChess: [...deadChess], deadXQ: [...deadXQ],
            turn: currentTurn, lastMove: lastMove ? {...lastMove} : null, isGameOver: isGameOver
        };
        gameHistory.push(state);
        viewIndex = gameHistory.length - 1;
        updateControls();
    }

    function reviewMove(step) {
        let newIndex = viewIndex + step;
        if (newIndex >= 0 && newIndex < gameHistory.length) {
            viewIndex = newIndex; isReviewing = (viewIndex !== gameHistory.length - 1);
            drawBoard(gameHistory[viewIndex]); updateControls();
        }
    }

    function returnToLive() {
        viewIndex = gameHistory.length - 1; isReviewing = false;
        drawBoard(gameHistory[viewIndex]); updateControls();
    }

    function updateControls() {
        btnPrev.disabled = viewIndex <= 0; btnNext.disabled = viewIndex >= gameHistory.length - 1;
        if (isReviewing) {
            btnLive.classList.remove("active-live"); btnLive.innerText = "QUAY L·∫†I"; boardEl.style.borderColor = "#f1c40f";
        } else {
            btnLive.classList.add("active-live"); btnLive.innerText = "LIVE"; boardEl.style.borderColor = "#333";
        }
    }

    // --- DRAWING ---
    function drawBoard(state = null) {
        if (!state) state = { pieces, deadChess, deadXQ, turn: currentTurn, lastMove };
        const { pieces: rPieces, turn: rTurn, deadChess: rDC, deadXQ: rDX, lastMove: rLM } = state;

        boardEl.innerHTML = "";
        
        if (isReviewing) {
            turnBadge.innerText = `XEM L·∫†I (${viewIndex}/${gameHistory.length-1})`;
            turnBadge.style.background = "#555"; turnBadge.style.color = "#ccc";
        } else {
            updateStatusUI(rTurn, rPieces);
        }

        // Draw Grid
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                let square = document.createElement("div"); square.className = "square";
                if (r < 4 && (r + c) % 2 === 1) square.classList.add("dark");
                if (r === 4) { square.classList.add("river"); square.innerHTML = "<span>S·ªû H√Ä - H√ÅN GI·ªöI</span>"; }
                if (r > 4) {
                    square.classList.add("xq-grid");
                    if (r === 7 && c === 3) square.classList.add("palace-slash");
                    if (r === 7 && c === 5) square.classList.add("palace-backslash");
                    if (r === 8 && c === 4) square.innerHTML += `<div style="position:absolute;width:100%;height:1px;background:rgba(0,0,0,0.2);transform:rotate(45deg);"></div><div style="position:absolute;width:100%;height:1px;background:rgba(0,0,0,0.2);transform:rotate(-45deg);"></div>`;
                }
                if (rLM && ((r===rLM.from.r && c===rLM.from.c) || (r===rLM.to.r && c===rLM.to.c))) square.classList.add("last-move");
                if (!isReviewing) square.onclick = () => handleSquareClick(r, c);
                boardEl.appendChild(square);
            }
        }

        // Draw Pieces
        let kingInCheck = isKingInCheck(rTurn, rPieces);
        rPieces.forEach(p => {
            let idx = p.r * COLS + p.c; if(idx >= boardEl.children.length) return;
            let square = boardEl.children[idx]; let el = createPieceEl(p);
            if (!isReviewing && selectedPiece && selectedPiece.r === p.r && selectedPiece.c === p.c) el.classList.add("selected");
            if (kingInCheck && (p.type === "king" || p.type === "t∆∞·ªõng") && p.side === rTurn) el.classList.add("in-check");
            if (!isReviewing) el.onclick = (e) => { e.stopPropagation(); handlePieceClick(p); }; else el.style.cursor = "default";
            square.appendChild(el);
        });

        // Draw Hint Dots
        if (!isReviewing && selectedPiece && !isGameOver) {
            getSafeMoves(selectedPiece).forEach(m => {
                let idx = m.r * COLS + m.c;
                if(boardEl.children[idx]) {
                    let dot = document.createElement("div"); dot.className = "move-dot";
                    if (m.isCastle) dot.style.background = "gold";
                    boardEl.children[idx].appendChild(dot);
                }
            });
        }
        
        // Render Graveyards
        renderGraveyards(rDC, rDX);
        
        // Re-append Modal if cleared
        if(!isReviewing) boardEl.appendChild(promoModal); 
    }

    function createPieceEl(p) {
        let el = document.createElement("div"); el.className = "piece";
        if (p.side === "chess") { el.classList.add("chess-side"); el.innerHTML = getChessIcon(p.type); }
        else { el.classList.add("xq-side"); el.innerText = XQ_CHARS[p.type] || p.type; }
        return el;
    }

    function renderGraveyards(dChess, dXQ) {
        graveTop.innerHTML = '<div class="grave-label">Qu√¢n Tr·∫Øng<br>B·ªã B·∫Øt</div>';
        graveBot.innerHTML = '<div class="grave-label">Qu√¢n ƒê·ªè<br>B·ªã B·∫Øt</div>';
        
        // Nh√≥m v√† ƒë·∫øm qu√¢n Tr·∫Øng b·ªã b·∫Øt
        let chessCount = {};
        dChess.forEach(p => { 
            chessCount[p] = (chessCount[p] || 0) + 1;
        });
        
        Object.keys(chessCount).forEach(type => {
            let count = chessCount[type];
            let el = document.createElement("div");
            el.classList.add("captured-piece", "chess-side");
            
            let iconEl = document.createElement("div");
            iconEl.className = "piece-icon";
            iconEl.innerHTML = getChessIcon(type);
            el.appendChild(iconEl);
            
            if (count > 1) {
                let countEl = document.createElement("span");
                countEl.className = "count";
                countEl.textContent = `x${count}`;
                el.appendChild(countEl);
            }
            
            graveTop.appendChild(el); 
        });

        // Nh√≥m v√† ƒë·∫øm qu√¢n ƒê·ªè b·ªã b·∫Øt
        let xqCount = {};
        dXQ.forEach(p => { 
            xqCount[p] = (xqCount[p] || 0) + 1;
        });
        
        Object.keys(xqCount).forEach(type => {
            let count = xqCount[type];
            let el = document.createElement("div");
            el.classList.add("captured-piece", "xq-side");
            
            let iconEl = document.createElement("div");
            iconEl.className = "piece-icon";
            iconEl.innerText = XQ_CHARS[type] || type;
            el.appendChild(iconEl);
            
            if (count > 1) {
                let countEl = document.createElement("span");
                countEl.className = "count";
                countEl.textContent = `x${count}`;
                el.appendChild(countEl);
            }
            
            graveBot.appendChild(el); 
        });
    }

    // Rotate board based on current player's perspective
    // Xiangqi player sees from bottom (rotated), Chess player sees from top (normal)
    function rotateBoardForTurn(turn) {
        const boardContainer = document.getElementById('board-container');
        const gameWrapper = document.querySelector('.game-wrapper');
        
        // Rotate board when it's Xiangqi (C·ªù T∆∞·ªõng) player's turn
        // This gives them their default perspective (from bottom)
        const shouldRotate = turn === "xiangqi";
        
        if (shouldRotate !== boardRotated) {
            boardRotated = shouldRotate;
            
            if (boardRotated) {
                boardContainer.classList.add('rotated');
                gameWrapper.classList.add('board-rotated');
            } else {
                boardContainer.classList.remove('rotated');
                gameWrapper.classList.remove('board-rotated');
            }
        }
    }

    function updateStatusUI(turn, _pieces) {
        // Rotate board for current turn
        rotateBoardForTurn(turn);
        
        // Determine which player's turn it is
        let currentPlayerName = '';
        if (player1Side && player2Side) {
            currentPlayerName = turn === player1Side ? player1Name : player2Name;
        }
        
        const turnText = turn === "chess" ? "C·ªù Vua" : "C·ªù T∆∞·ªõng";
        turnBadge.innerText = currentPlayerName ? `L∆∞·ª£t: ${currentPlayerName} (${turnText})` : `L∆∞·ª£t: ${turnText}`;
        turnBadge.style.background = turn === "chess" ? "#fff" : "#cc0000";
        turnBadge.style.color = turn === "chess" ? "#000" : "#fff";
        msgEl.innerText = isKingInCheck(turn, _pieces) ? "‚ö†Ô∏è CHI·∫æU T∆Ø·ªöNG!" : "";
    }

    // --- INTERACTION ---
    function handlePieceClick(p) {
        if (isGameOver || isReviewing || pendingPromotion) return;
        if (selectedPiece && selectedPiece.side !== p.side) { tryMoveTo(p.r, p.c); return; }
        if (p.side !== currentTurn) return;
        selectedPiece = p; drawBoard();
    }

    function handleSquareClick(r, c) {
        if (isGameOver || isReviewing || pendingPromotion || !selectedPiece) return;
        tryMoveTo(r, c);
    }

    function tryMoveTo(r, c) {
        let moves = getSafeMoves(selectedPiece);
        let move = moves.find(m => m.r === r && m.c === c);

        if (move) {
            lastMove = { from: {r: selectedPiece.r, c: selectedPiece.c}, to: {r: r, c: c} };
            let targetIdx = pieces.findIndex(p => p.r === r && p.c === c);
            if (targetIdx !== -1) {
                let captured = pieces[targetIdx]; pieces.splice(targetIdx, 1);
                if (captured.side === "chess") deadChess.push(captured.type); else deadXQ.push(captured.type);
                playSound('capture');
            } else playSound('move');

            if (move.isCastle) {
                if (c === 6) { let rook = pieces.find(p => p.r===0 && p.c===7); if (rook) { rook.c = 5; rook.hasMoved = true; } }
                if (c === 2) { let rook = pieces.find(p => p.r===0 && p.c===0); if (rook) { rook.c = 3; rook.hasMoved = true; } }
            }

            selectedPiece.r = r; selectedPiece.c = c;
            if (selectedPiece.type === "king" || selectedPiece.type === "rook") selectedPiece.hasMoved = true;

            // CHECK PROMOTION (T·ªët c·ªù vua ƒë·∫øn h√†ng cu·ªëi)
            if (selectedPiece.side === "chess" && selectedPiece.type === "pawn" && r === 9) {
                pendingPromotion = selectedPiece;
                // Hi·ªÉn th·ªã modal phong c·∫•p v√† D·ª™NG L·∫†I, ch∆∞a ƒë·ªïi l∆∞·ª£t
                promoModal.style.display = 'flex';
                drawBoard(); // V·∫Ω l·∫°i ƒë·ªÉ th·∫•y qu√¢n t·ªët ƒë√£ ƒëi xu·ªëng
                return; // THO√ÅT H√ÄM, ch·ªù ng∆∞·ªùi ch∆°i ch·ªçn
            }

            finishTurn();
        }
    }

    // --- LOGIC MOVES ---
    function inside(r, c) { return r >= 0 && r < ROWS && c >= 0 && c < COLS; }
    function isOccupied(r, c, _pieces = pieces) { return _pieces.some(p => p.r === r && p.c === c); }
    function isAlly(r, c, side, _pieces = pieces) { return _pieces.some(p => p.r === r && p.c === c && p.side === side); }
    function isInPalace(r, c) { return r >= 7 && r <= 9 && c >= 3 && c <= 5; }

    function isSquareAttacked(r, c, sideBeingAttacked, _pieces = pieces) {
        let enemySide = sideBeingAttacked === "chess" ? "xiangqi" : "chess";
        let enemies = _pieces.filter(p => p.side === enemySide);
        for (let enemy of enemies) { if (getPseudoMoves(enemy, _pieces).some(m => m.r === r && m.c === c)) return true; }
        return false;
    }

    function isKingInCheck(side, _pieces = pieces) {
        let kingType = side === "chess" ? "king" : "t∆∞·ªõng";
        let king = _pieces.find(p => p.side === side && p.type === kingType);
        if (!king) return true; 
        return isSquareAttacked(king.r, king.c, side, _pieces);
    }

    function isCheckmate(side) {
        if (!isKingInCheck(side)) return false;
        let myPieces = pieces.filter(p => p.side === side);
        for (let p of myPieces) { if (getSafeMoves(p).length > 0) return false; }
        return true;
    }

    function getSafeMoves(p) {
        let moves = getPseudoMoves(p, pieces);
        return moves.filter(m => {
            let oldR = p.r, oldC = p.c;
            let capIdx = pieces.findIndex(t => t.r === m.r && t.c === m.c);
            let capPiece = null;
            if (capIdx !== -1) { capPiece = pieces[capIdx]; pieces.splice(capIdx, 1); }
            p.r = m.r; p.c = m.c;
            let safe = !isKingInCheck(p.side, pieces);
            p.r = oldR; p.c = oldC;
            if (capPiece) pieces.splice(capIdx, 0, capPiece);
            return safe;
        });
    }

    function getPseudoMoves(p, _pieces) {
        if (p.side === "chess") return getChessMoves(p, _pieces);
        return getXQMoves(p, _pieces);
    }

    function getChessMoves(p, _pieces) {
        let moves = [];
        const dirs = { rook: [[1,0],[-1,0],[0,1],[0,-1]], bishop: [[1,1],[1,-1],[-1,1],[-1,-1]], queen: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]] };
        if (p.type === "pawn") {
            if (!isOccupied(p.r+1, p.c, _pieces) && inside(p.r+1, p.c)) moves.push({r: p.r+1, c: p.c});
            if (p.r === 1 && !isOccupied(p.r+1, p.c, _pieces) && !isOccupied(p.r+2, p.c, _pieces)) moves.push({r: p.r+2, c: p.c});
            [[1,1], [1,-1]].forEach(([dr, dc]) => {
                let nr = p.r+dr, nc = p.c+dc;
                if (inside(nr, nc) && isOccupied(nr, nc, _pieces) && !isAlly(nr, nc, p.side, _pieces)) moves.push({r: nr, c: nc});
            });
        }
        else if (p.type === "knight") {
            [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dr,dc]) => {
                let nr = p.r+dr, nc = p.c+dc; if (inside(nr, nc) && !isAlly(nr, nc, p.side, _pieces)) moves.push({r: nr, c: nc});
            });
        }
        else if (p.type === "king") {
            [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc]) => {
                let nr = p.r+dr, nc = p.c+dc; if (inside(nr, nc) && !isAlly(nr, nc, p.side, _pieces)) moves.push({r: nr, c: nc});
            });
            if (_pieces === pieces && !p.hasMoved && !isKingInCheck("chess")) {
                if (!isOccupied(0, 5) && !isOccupied(0, 6)) {
                    let rook = _pieces.find(rp => rp.r===0 && rp.c===7 && rp.type==="rook" && !rp.hasMoved);
                    if (rook && !isSquareAttacked(0,5,"chess") && !isSquareAttacked(0,6,"chess")) moves.push({r: 0, c: 6, isCastle: true});
                }
                if (!isOccupied(0, 1) && !isOccupied(0, 2) && !isOccupied(0, 3)) {
                    let rook = _pieces.find(rp => rp.r===0 && rp.c===0 && rp.type==="rook" && !rp.hasMoved);
                    if (rook && !isSquareAttacked(0,3,"chess") && !isSquareAttacked(0,2,"chess")) moves.push({r: 0, c: 2, isCastle: true});
                }
            }
        }
        else if (dirs[p.type]) {
            dirs[p.type].forEach(([dr, dc]) => {
                let nr = p.r+dr, nc = p.c+dc;
                while (inside(nr, nc)) {
                    if (isAlly(nr, nc, p.side, _pieces)) break; moves.push({r: nr, c: nc}); if (isOccupied(nr, nc, _pieces)) break; nr += dr; nc += dc;
                }
            });
        }
        return moves;
    }

    function getXQMoves(p, _pieces) {
        let moves = [];
        const checkLine = (dirs, isCannon=false) => {
             dirs.forEach(([dr, dc]) => {
                let nr = p.r+dr, nc = p.c+dc; let hurdle=false; 
                while (inside(nr, nc)) {
                    let targetIdx = _pieces.findIndex(t => t.r === nr && t.c === nc);
                    let targetPiece = targetIdx !== -1 ? _pieces[targetIdx] : null;

                    if (!hurdle) {
                        if (!targetPiece) moves.push({r: nr, c: nc});
                        else {
                            if (!isCannon) {
                                if (targetPiece.side !== p.side) moves.push({r: nr, c: nc});
                                break;
                            } else {
                                if (targetPiece.side === "chess" && targetPiece.type === "pawn") break;
                                else hurdle = true;
                            }
                        }
                    } else {
                        if (targetPiece) {
                            if (targetPiece.side !== p.side) moves.push({r: nr, c: nc});
                            break;
                        }
                    }
                    nr += dr; nc += dc;
                }
            });
        }

        if (p.type==="xe") checkLine([[1,0],[-1,0],[0,1],[0,-1]]);
        if (p.type==="ph√°o") checkLine([[1,0],[-1,0],[0,1],[0,-1]], true);
        if (p.type==="m√£") {
            [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dr,dc]) => {
                let nr=p.r+dr, nc=p.c+dc; if(inside(nr,nc) && !isAlly(nr,nc,p.side, _pieces)) moves.push({r:nr, c:nc});
            });
        }
        if (p.type==="t·ªët") {
             let nr=p.r-1; if(inside(nr,p.c) && !isAlly(nr,p.c,p.side, _pieces)) moves.push({r:nr, c:p.c});
             if(p.r<5) { if(inside(p.r,p.c-1)&&!isAlly(p.r,p.c-1,p.side, _pieces)) moves.push({r:p.r,c:p.c-1}); if(inside(p.r,p.c+1)&&!isAlly(p.r,p.c+1,p.side, _pieces)) moves.push({r:p.r,c:p.c+1}); }
        }
        if (p.type==="t∆∞·ªõng"||p.type==="sƒ©") {
            let dirs = p.type==="t∆∞·ªõng" ? [[1,0],[-1,0],[0,1],[0,-1]] : [[1,1],[1,-1],[-1,1],[-1,-1]];
            dirs.forEach(([dr,dc]) => {
                let nr=p.r+dr, nc=p.c+dc; if(inside(nr,nc) && isInPalace(nr,nc) && !isAlly(nr,nc,p.side, _pieces)) moves.push({r:nr, c:nc});
            });
        }
        if (p.type==="t∆∞·ª£ng") {
             [[2,2],[2,-2],[-2,2],[-2,-2]].forEach(([dr,dc]) => {
                let nr=p.r+dr, nc=p.c+dc;
                if(inside(nr,nc) && nr>=5 && !isAlly(nr,nc,p.side, _pieces)) {
                    let er=p.r+dr/2, ec=p.c+dc/2; if(!isOccupied(er,ec, _pieces)) moves.push({r:nr, c:nc});
                }
            });
        }
        return moves;
    }

    function getChessIcon(type) {
        switch (type) {
            case "king": return "‚ôö"; case "queen": return "‚ôõ"; case "rook": return "‚ôú";
            case "bishop": return "‚ôù"; case "knight": return "‚ôû"; case "pawn": return "‚ôü"; default: return "?";
        }
    }
</script>
</body>
</html>