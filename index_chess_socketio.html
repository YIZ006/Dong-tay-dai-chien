<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ƒê√¥ng T√¢y ƒê·∫°i Chi·∫øn - Online Multiplayer (Socket.io)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Socket.io Client -->
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
    <style>
        :root {
            --cell: 60px;
            --board-bg: #deb887;
            --river-color: #87ceeb;
            --bg-color: #1a1a1a;
            --panel-bg: #222;
            --text-gold: #f1c40f;
        }
        
        body {
            background: var(--bg-color);
            color: white;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            min-height: 100vh;
            user-select: none;
            overflow-x: hidden; /* Tr√°nh thanh cu·ªôn ngang */
            padding-bottom: 50px; /* Ch·ª´a ch·ªó cho footer */
        }

        /* --- LAYOUT --- */
        .game-wrapper {
            display: flex;
            flex-direction: column; /* X·∫øp d·ªçc */
            align-items: center;
            gap: 10px;
            margin-top: 5px;
        }

        /* --- TOP GRAVEYARD BAR --- */
        #graveyard-bar {
            width: calc(var(--cell) * 9 + 20px); /* B·∫±ng chi·ªÅu r·ªông b√†n c·ªù */
            background: #2a2a2a;
            border: 2px solid #555;
            border-radius: 8px;
            padding: 4px 8px;
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .grave-row {
            height: 28px;
            display: flex;
            align-items: center;
            gap: 3px;
            background: rgba(0,0,0,0.3);
            padding: 0 8px;
            border-radius: 4px;
            flex-wrap: wrap;
        }
        
        /* Nh√£n cho h√†ng t√π binh */
        .grave-label {
            font-size: 8px; color: #888; width: 50px; flex-shrink: 0;
            text-transform: uppercase; font-weight: bold; line-height: 1.2;
        }

        /* Qu√¢n c·ªù trong t√π binh */
        .captured-piece {
            display: flex;
            align-items: center;
            gap: 2px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            padding: 2px 6px;
            flex-shrink: 0;
        }
        .captured-piece .piece-icon {
            width: 18px;
            height: 18px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .captured-piece.chess-side { 
            font-size: 12px !important; 
            color: #bbb; 
            text-shadow: none; 
        }
        .captured-piece.chess-side .piece-icon {
            font-size: 12px !important;
            color: #bbb;
        }
        .captured-piece.xq-side { 
            font-size: 10px !important; 
            color: #e74c3c; 
            border: 1px solid #8b0000; 
            background: #f5deb3; 
        }
        .captured-piece.xq-side .piece-icon {
            font-size: 10px !important;
            color: #e74c3c;
        }
        .captured-piece .count {
            font-size: 10px;
            color: #aaa;
            font-weight: bold;
            margin-left: 2px;
        }
        .captured-piece.xq-side .count {
            color: #8b0000;
        }

        /* --- BOARD --- */
        #board-container {
            padding: 10px; background: #5c4033; border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            position: relative;
            overflow: visible; /* Cho ph√©p hi·ªÉn th·ªã g√≥c b√†n c·ªù */
            margin: 10px;
        }
        
        /* Fix cho mobile - kh√¥ng b·ªã khu·∫•t g√≥c b√†n c·ªù */
        @media (max-width: 768px) {
            #board-container {
                padding: 5px;
                margin: 5px;
                overflow: visible;
            }
            #board {
                overflow: visible;
            }
            body {
                overflow-x: auto; /* Cho ph√©p scroll ngang n·∫øu c·∫ßn */
            }
        }
        #board {
            display: grid;
            grid-template-columns: repeat(9, var(--cell));
            grid-template-rows: repeat(10, var(--cell));
            background: var(--board-bg);
            border: 2px solid #333;
            position: relative;
        }

        /* --- CONTROLS --- */
        #control-bar {
            margin-top: 10px; display: flex; gap: 10px; background: #333;
            padding: 8px 20px; border-radius: 50px; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .ctrl-btn {
            width: 40px; height: 40px; border-radius: 50%; border: none;
            background: #444; color: white; font-size: 1rem; cursor: pointer;
            transition: 0.2s; display: flex; justify-content: center; align-items: center;
        }
        .ctrl-btn:hover { background: #666; transform: scale(1.1); }
        .ctrl-btn:disabled { opacity: 0.3; cursor: not-allowed; transform: none; }
        .ctrl-btn.active-live { background: #e74c3c; box-shadow: 0 0 10px red; width: auto; padding: 0 20px; border-radius: 20px; font-weight: bold;}

        /* --- RULES SECTION (M·ªöI) --- */
        #rules-container {
            margin-top: 25px;
            width: 100%;
            max-width: 650px;
            background: #232323;
            border: 1px solid #444;
            border-radius: 12px;
            padding: 20px;
            box-sizing: border-box;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }
        .rules-title {
            text-align: center; color: var(--text-gold); margin-top: 0;
            border-bottom: 1px solid #444; padding-bottom: 10px; font-size: 1.4rem;
        }
        .rules-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px;
        }
        .rule-box h3 {
            color: #e74c3c; font-size: 1.1rem; margin-bottom: 10px; margin-top: 0;
            display: flex; align-items: center; gap: 8px;
        }
        .rule-box:first-child h3 { color: #dcdcdc; } /* M√†u ti√™u ƒë·ªÅ phe C·ªù Vua */
        .rule-box ul {
            padding-left: 20px; margin: 0; font-size: 0.9rem; color: #ccc; line-height: 1.6;
        }
        .rule-box li { margin-bottom: 6px; }
        .full-width {
            grid-column: span 2; border-top: 1px dashed #444; padding-top: 15px; margin-top: 5px;
        }
        @media (max-width: 700px) {
            .rules-grid { grid-template-columns: 1fr; }
            .full-width { grid-column: span 1; }
        }

        /* --- PROMOTION MODAL --- */
        #promotion-modal {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85); z-index: 50; border-radius: 8px;
            display: none; flex-direction: column; justify-content: center; align-items: center;
        }
        #promotion-modal h3 { color: var(--text-gold); margin-bottom: 20px; font-size: 1.5rem; }
        .promo-options { display: flex; gap: 20px; }
        .promo-btn {
            width: 60px; height: 60px; font-size: 40px; background: #444; color: #fdf5e6;
            border: 2px solid #fff; border-radius: 10px; cursor: pointer; transition: 0.2s;
        }
        .promo-btn:hover { background: #666; transform: scale(1.1); border-color: var(--text-gold); }

        /* --- VISUALS --- */
        .square { width: var(--cell); height: var(--cell); display: flex; justify-content: center; align-items: center; position: relative; }
        .square.dark { background: rgba(139, 69, 19, 0.3); }
        .river { background: var(--river-color) !important; position: relative; }
        .river span { position: absolute; width: 100%; text-align: center; font-size: 11px; color: #444; font-weight: bold; pointer-events: none; z-index: 0; }
        .last-move { background-color: rgba(255, 255, 0, 0.4) !important; box-shadow: inset 0 0 10px orange; }

        .xq-grid::before { content: ''; position: absolute; top: 50%; left: 0; right: 0; height: 1px; background: rgba(0,0,0,0.15); z-index: 0; }
        .xq-grid::after { content: ''; position: absolute; top: 0; bottom: 0; left: 50%; width: 1px; background: rgba(0,0,0,0.15); z-index: 0; }
        .palace-slash { background: linear-gradient(to bottom right, transparent calc(50% - 1px), rgba(0,0,0,0.2) 50%, transparent calc(50% + 1px)); }
        .palace-backslash { background: linear-gradient(to bottom left, transparent calc(50% - 1px), rgba(0,0,0,0.2) 50%, transparent calc(50% + 1px)); }

        .piece { width: 85%; height: 85%; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: transform 0.2s; position: relative; z-index: 10; }
        .piece:hover { transform: scale(1.1); }
        .piece.selected { transform: scale(1.15); filter: drop-shadow(0 0 5px yellow); }
        .in-check { background-color: rgba(255, 0, 0, 0.6) !important; box-shadow: 0 0 15px red; border-radius: 50%; }

        .piece.chess-side { font-size: 40px; color: #fdf5e6; text-shadow: 1px 1px 2px black; }
        .piece.xq-side { background: #f5deb3; border-radius: 50%; border: 3px solid #8b0000; color: #cc0000; font-family: "KaiTi", serif; font-weight: bold; font-size: 22px; box-shadow: 2px 2px 5px rgba(0,0,0,0.4); }
        .piece.xq-side::before { content: ''; position: absolute; top: 2px; left: 2px; right: 2px; bottom: 2px; border-radius: 50%; border: 1px dashed rgba(139, 0, 0, 0.3); }

        .move-dot { width: 16px; height: 16px; background: rgba(0, 255, 0, 0.6); border-radius: 50%; position: absolute; z-index: 20; pointer-events: none; box-shadow: 0 0 5px #fff; }

        #status-bar { display: flex; gap: 20px; align-items: center; margin-bottom: 5px; }
        .badge { padding: 5px 25px; border-radius: 15px; font-weight: bold; border: 2px solid #fff; width: 250px; text-align: center; font-size: 1.1rem; }
        
        /* Chat Box Styles */
        #chat-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            max-height: 400px;
            background: rgba(34, 34, 34, 0.95);
            border: 2px solid #555;
            border-radius: 10px;
            display: none;
            flex-direction: column;
            z-index: 50;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }
        #chat-container.show {
            display: flex;
        }
        #chat-header {
            background: #2c3e50;
            padding: 10px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        #chat-header h3 {
            margin: 0;
            font-size: 1rem;
            color: #f1c40f;
        }
        #chat-toggle {
            background: none;
            border: none;
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0 5px;
        }
        #chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            max-height: 250px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .chat-message {
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.9rem;
            word-wrap: break-word;
            max-width: 85%;
        }
        .chat-message.own {
            background: #3498db;
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 2px;
        }
        .chat-message.other {
            background: #555;
            color: #fff;
            align-self: flex-start;
            border-bottom-left-radius: 2px;
        }
        .chat-message .sender {
            font-weight: bold;
            font-size: 0.8rem;
            margin-bottom: 3px;
            opacity: 0.9;
        }
        .chat-message .time {
            font-size: 0.7rem;
            opacity: 0.7;
            margin-top: 3px;
        }
        #chat-input-container {
            display: flex;
            gap: 5px;
            padding: 10px;
            border-top: 1px solid #555;
            position: relative;
        }
        #chat-input {
            flex: 1;
            padding: 8px;
            border: 1px solid #555;
            border-radius: 5px;
            background: #222;
            color: white;
            font-size: 0.9rem;
        }
        #chat-input:focus {
            outline: none;
            border-color: #3498db;
        }
        #chat-emoji-btn {
            padding: 8px 10px;
            background: #555;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #chat-emoji-btn:hover {
            background: #666;
        }
        #chat-send {
            padding: 8px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        #chat-send:hover {
            background: #2980b9;
        }
        #chat-send:disabled {
            background: #555;
            cursor: not-allowed;
        }
        /* Emoji Picker */
        #emoji-picker {
            position: absolute;
            bottom: 100%;
            right: 0;
            width: 280px;
            height: 300px;
            background: #2c3e50;
            border: 2px solid #555;
            border-radius: 10px;
            padding: 10px;
            display: none;
            flex-direction: column;
            z-index: 100;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.5);
            margin-bottom: 5px;
        }
        #emoji-picker.show {
            display: flex;
        }
        #emoji-picker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 8px;
            border-bottom: 1px solid #555;
            margin-bottom: 8px;
        }
        #emoji-picker-header h4 {
            margin: 0;
            font-size: 0.9rem;
            color: #f1c40f;
        }
        #emoji-picker-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0 5px;
        }
        #emoji-picker-body {
            flex: 1;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 5px;
            padding: 5px;
        }
        .emoji-item {
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            text-align: center;
            transition: background 0.2s;
            user-select: none;
        }
        .emoji-item:hover {
            background: rgba(255,255,255,0.1);
        }
        .emoji-item:active {
            transform: scale(0.9);
        }
        #chat-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #3498db;
            color: white;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
            z-index: 49;
            display: none;
        }
        #chat-button:hover {
            background: #2980b9;
            transform: scale(1.1);
        }
        #chat-button.show {
            display: block;
        }
        #chat-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #e74c3c;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
        }
        
        #start-screen, #game-over { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        button.main-btn { padding: 10px 30px; font-size: 1.2rem; background: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 20px; }
        
        /* Online Multiplayer UI */
        .room-container { display: flex; flex-direction: column; gap: 15px; align-items: center; margin-top: 20px; }
        .room-input { padding: 10px 15px; font-size: 1rem; border-radius: 5px; border: 2px solid #555; background: #333; color: white; width: 250px; text-align: center; }
        .room-code { font-size: 2rem; font-weight: bold; color: var(--text-gold); letter-spacing: 5px; margin: 10px 0; }
        .player-info { 
            margin-top: 15px; 
            padding: 15px; 
            background: rgba(255,255,255,0.1); 
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 300px;
        }
        .player-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            border-radius: 6px;
            background: rgba(0,0,0,0.3);
        }
        .player-item.player1 {
            border-left: 4px solid #3498db;
        }
        .player-item.player2 {
            border-left: 4px solid #e74c3c;
        }
        .player-badge {
            font-weight: bold;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
        }
        .player-badge.player1 {
            background: #3498db;
            color: white;
        }
        .player-badge.player2 {
            background: #e74c3c;
            color: white;
        }
        .player-side {
            font-size: 0.9rem;
            color: #aaa;
        }
        .waiting-msg { color: #f1c40f; margin-top: 10px; }
        
        /* Coin Flip Animation */
        .coin-container {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        .coin {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(135deg, #f1c40f 0%, #f39c12 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            box-shadow: 0 10px 30px rgba(241, 196, 15, 0.5);
            cursor: pointer;
            transition: transform 0.3s;
            position: relative;
            overflow: hidden;
        }
        .coin.flipping {
            animation: coinFlip 2s ease-in-out;
        }
        @keyframes coinFlip {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(1800deg) scale(1.2); }
            100% { transform: rotateY(3600deg); }
        }
        .coin-side {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            backface-visibility: hidden;
        }
        .coin-heads { 
            background: linear-gradient(135deg, #f1c40f 0%, #f39c12 100%); 
        }
        .coin-tails { 
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%); 
            transform: rotateY(180deg);
            border: 3px solid #1a1a1a;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }
        /* M·∫∑t sau ƒë·ªìng xu - c√≥ pattern ƒë·∫∑c bi·ªát */
        .coin-tails::before {
            content: '‚óè';
            font-size: 2rem;
            color: rgba(255,255,255,0.2);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .coin-tails::after {
            content: '';
            position: absolute;
            width: 80%;
            height: 80%;
            top: 10%;
            left: 10%;
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.3);
        }
        
        /* Dice Animation */
        .dice-container {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        .dice {
            width: 80px;
            height: 80px;
            background: white;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: transform 0.3s;
        }
        .dice.rolling {
            animation: diceRoll 1.5s ease-in-out;
        }
        @keyframes diceRoll {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(90deg) scale(1.1); }
            50% { transform: rotate(180deg) scale(0.9); }
            75% { transform: rotate(270deg) scale(1.1); }
        }
        .result-display {
            margin-top: 15px;
            padding: 15px;
            background: rgba(241, 196, 15, 0.2);
            border-radius: 8px;
            border: 2px solid #f1c40f;
            font-size: 1.1rem;
            font-weight: bold;
            color: #f1c40f;
            text-align: center;
        }
        
        /* Network Mode Selection */
        .mode-selector { display: flex; gap: 15px; margin-bottom: 20px; }
        .mode-btn { 
            padding: 12px 25px; 
            font-size: 1rem; 
            background: #444; 
            color: white; 
            border: 2px solid #666; 
            border-radius: 8px; 
            cursor: pointer; 
            transition: all 0.3s;
            flex: 1;
        }
        .mode-btn:hover { background: #555; border-color: #888; }
        .mode-btn.active { 
            background: #e74c3c; 
            border-color: #c0392b; 
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.5);
        }
        .server-url-container { 
            margin-top: 15px; 
            display: none; 
            flex-direction: column; 
            gap: 10px; 
            align-items: center;
        }
        .server-url-container.show { display: flex; }
        .server-url-input { 
            padding: 10px 15px; 
            font-size: 0.9rem; 
            border-radius: 5px; 
            border: 2px solid #555; 
            background: #333; 
            color: white; 
            width: 100%; 
            max-width: 400px;
        }
        .server-url-input::placeholder { color: #888; }
        .local-info { 
            margin-top: 10px; 
            padding: 10px; 
            background: rgba(52, 152, 219, 0.2); 
            border-radius: 5px; 
            font-size: 0.85rem; 
            color: #3498db;
            text-align: center;
        }
        .local-info strong { color: #2980b9; }

    </style>
</head>
<body>

    <div id="start-screen">
        <button onclick="resetToMenu()" style="position: absolute; top: 20px; left: 20px; padding: 10px 20px; background: #555; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 0.9rem;">
            üè† V·ªÅ Menu
        </button>
        <h1 style="color: var(--text-gold);">ƒê√îNG T√ÇY ƒê·∫†I CHI·∫æN</h1>
        <p style="color: #ccc;">Ch·ªçn ch·∫ø ƒë·ªô ch∆°i</p>
        
        <!-- Game Mode Selection -->
        <div class="mode-selector" style="margin-bottom: 20px;">
            <button class="mode-btn" id="btn-online" onclick="selectGameMode('online')">
                üåê Ch∆°i Online
            </button>
            <button class="mode-btn active" id="btn-bot" onclick="selectGameMode('bot')">
                ü§ñ Ch∆°i v·ªõi BOT
            </button>
        </div>
        
        <!-- Dice Section (for Bot Mode) -->
        <div id="dice-section" class="dice-container" style="display: none;">
            <h3 style="color: #f1c40f; margin-bottom: 15px;">üé≤ TUNG X√öC X·∫ÆC - QUY·∫æT ƒê·ªäNH AI ƒêI TR∆Ø·ªöC</h3>
            <div class="dice" id="dice">üé≤</div>
            <div id="dice-result" class="result-display" style="display: block;"></div>
        </div>
        
        <!-- Network Mode Selection (only for online) -->
        <div class="mode-selector" id="network-mode-selector" style="display: none;">
            <button class="mode-btn active" id="btn-local" onclick="selectMode('local')">
                üåê M·∫°ng LAN (Local)
            </button>
            <button class="mode-btn" id="btn-global" onclick="selectMode('global')">
                üåç Global (Online)
            </button>
        </div>
        
        <!-- Server URL Input (for Global mode) -->
        <div class="server-url-container" id="server-url-container">
            <input type="text" 
                   id="server-url-input" 
                   class="server-url-input" 
                   placeholder="Nh·∫≠p server URL (v√≠ d·ª•: https://your-server.com)"
                   value="">
            <div style="font-size: 0.85rem; color: #888; text-align: center;">
                ƒê·ªÉ tr·ªëng ƒë·ªÉ d√πng server m·∫∑c ƒë·ªãnh
            </div>
        </div>
        
        <!-- Local Network Info -->
        <div class="local-info" id="local-info" style="display: none;">
            <strong>üåê M·∫°ng LAN:</strong> Ch∆°i v·ªõi ng∆∞·ªùi c√πng WiFi<br>
            <strong>Server URL:</strong> <span id="local-server-url" style="color: #f1c40f; font-weight: bold;">ƒêang t·∫£i...</span><br>
            <div style="margin-top: 8px; font-size: 0.85rem; color: #aaa;">
                Ng∆∞·ªùi ch∆°i kh√°c v√†o URL n√†y tr√™n ƒëi·ªán tho·∫°i/m√°y t√≠nh c√πng WiFi
            </div>
        </div>
        
        <!-- Online Mode Menu -->
        <div class="room-container" id="room-menu" style="display: none;">
            <button class="main-btn" onclick="createRoom()">T·∫°o Ph√≤ng M·ªõi</button>
            <div style="margin: 20px 0; color: #888;">HO·∫∂C</div>
            <input type="text" id="room-code-input" class="room-input" placeholder="Nh·∫≠p m√£ ph√≤ng" maxlength="6">
            <button class="main-btn" onclick="joinRoom()">Tham Gia Ph√≤ng</button>
        </div>
        
        <!-- Bot Mode Menu -->
        <div class="room-container" id="bot-menu">
            <div style="margin-bottom: 20px;">
                <h3 style="color: #f1c40f; margin-bottom: 15px;">Ch·ªçn b√™n c·ªßa b·∫°n:</h3>
                <div class="mode-selector">
                    <button class="mode-btn active" id="btn-choose-chess" onclick="selectBotSide('chess')">
                        üè∞ C·ªù Vua (Tr·∫Øng)
                    </button>
                    <button class="mode-btn" id="btn-choose-xiangqi" onclick="selectBotSide('xiangqi')">
                        ‚õ©Ô∏è C·ªù T∆∞·ªõng (ƒê·ªè)
                    </button>
                </div>
            </div>
            <button class="main-btn" onclick="startBotGame()" style="font-size: 1.3rem; padding: 15px 40px;">
                ü§ñ B·∫Øt ƒê·∫ßu Ch∆°i V·ªõi BOT
            </button>
        </div>
        
        <div id="room-info" style="display: none;">
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 10px;">
                <div class="room-code" id="room-code-display">ABC123</div>
                <button id="copy-room-code" onclick="copyRoomCode()" style="padding: 10px 20px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 0.9rem;" title="Copy m√£ ph√≤ng">
                    üìã Copy
                </button>
            </div>
            <div id="copy-success-msg" style="display: none; color: #2ecc71; text-align: center; margin-bottom: 10px; font-size: 0.9rem;">
                ‚úì ƒê√£ copy m√£ ph√≤ng!
            </div>
            
            <!-- Player Info -->
            <div class="player-info">
                <div class="player-item player1">
                    <div>
                        <span class="player-badge player1">PLAYER 1</span>
                        <span id="player1-name" style="margin-left: 10px;">B·∫°n</span>
                    </div>
                    <div class="player-side" id="player1-side">-</div>
                </div>
                <div class="player-item player2">
                    <div>
                        <span class="player-badge player2">PLAYER 2</span>
                        <span id="player2-name" style="margin-left: 10px;">ƒêang ch·ªù...</span>
                    </div>
                    <div class="player-side" id="player2-side">-</div>
                </div>
            </div>
            
            <!-- Waiting Message -->
            <div id="waiting-msg" class="waiting-msg">ƒêang ch·ªù ng∆∞·ªùi ch∆°i th·ª© 2...</div>
            
            <!-- Coin Flip Section (Choose Side) -->
            <div id="coin-flip-section" class="coin-container" style="display: none;">
                <div style="font-size: 1.2rem; color: #f1c40f; font-weight: bold; margin-bottom: 10px;">
                    ü™ô TUNG ƒê·ªíNG XU - CH·ªåN B√äN
                </div>
                <div style="font-size: 0.9rem; color: #aaa; margin-bottom: 15px; text-align: center;">
                    <span id="coin-flip-instruction">Player 1 click v√†o ƒë·ªìng xu ƒë·ªÉ tung</span>
                </div>
                <div class="coin" id="coin">
                    <div class="coin-side coin-heads">‚ôö</div>
                    <div class="coin-side coin-tails"></div>
                </div>
                <div id="coin-result" class="result-display" style="display: none;"></div>
                <!-- Player 1 choice buttons (only shown to Player 1 after coin flip) -->
                <div id="player1-choice" style="display: none; margin-top: 20px;">
                    <div id="player1-choice-text" style="font-size: 1rem; color: #f1c40f; margin-bottom: 10px; text-align: center;">
                        Ch·ªçn b√™n b·∫°n mu·ªën ch∆°i:
                    </div>
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button class="main-btn" onclick="chooseSide('chess')" style="background: #3498db;">
                            üè∞ Ch∆°i C·ªù Vua (Tr·∫Øng)
                        </button>
                        <button class="main-btn" onclick="chooseSide('xiangqi')" style="background: #e74c3c;">
                            ‚õ©Ô∏è Ch∆°i C·ªù T∆∞·ªõng (ƒê·ªè)
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Dice Section (Choose First Turn) -->
            <div id="dice-section" class="dice-container" style="display: none;">
                <div style="font-size: 1.2rem; color: #f1c40f; font-weight: bold; margin-bottom: 10px;">
                    üé≤ TUNG X√öC X·∫ÆC - CH·ªåN NG∆Ø·ªúI ƒêI TR∆Ø·ªöC
                </div>
                <div style="font-size: 0.9rem; color: #aaa; margin-bottom: 15px; text-align: center;">
                    C·∫£ 2 ng∆∞·ªùi ch∆°i ƒë·ªÅu tung x√∫c x·∫Øc. Ai c√≥ t·ªïng cao h∆°n s·∫Ω ƒëi tr∆∞·ªõc!
                </div>
                <div class="dice" id="dice" onclick="rollDice()">üé≤</div>
                <div id="dice-result-text" class="result-display" style="display: none;"></div>
            </div>
        </div>
    </div>

    <div id="game-over" style="display: none;">
        <h1 id="winner-text" style="color: var(--text-gold);">WINNER</h1>
        <div style="display: flex; gap: 15px; flex-wrap: wrap; justify-content: center;">
            <button class="main-btn" onclick="resetToMenu()" style="background: #3498db;">
                üè† V·ªÅ Menu Ch√≠nh
            </button>
            <button class="main-btn" onclick="playAgain()">
                üîÑ Ch∆°i L·∫°i
            </button>
        </div>
    </div>

    <div id="status-bar">
        <div id="turn-badge" class="badge">...</div>
        <div id="message" style="color: red; font-weight: bold;"></div>
    </div>
    
    <!-- Chat Button -->
    <button id="chat-button" onclick="toggleChat()" title="M·ªü Chat">üí¨</button>
    
    <!-- Chat Container -->
    <div id="chat-container">
        <div id="chat-header" onclick="toggleChat()">
            <h3>üí¨ Chat</h3>
            <button id="chat-toggle">‚àí</button>
        </div>
        <div id="chat-messages"></div>
        <div id="chat-input-container">
            <input type="text" id="chat-input" placeholder="Nh·∫≠p tin nh·∫Øn..." maxlength="200" onkeypress="handleChatKeyPress(event)">
            <button id="chat-emoji-btn" onclick="toggleEmojiPicker()" title="Ch·ªçn emoji">üòÄ</button>
            <button id="chat-send" onclick="sendChatMessage()">G·ª≠i</button>
            
            <!-- Emoji Picker -->
            <div id="emoji-picker">
                <div id="emoji-picker-header">
                    <h4>üòÄ Ch·ªçn Emoji</h4>
                    <button id="emoji-picker-close" onclick="toggleEmojiPicker()">√ó</button>
                </div>
                <div id="emoji-picker-body"></div>
            </div>
        </div>
    </div>

    <div class="game-wrapper">
        
        <div id="graveyard-bar">
            <div class="grave-row" id="grave-top">
                <div class="grave-label">Qu√¢n Tr·∫Øng<br>B·ªã B·∫Øt</div>
                </div>
            <div class="grave-row" id="grave-bot">
                <div class="grave-label">Qu√¢n ƒê·ªè<br>B·ªã B·∫Øt</div>
                </div>
        </div>

        <div id="board-container">
            <div id="board"></div>
            
            <div id="promotion-modal">
                <h3>PHONG C·∫§P!</h3>
                <div class="promo-options">
                    <button class="promo-btn" onclick="promotePawn('queen')" title="H·∫≠u">‚ôõ</button>
                    <button class="promo-btn" onclick="promotePawn('rook')" title="Xe">‚ôú</button>
                    <button class="promo-btn" onclick="promotePawn('bishop')" title="T∆∞·ª£ng">‚ôù</button>
                    <button class="promo-btn" onclick="promotePawn('knight')" title="M√£">‚ôû</button>
                </div>
            </div>
        </div>
    </div>

    <div id="control-bar">
        <button class="ctrl-btn" id="btn-prev" onclick="reviewMove(-1)" title="L√πi l·∫°i"><i class="fa-solid fa-backward"></i></button>
        <button class="ctrl-btn" id="btn-next" onclick="reviewMove(1)" title="Ti·∫øn t·ªõi"><i class="fa-solid fa-forward"></i></button>
        <button class="ctrl-btn active-live" id="btn-live" onclick="returnToLive()" title="V·ªÅ tr·∫≠n ƒë·∫•u hi·ªán t·∫°i">LIVE</button>
    </div>

    <div id="rules-container">
        <h2 class="rules-title">üìú LU·∫¨T CH∆†I CHI TI·∫æT</h2>
        <div class="rules-grid">
            <div class="rule-box">
                <h3>üè∞ Phe C·ªù Vua (Tr·∫Øng)</h3>
                <ul>
                    <li><strong>Lu·∫≠t di chuy·ªÉn:</strong> Tu√¢n theo lu·∫≠t C·ªù Vua qu·ªëc t·∫ø.</li>
                    <li><strong>Phong c·∫•p T·ªët:</strong> T·ªët khi ƒëi ƒë·∫øn h√†ng cu·ªëi c√πng (h√†ng ƒë√°y b√™n phe ƒë·ªè) ƒë∆∞·ª£c ph√©p phong c·∫•p th√†nh: H·∫≠u, Xe, T∆∞·ª£ng ho·∫∑c M√£.</li>
                    <li><strong>ƒê·∫∑c quy·ªÅn:</strong> Qu√¢n C·ªù Vua kh√¥ng b·ªã gi·ªõi h·∫°n b·ªüi S√¥ng hay Cung T∆∞·ªõng.</li>
                    <li><strong>Nh·∫≠p th√†nh:</strong> ƒê∆∞·ª£c ph√©p n·∫øu Vua v√† Xe ch∆∞a di chuy·ªÉn v√† ƒë∆∞·ªùng ƒëi tho√°ng.</li>
                </ul>
            </div>
            <div class="rule-box">
                <h3>‚õ©Ô∏è Phe C·ªù T∆∞·ªõng (ƒê·ªè)</h3>
                <ul>
                    <li><strong>Lu·∫≠t di chuy·ªÉn:</strong> Tu√¢n theo lu·∫≠t C·ªù T∆∞·ªõng c∆° b·∫£n.</li>
                    <li><strong>T·ªët:</strong> Qua s√¥ng ƒë∆∞·ª£c ph√©p ƒëi ngang v√† th·∫≥ng (m·ªói l·∫ßn 1 √¥).</li>
                    <li><strong>H·∫°n ch·∫ø:</strong> T∆∞·ªõng v√† Sƒ© kh√¥ng ƒë∆∞·ª£c ra kh·ªèi Cung (√¥ vu√¥ng 3x3). T∆∞·ª£ng kh√¥ng ƒë∆∞·ª£c ƒëi qua s√¥ng.</li>
                    <li><strong>C·∫£n ch√¢n:</strong> M√£ v√† T∆∞·ª£ng tu√¢n th·ªß lu·∫≠t c·∫£n ch√¢n nh∆∞ b√¨nh th∆∞·ªùng.</li>
                </ul>
            </div>
            <div class="rule-box full-width">
                <h3>‚öîÔ∏è Quy T·∫Øc Chung & Th·∫Øng Thua</h3>
                <ul>
                    <li><strong>M·ª•c ti√™u:</strong> Chi·∫øu b√≠ T∆∞·ªõng (C·ªù T∆∞·ªõng) ho·∫∑c Vua (C·ªù Vua).</li>
                    <li><strong>Kh·ªüi ƒë·∫ßu:</strong> Tung ƒë·ªìng xu ƒë·ªÉ ch·ªçn ng∆∞·ªùi ƒë∆∞·ª£c ch·ªçn b√™n, sau ƒë√≥ tung x√∫c x·∫Øc ƒë·ªÉ ch·ªçn phe ƒëi tr∆∞·ªõc.</li>
                    <li><strong>ƒÇn qu√¢n:</strong> Qu√¢n phe n√†y ƒëi v√†o √¥ qu√¢n phe kia ƒëang ƒë·ª©ng s·∫Ω ƒÉn qu√¢n ƒë√≥.</li>
                    <li><strong>üõ°Ô∏è Khi√™n c·ªßa T·ªët C·ªù Vua:</strong> T·ªët c·ªù vua khi ch∆∞a di chuy·ªÉn c√≥ khi√™n (üõ°Ô∏è). Ph√°o c·ªù t∆∞·ªõng kh√¥ng th·ªÉ b·∫Øc c·∫ßu qua t·ªët c√≥ khi√™n. Khi t·ªët di chuy·ªÉn, khi√™n s·∫Ω m·∫•t v√† ph√°o c√≥ th·ªÉ b·∫Øc c·∫ßu ƒë∆∞·ª£c.</li>
                    <li><strong>M√£ C·ªù T∆∞·ªõng:</strong> M√£ c·ªù t∆∞·ªõng kh√¥ng b·ªã ch·∫∑n b·ªüi t·ªët c·ªù vua khi ƒëi ch·ªØ L.</li>
                    <li><strong>En Passant:</strong> T·ªët c·ªù vua c√≥ th·ªÉ ƒÉn t·ªët ƒë·ªëi ph∆∞∆°ng ƒëi 2 √¥ ngang qua m·∫∑t m√¨nh.</li>
                </ul>
            </div>
        </div>
    </div>

<script>
    // ========== NETWORK MODE CONFIGURATION ==========
    let networkMode = 'local'; // 'local' or 'global'
    let socket = null;
    let currentServerURL = window.location.origin;
    
    // ========== MULTIPLAYER STATE ==========
    let gameRoomId = null;
    let playerId = null;
    let playerSide = null; // "chess" ho·∫∑c "xiangqi"
    let isHost = false;
    let isOnlineGame = false;
    
    // ========== GAME MODE SELECTION ==========
    function selectGameMode(mode) {
        // Reset UI
        document.querySelectorAll('.mode-btn').forEach(btn => {
            // Ch·ªâ reset c√°c n√∫t ch·∫ø ƒë·ªô ch∆°i, kh√¥ng reset n√∫t ch·ªçn b√™n
            if (btn.id === 'btn-online' || btn.id === 'btn-bot') {
                btn.classList.remove('active');
            }
        });
        
        if (mode === 'online') {
            document.getElementById('btn-online').classList.add('active');
            document.getElementById('network-mode-selector').style.display = 'flex';
            document.getElementById('room-menu').style.display = 'flex';
            document.getElementById('bot-menu').style.display = 'none';
            document.getElementById('server-url-container').style.display = 'block';
            isBotMode = false;
        } else if (mode === 'bot') {
            document.getElementById('btn-bot').classList.add('active');
            document.getElementById('network-mode-selector').style.display = 'none';
            document.getElementById('room-menu').style.display = 'none';
            document.getElementById('bot-menu').style.display = 'flex';
            document.getElementById('server-url-container').style.display = 'none';
            document.getElementById('local-info').style.display = 'none';
            isBotMode = true;
        }
    }
    
    // ========== BOT SIDE SELECTION ==========
    function selectBotSide(side) {
        document.getElementById('btn-choose-chess').classList.toggle('active', side === 'chess');
        document.getElementById('btn-choose-xiangqi').classList.toggle('active', side === 'xiangqi');
        playerSide = side;
        botSide = side === 'chess' ? 'xiangqi' : 'chess';
    }
    
    // ========== MODE SELECTION ==========
    function selectMode(mode) {
        networkMode = mode;
        
        // Update UI
        document.getElementById('btn-local').classList.toggle('active', mode === 'local');
        document.getElementById('btn-global').classList.toggle('active', mode === 'global');
        document.getElementById('server-url-container').classList.toggle('show', mode === 'global');
        document.getElementById('local-info').style.display = mode === 'local' ? 'block' : 'none';
        
        // Update server URL
        if (mode === 'local') {
            currentServerURL = window.location.origin;
            // Show local info immediately
            const localInfo = document.getElementById('local-info');
            if (localInfo) {
                localInfo.style.display = 'block';
            }
            // Update IP info
            updateLocalServerInfo();
        } else {
            const urlInput = document.getElementById('server-url-input').value.trim();
            currentServerURL = urlInput || window.location.origin;
            // Hide local info
            const localInfo = document.getElementById('local-info');
            if (localInfo) {
                localInfo.style.display = 'none';
            }
        }
        
        // Reconnect socket if already connected
        if (socket && socket.connected) {
            socket.disconnect();
            connectToServer();
        }
    }
    
    function updateLocalServerInfo() {
        const urlElement = document.getElementById('local-server-url');
        if (!urlElement) return;
        
        // Try to get local IP from server
        fetch(`${currentServerURL}/api/ip`)
            .then(res => res.json())
            .then(data => {
                if (data.ip && data.ip !== 'localhost' && data.ip !== '127.0.0.1') {
                    urlElement.textContent = `http://${data.ip}:3000`;
                    urlElement.style.color = '#f1c40f';
                } else {
                    // Fallback: try to get IP from WebRTC
                    getLocalIP().then(ip => {
                        if (ip) {
                            urlElement.textContent = `http://${ip}:3000`;
                            urlElement.style.color = '#f1c40f';
                        } else {
                            urlElement.textContent = 'http://localhost:3000';
                            urlElement.style.color = '#e74c3c';
                            urlElement.title = 'Kh√¥ng th·ªÉ l·∫•y IP t·ª± ƒë·ªông. H√£y ki·ªÉm tra IP b·∫±ng l·ªánh ipconfig';
                        }
                    });
                }
            })
            .catch(() => {
                // Fallback: try WebRTC method
                getLocalIP().then(ip => {
                    if (ip) {
                        urlElement.textContent = `http://${ip}:3000`;
                        urlElement.style.color = '#f1c40f';
                    } else {
                        urlElement.textContent = 'http://localhost:3000';
                        urlElement.style.color = '#e74c3c';
                        urlElement.title = 'Kh√¥ng th·ªÉ l·∫•y IP t·ª± ƒë·ªông. Ch·∫°y ipconfig ƒë·ªÉ l·∫•y IP';
                    }
                });
            });
    }
    
    // Get local IP using WebRTC (fallback method)
    function getLocalIP() {
        return new Promise((resolve) => {
            const RTCPeerConnection = window.RTCPeerConnection || 
                                     window.mozRTCPeerConnection || 
                                     window.webkitRTCPeerConnection;
            
            if (!RTCPeerConnection) {
                resolve(null);
                return;
            }
            
            const pc = new RTCPeerConnection({
                iceServers: []
            });
            
            pc.createDataChannel('');
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    const candidate = event.candidate.candidate;
                    const match = candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
                    if (match) {
                        const ip = match[1];
                        // Filter out localhost and invalid IPs
                        if (ip && !ip.startsWith('127.') && !ip.startsWith('169.254.')) {
                            pc.close();
                            resolve(ip);
                            return;
                        }
                    }
                }
            };
            
            pc.createOffer()
                .then(offer => pc.setLocalDescription(offer))
                .catch(() => resolve(null));
            
            // Timeout after 2 seconds
            setTimeout(() => {
                pc.close();
                resolve(null);
            }, 2000);
        });
    }
    
    function connectToServer() {
        if (socket) {
            socket.disconnect();
        }
        
        socket = io(currentServerURL, {
            reconnection: true,
            reconnectionDelay: 2000, // TƒÉng delay cho m·∫°ng y·∫øu
            reconnectionAttempts: 10, // TƒÉng s·ªë l·∫ßn th·ª≠ l·∫°i
            reconnectionDelayMax: 10000, // Delay t·ªëi ƒëa 10 gi√¢y
            timeout: 20000, // Timeout 20 gi√¢y cho m·∫°ng y·∫øu
            transports: ['websocket', 'polling'], // Th·ª≠ websocket tr∆∞·ªõc, fallback polling
            upgrade: true,
            rememberUpgrade: false
        });
        
        setupSocketEvents();
    }
    
    function setupSocketEvents() {
    
        // Socket.io event handlers
        socket.on('connect', () => {
            console.log('Connected to server:', socket.id, 'at', currentServerURL);
            if (msgEl) {
                msgEl.innerText = 'ƒê√£ k·∫øt n·ªëi ƒë·∫øn server';
                msgEl.style.color = '#2ecc71';
                setTimeout(() => {
                    if (msgEl) {
                        msgEl.innerText = '';
                        msgEl.style.color = '';
                    }
                }, 2000);
            }
        });
        
        socket.on('disconnect', (reason) => {
            console.log('Disconnected from server:', reason);
            if (isOnlineGame && msgEl) {
                msgEl.innerText = 'M·∫•t k·∫øt n·ªëi v·ªõi server! ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i...';
                msgEl.style.color = '#e74c3c';
            }
        });
        
        socket.on('reconnect', (attemptNumber) => {
            console.log('Reconnected after', attemptNumber, 'attempts');
            if (msgEl) {
                msgEl.innerText = 'ƒê√£ k·∫øt n·ªëi l·∫°i th√†nh c√¥ng!';
                msgEl.style.color = '#2ecc71';
                setTimeout(() => {
                    if (msgEl) {
                        msgEl.innerText = '';
                        msgEl.style.color = '';
                    }
                }, 2000);
            }
        });
        
        socket.on('reconnect_attempt', (attemptNumber) => {
            console.log('Reconnection attempt', attemptNumber);
            if (msgEl) {
                msgEl.innerText = `ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i... (L·∫ßn ${attemptNumber})`;
                msgEl.style.color = '#f39c12';
            }
        });
        
        socket.on('reconnect_failed', () => {
            console.error('Reconnection failed');
            if (msgEl) {
                msgEl.innerText = 'Kh√¥ng th·ªÉ k·∫øt n·ªëi l·∫°i! Vui l√≤ng refresh trang.';
                msgEl.style.color = '#e74c3c';
            }
        });
        
        socket.on('connect_error', (error) => {
            console.error('Connection error:', error);
            if (msgEl) {
                msgEl.innerText = `Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server: ${currentServerURL}. ƒêang th·ª≠ l·∫°i...`;
                msgEl.style.color = '#e74c3c';
            }
        });
        
        socket.on('error', (data) => {
            console.error('Socket error:', data);
            const errorMsg = data.message || 'C√≥ l·ªói x·∫£y ra!';
            
            // Hi·ªÉn th·ªã l·ªói trong UI thay v√¨ alert ƒë·ªÉ kh√¥ng l√†m gi√°n ƒëo·∫°n
            if (msgEl) {
                msgEl.innerText = errorMsg;
                msgEl.style.color = '#e74c3c';
                setTimeout(() => {
                    if (msgEl) {
                        msgEl.innerText = '';
                        msgEl.style.color = '';
                    }
                }, 5000);
            } else {
                alert(errorMsg);
            }
        });
    
        socket.on('roomCreated', ({ roomCode, playerId: pid }) => {
            gameRoomId = roomCode;
            playerId = pid;
            isHost = true;
            isOnlineGame = true; // Set online game mode khi v√†o ph√≤ng
            coinFlipped = false;
            diceRolled = false;
            
            console.log('Room created - isOnlineGame set to true', { roomCode, playerId: pid, isHost });
            
            document.getElementById('room-menu').style.display = 'none';
            document.getElementById('room-info').style.display = 'block';
            document.getElementById('room-code-display').textContent = roomCode;
            document.getElementById('player1-name').textContent = 'B·∫°n';
            document.getElementById('player1-side').textContent = '-';
            document.getElementById('player2-name').textContent = 'ƒêang ch·ªù...';
            document.getElementById('player2-side').textContent = '-';
        });
        
        socket.on('roomJoined', ({ roomCode, playerId: pid }) => {
            // Clear timeout n·∫øu c√≥
            if (joinRoomTimeout) {
                clearTimeout(joinRoomTimeout);
                joinRoomTimeout = null;
            }
            
            // Reset button
            if (joinRoomButton) {
                joinRoomButton.disabled = false;
                joinRoomButton.textContent = 'Tham Gia Ph√≤ng';
            }
            
            gameRoomId = roomCode;
            playerId = pid;
            isHost = false;
            isOnlineGame = true; // Set online game mode khi v√†o ph√≤ng
            coinFlipped = false;
            diceRolled = false;
            
            console.log('Room joined successfully:', { roomCode, playerId: pid, isHost });
            
            if (msgEl) {
                msgEl.innerText = 'ƒê√£ tham gia ph√≤ng th√†nh c√¥ng!';
                msgEl.style.color = '#2ecc71';
                setTimeout(() => {
                    if (msgEl) msgEl.innerText = '';
                }, 2000);
            }
            
            document.getElementById('room-menu').style.display = 'none';
            document.getElementById('room-info').style.display = 'block';
            document.getElementById('room-code-display').textContent = roomCode;
            document.getElementById('player2-name').textContent = 'B·∫°n';
            document.getElementById('player2-side').textContent = '-';
        });
        
        socket.on('playerJoined', ({ players: playersList }) => {
            playersList.forEach((p, idx) => {
                if (idx === 0) {
                    document.getElementById('player1-name').textContent = p.name || 'Ng∆∞·ªùi ch∆°i 1';
                    if (p.id === playerId) {
                        document.getElementById('player1-name').textContent += ' (B·∫°n)';
                    }
                } else if (idx === 1) {
                    document.getElementById('player2-name').textContent = p.name || 'Ng∆∞·ªùi ch∆°i 2';
                    if (p.id === playerId) {
                        document.getElementById('player2-name').textContent += ' (B·∫°n)';
                    }
                }
            });
        });
        
        socket.on('readyToChooseSides', ({ players: playersList }) => {
            console.log('readyToChooseSides received', playersList, { isOnlineGame, gameRoomId, isHost, playerId });
            
            // ƒê·∫£m b·∫£o isOnlineGame ƒë∆∞·ª£c set
            isOnlineGame = true;
            
            document.getElementById('waiting-msg').style.display = 'none';
            document.getElementById('coin-flip-section').style.display = 'block';
            document.getElementById('room-info').style.display = 'block';
            
            // Update player names
            playersList.forEach((p, idx) => {
                if (idx === 0) {
                    document.getElementById('player1-name').textContent = (p.id === playerId ? 'B·∫°n' : p.name) || 'Ng∆∞·ªùi ch∆°i 1';
                } else if (idx === 1) {
                    document.getElementById('player2-name').textContent = (p.id === playerId ? 'B·∫°n' : p.name) || 'Ng∆∞·ªùi ch∆°i 2';
                }
            });
            
            // Update coin flip instruction
            const coinInstruction = document.getElementById('coin-flip-instruction');
            const coinElement = document.getElementById('coin');
            
            if (isHost) {
                coinInstruction.textContent = 'B·∫°n (Player 1) click v√†o ƒë·ªìng xu ƒë·ªÉ tung';
                coinElement.style.cursor = 'pointer';
                coinElement.style.pointerEvents = 'auto';
                // ƒê·∫£m b·∫£o event listener ƒë∆∞·ª£c g·∫Øn
                coinElement.onclick = flipCoin;
                console.log('Player 1 - Coin flip enabled', { isOnlineGame, gameRoomId, isHost, playerId });
            } else {
                coinInstruction.textContent = 'ƒêang ch·ªù Player 1 tung ƒë·ªìng xu...';
                coinElement.style.cursor = 'not-allowed';
                coinElement.style.pointerEvents = 'none';
                coinElement.onclick = null;
                console.log('Player 2 - Coin flip disabled', { isOnlineGame, gameRoomId, isHost, playerId });
            }
        });
        
        socket.on('sidesAssigned', ({ players: playersList }) => {
            document.getElementById('coin-flip-section').style.display = 'none';
            document.getElementById('player1-choice').style.display = 'none';
            document.getElementById('dice-section').style.display = 'block';
            
            // Reset dice state ƒë·ªÉ c·∫£ 2 player ƒë·ªÅu c√≥ th·ªÉ tung
            diceRolled = false;
            
            // Update player sides
            playersList.forEach((p, idx) => {
                const sideText = p.side === 'chess' ? 'üè∞ C·ªù Vua (Tr·∫Øng)' : '‚õ©Ô∏è C·ªù T∆∞·ªõng (ƒê·ªè)';
                if (p.id === playerId) {
                    playerSide = p.side;
                }
                
                if (idx === 0) {
                    document.getElementById('player1-side').textContent = sideText;
                } else if (idx === 1) {
                    document.getElementById('player2-side').textContent = sideText;
                }
            });
            
            // ƒê·∫£m b·∫£o dice c√≥ th·ªÉ click ƒë∆∞·ª£c
            const dice = document.getElementById('dice');
            if (dice) {
                dice.style.pointerEvents = 'auto';
                dice.style.cursor = 'pointer';
                dice.onclick = rollDice;
            }
        });
        
        socket.on('gameStarted', ({ players: playersList, currentTurn, diceResults, firstTurnPlayer }) => {
            console.log('gameStarted event received:', { playersList, currentTurn, diceResults, firstTurnPlayer });
            
            // Hide dice section
            const diceSection = document.getElementById('dice-section');
            if (diceSection) {
                diceSection.style.display = 'none';
            }
            
            // Hide room info
            const roomInfo = document.getElementById('room-info');
            if (roomInfo) {
                roomInfo.style.display = 'none';
            }
            
            const myPlayer = playersList.find(p => p.id === playerId);
            if (myPlayer) {
                playerSide = myPlayer.side;
            }
            
            // Update final player info
            playersList.forEach((p, idx) => {
                const sideText = p.side === 'chess' ? 'üè∞ C·ªù Vua (Tr·∫Øng)' : '‚õ©Ô∏è C·ªù T∆∞·ªõng (ƒê·ªè)';
                const isMe = p.id === playerId;
                if (idx === 0) {
                    const player1Name = document.getElementById('player1-name');
                    const player1Side = document.getElementById('player1-side');
                    if (player1Name) player1Name.textContent = (isMe ? 'B·∫°n' : p.name) || 'Ng∆∞·ªùi ch∆°i 1';
                    if (player1Side) player1Side.textContent = sideText;
                } else if (idx === 1) {
                    const player2Name = document.getElementById('player2-name');
                    const player2Side = document.getElementById('player2-side');
                    if (player2Name) player2Name.textContent = (isMe ? 'B·∫°n' : p.name) || 'Ng∆∞·ªùi ch∆°i 2';
                    if (player2Side) player2Side.textContent = sideText;
                }
            });
            
            // Show who goes first
            if (firstTurnPlayer && diceResults) {
                const resultEl = document.getElementById('dice-result-text');
                if (resultEl) {
                    const firstTurnSide = currentTurn === 'chess' ? 'üè∞ C·ªù Vua' : '‚õ©Ô∏è C·ªù T∆∞·ªõng';
                    const player1Result = diceResults.player1?.diceResult || diceResults.player1?.diceResult || 0;
                    const player2Result = diceResults.player2?.diceResult || diceResults.player2?.diceResult || 0;
                    resultEl.innerHTML += `<br><br>üéØ Player 1: ${player1Result} | Player 2: ${player2Result}<br><strong>${firstTurnPlayer}</strong> ƒëi tr∆∞·ªõc (${firstTurnSide})`;
                }
            }
            
            // Hi·ªÉn th·ªã chat khi game b·∫Øt ƒë·∫ßu
            const chatButton = document.getElementById('chat-button');
            const chatContainer = document.getElementById('chat-container');
            if (chatButton) chatButton.classList.add('show');
            if (chatContainer) chatContainer.classList.add('show');
            chatMinimized = false;
            
            console.log('Starting game with:', { currentTurn, playerSide, isOnlineGame, gameRoomId });
            
            // Kh·ªüi t·∫°o game
            startOnlineGame(currentTurn);
        });
        
        socket.on('gameStateUpdated', ({ gameState }) => {
            // C·∫≠p nh·∫≠t game state t·ª´ server
            pieces = gameState.pieces || [];
            deadChess = gameState.deadChess || [];
            deadXQ = gameState.deadXQ || [];
            currentTurn = gameState.currentTurn || 'chess';
            isGameOver = gameState.isGameOver || false;
            lastMove = gameState.lastMove || null;
            
            drawBoard();
        });
        
        socket.on('gameOver', ({ winner }) => {
            isGameOver = true;
            const winnerText = document.getElementById('winner-text');
            if (winnerText) {
                winnerText.innerText = (winner === playerSide ? 'B·∫†N' : 'ƒê·ªêI TH·ª¶') + ' TH·∫ÆNG!';
            }
            const gameOverEl = document.getElementById('game-over');
            if (gameOverEl) {
                gameOverEl.style.display = 'flex';
            }
        });
        
        socket.on('playerLeft', ({ playerId: pid }) => {
            if (isOnlineGame && msgEl) {
                msgEl.innerText = 'ƒê·ªëi th·ªß ƒë√£ r·ªùi ph√≤ng!';
                setTimeout(() => {
                    location.reload();
                }, 3000);
            }
        });
        
        // Chat message received
        socket.on('chatMessage', ({ playerId: senderId, playerName, message, timestamp }) => {
            addChatMessage(senderId === playerId, playerName, message, timestamp);
        });
    
    }
    
    // ========== CHAT FUNCTIONS ==========
    let chatUnreadCount = 0;
    let chatMinimized = false;
    
    function toggleChat() {
        const chatContainer = document.getElementById('chat-container');
        const chatButton = document.getElementById('chat-button');
        
        if (chatContainer.classList.contains('show')) {
            chatContainer.classList.remove('show');
            chatButton.classList.add('show');
            chatMinimized = true;
        } else {
            chatContainer.classList.add('show');
            chatButton.classList.remove('show');
            chatMinimized = false;
            chatUnreadCount = 0;
            updateChatBadge();
        }
    }
    
    function addChatMessage(isOwn, senderName, message, timestamp) {
        const chatMessages = document.getElementById('chat-messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-message ${isOwn ? 'own' : 'other'}`;
        
        const senderSpan = document.createElement('div');
        senderSpan.className = 'sender';
        senderSpan.textContent = isOwn ? 'B·∫°n' : senderName;
        
        const messageText = document.createElement('div');
        messageText.textContent = message;
        
        const timeSpan = document.createElement('div');
        timeSpan.className = 'time';
        const time = timestamp ? new Date(timestamp) : new Date();
        timeSpan.textContent = time.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });
        
        messageDiv.appendChild(senderSpan);
        messageDiv.appendChild(messageText);
        messageDiv.appendChild(timeSpan);
        
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        // N·∫øu chat ƒëang minimized, tƒÉng unread count
        if (chatMinimized && !isOwn) {
            chatUnreadCount++;
            updateChatBadge();
        }
    }
    
    function updateChatBadge() {
        const chatButton = document.getElementById('chat-button');
        let badge = document.getElementById('chat-badge');
        
        if (chatUnreadCount > 0) {
            if (!badge) {
                badge = document.createElement('div');
                badge.id = 'chat-badge';
                chatButton.appendChild(badge);
            }
            badge.textContent = chatUnreadCount > 9 ? '9+' : chatUnreadCount;
        } else {
            if (badge) {
                badge.remove();
            }
        }
    }
    
    function sendChatMessage() {
        const chatInput = document.getElementById('chat-input');
        const message = chatInput.value.trim();
        
        if (!message || !isOnlineGame || !gameRoomId) return;
        
        // G·ª≠i tin nh·∫Øn ƒë·∫øn server
        socket.emit('chatMessage', {
            roomCode: gameRoomId,
            message: message
        });
        
        // Clear input
        chatInput.value = '';
    }
    
    function handleChatKeyPress(event) {
        if (event.key === 'Enter') {
            sendChatMessage();
        }
    }
    
    // Emoji Picker Functions
    const emojiList = [
        'üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'üòÇ', 'ü§£',
        'üòä', 'üòá', 'üôÇ', 'üôÉ', 'üòâ', 'üòå', 'üòç', 'ü•∞',
        'üòò', 'üòó', 'üòô', 'üòö', 'üòã', 'üòõ', 'üòù', 'üòú',
        'ü§™', 'ü§®', 'üßê', 'ü§ì', 'üòé', 'ü§©', 'ü•≥', 'üòè',
        'üòí', 'üòû', 'üòî', 'üòü', 'üòï', 'üôÅ', '‚òπÔ∏è', 'üò£',
        'üòñ', 'üò´', 'üò©', 'ü•∫', 'üò¢', 'üò≠', 'üò§', 'üò†',
        'üò°', 'ü§¨', 'ü§Ø', 'üò≥', 'ü•µ', 'ü•∂', 'üò±', 'üò®',
        'üò∞', 'üò•', 'üòì', 'ü§ó', 'ü§î', 'ü§≠', 'ü§´', 'ü§•',
        'üò∂', 'üòê', 'üòë', 'üò¨', 'üôÑ', 'üòØ', 'üò¶', 'üòß',
        'üòÆ', 'üò≤', 'ü•±', 'üò¥', 'ü§§', 'üò™', 'üòµ', 'ü§ê',
        'üëç', 'üëé', 'üëå', '‚úåÔ∏è', 'ü§û', 'ü§ü', 'ü§ò', 'ü§ô',
        'üëè', 'üôå', 'üëê', 'ü§≤', 'ü§ù', 'üôè', '‚úçÔ∏è', 'üí™',
        '‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'üñ§', 'ü§ç',
        'üíî', '‚ù£Ô∏è', 'üíï', 'üíû', 'üíì', 'üíó', 'üíñ', 'üíò',
        'üíù', 'üíü', '‚òÆÔ∏è', '‚úùÔ∏è', '‚ò™Ô∏è', 'üïâ', '‚ò∏Ô∏è', '‚ú°Ô∏è',
        'üîØ', 'üïé', '‚òØÔ∏è', '‚ò¶Ô∏è', 'üõê', '‚õé', '‚ôà', '‚ôâ',
        '‚ôä', '‚ôã', '‚ôå', '‚ôç', '‚ôé', '‚ôè', '‚ôê', '‚ôë',
        '‚ôí', '‚ôì', 'üÜî', '‚öõÔ∏è', 'üâë', '‚ò¢Ô∏è', '‚ò£Ô∏è', 'üì¥',
        'üì≥', 'üà∂', 'üàö', 'üà∏', 'üà∫', 'üà∑Ô∏è', '‚ú¥Ô∏è', 'üÜö',
        'üíÆ', 'üâê', '„äôÔ∏è', '„äóÔ∏è', 'üà¥', 'üàµ', 'üàπ', 'üà≤',
        'üÖ∞Ô∏è', 'üÖ±Ô∏è', 'üÜé', 'üÜë', 'üÖæÔ∏è', 'üÜò', '‚ùå', '‚≠ï',
        'üõë', '‚õî', 'üìõ', 'üö´', 'üíØ', 'üí¢', '‚ô®Ô∏è', 'üö∑',
        'üöØ', 'üö≥', 'üö±', 'üîû', 'üìµ', 'üö≠', '‚ùó', '‚ùì',
        '‚ùï', '‚ùî', '‚ÄºÔ∏è', '‚ÅâÔ∏è', 'üîÖ', 'üîÜ', '„ÄΩÔ∏è', '‚ö†Ô∏è',
        'üö∏', 'üî±', '‚öúÔ∏è', 'üî∞', '‚ôªÔ∏è', '‚úÖ', 'üàØ', 'üíπ',
        '‚ùáÔ∏è', '‚ú≥Ô∏è', '‚ùé', 'üåê', 'üí†', '‚ìÇÔ∏è', 'üåÄ', 'üí§',
        'üèß', 'üöæ', '‚ôø', 'üÖøÔ∏è', 'üà≥', 'üàÇÔ∏è', 'üõÇ', 'üõÉ',
        'üõÑ', 'üõÖ', 'üöπ', 'üö∫', 'üöº', 'üöª', 'üöÆ', 'üé¶',
        'üì∂', 'üàÅ', 'üî£', '‚ÑπÔ∏è', 'üî§', 'üî°', 'üî†', 'üî¢'
    ];
    
    let emojiPickerVisible = false;
    
    function toggleEmojiPicker() {
        const emojiPicker = document.getElementById('emoji-picker');
        emojiPickerVisible = !emojiPickerVisible;
        
        if (emojiPickerVisible) {
            emojiPicker.classList.add('show');
            // Populate emoji picker if empty
            if (emojiPicker.querySelector('#emoji-picker-body').children.length === 0) {
                populateEmojiPicker();
            }
        } else {
            emojiPicker.classList.remove('show');
        }
    }
    
    function populateEmojiPicker() {
        const emojiPickerBody = document.getElementById('emoji-picker-body');
        emojiPickerBody.innerHTML = '';
        
        emojiList.forEach(emoji => {
            const emojiItem = document.createElement('div');
            emojiItem.className = 'emoji-item';
            emojiItem.textContent = emoji;
            emojiItem.onclick = () => insertEmoji(emoji);
            emojiPickerBody.appendChild(emojiItem);
        });
    }
    
    function insertEmoji(emoji) {
        const chatInput = document.getElementById('chat-input');
        const cursorPos = chatInput.selectionStart;
        const textBefore = chatInput.value.substring(0, cursorPos);
        const textAfter = chatInput.value.substring(cursorPos);
        
        chatInput.value = textBefore + emoji + textAfter;
        chatInput.focus();
        
        // Set cursor position after inserted emoji
        const newCursorPos = cursorPos + emoji.length;
        chatInput.setSelectionRange(newCursorPos, newCursorPos);
        
        // Close emoji picker after selection
        toggleEmojiPicker();
    }
    
    // Close emoji picker when clicking outside
    document.addEventListener('click', (e) => {
        const emojiPicker = document.getElementById('emoji-picker');
        const emojiBtn = document.getElementById('chat-emoji-btn');
        
        if (emojiPickerVisible && 
            !emojiPicker.contains(e.target) && 
            !emojiBtn.contains(e.target)) {
            toggleEmojiPicker();
        }
    });
    
    
    // Initialize connection
    connectToServer();
    
    // Update server URL when input changes (for global mode)
    document.getElementById('server-url-input').addEventListener('change', function() {
        if (networkMode === 'global') {
            const newURL = this.value.trim() || window.location.origin;
            if (newURL !== currentServerURL) {
                currentServerURL = newURL;
                if (socket && socket.connected) {
                    socket.disconnect();
                    connectToServer();
                }
            }
        }
    });
    
    // ========== ROOM MANAGEMENT ==========
    function createRoom() {
        if (!socket || !socket.connected) {
            alert('Ch∆∞a k·∫øt n·ªëi ƒë·∫øn server! Vui l√≤ng ki·ªÉm tra l·∫°i.');
            connectToServer();
            return;
        }
        socket.emit('createRoom');
    }
    
    let joinRoomTimeout = null;
    let joinRoomButton = null;
    
    function joinRoom() {
        const codeInput = document.getElementById('room-code-input');
        const code = codeInput.value.trim().toUpperCase();
        
        if (!code || code.length !== 6) {
            alert('M√£ ph√≤ng kh√¥ng h·ª£p l·ªá! Vui l√≤ng nh·∫≠p ƒë√∫ng 6 k√Ω t·ª±.');
            codeInput.focus();
            return;
        }
        
        // L·∫•y button
        joinRoomButton = document.querySelector('button[onclick="joinRoom()"]');
        
        // Ki·ªÉm tra k·∫øt n·ªëi
        if (!socket) {
            if (msgEl) {
                msgEl.innerText = 'ƒêang k·∫øt n·ªëi ƒë·∫øn server...';
                msgEl.style.color = '#f39c12';
            }
            connectToServer();
            // ƒê·ª£i k·∫øt n·ªëi r·ªìi th·ª≠ l·∫°i
            setTimeout(() => {
                if (socket && socket.connected) {
                    joinRoom();
                } else {
                    if (msgEl) {
                        msgEl.innerText = 'Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server. Vui l√≤ng ki·ªÉm tra l·∫°i k·∫øt n·ªëi m·∫°ng.';
                        msgEl.style.color = '#e74c3c';
                    }
                }
            }, 3000);
            return;
        }
        
        if (!socket.connected) {
            if (msgEl) {
                msgEl.innerText = 'ƒêang k·∫øt n·ªëi l·∫°i... Vui l√≤ng ƒë·ª£i.';
                msgEl.style.color = '#f39c12';
            }
            socket.connect();
            // ƒê·ª£i k·∫øt n·ªëi r·ªìi th·ª≠ l·∫°i
            let retryCount = 0;
            const checkConnection = setInterval(() => {
                retryCount++;
                if (socket.connected) {
                    clearInterval(checkConnection);
                    if (msgEl) msgEl.innerText = '';
                    joinRoom(); // G·ªçi l·∫°i h√†m
                } else if (retryCount > 10) {
                    clearInterval(checkConnection);
                    if (msgEl) {
                        msgEl.innerText = 'Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server. Vui l√≤ng refresh trang.';
                        msgEl.style.color = '#e74c3c';
                    }
                }
            }, 1000);
            return;
        }
        
        // Hi·ªÉn th·ªã loading
        if (joinRoomButton) {
            joinRoomButton.disabled = true;
            joinRoomButton.textContent = 'ƒêang tham gia...';
        }
        
        if (msgEl) {
            msgEl.innerText = 'ƒêang tham gia ph√≤ng...';
            msgEl.style.color = '#3498db';
        }
        
        // Clear timeout c≈© n·∫øu c√≥
        if (joinRoomTimeout) {
            clearTimeout(joinRoomTimeout);
        }
        
        // Set timeout cho joinRoom (15 gi√¢y cho m·∫°ng y·∫øu)
        joinRoomTimeout = setTimeout(() => {
            if (joinRoomButton) {
                joinRoomButton.disabled = false;
                joinRoomButton.textContent = 'Tham Gia Ph√≤ng';
            }
            if (msgEl) {
                msgEl.innerText = 'Kh√¥ng th·ªÉ tham gia ph√≤ng. C√≥ th·ªÉ ph√≤ng kh√¥ng t·ªìn t·∫°i ho·∫∑c m·∫°ng qu√° ch·∫≠m.';
                msgEl.style.color = '#e74c3c';
            }
            joinRoomTimeout = null;
        }, 15000); // 15 gi√¢y timeout cho m·∫°ng y·∫øu
        
        // G·ª≠i request join room
        console.log('Sending joinRoom request:', code);
        socket.emit('joinRoom', { roomCode: code });
    }
    
    // Coin flip function - only host can flip
    // coinFlipped and coinResult are declared above in MULTIPLAYER STATE section
    
    function flipCoin() {
        console.log('flipCoin called', { coinFlipped, isOnlineGame, gameRoomId, isHost, playerId });
        
        // Ki·ªÉm tra ƒëi·ªÅu ki·ªán
        if (coinFlipped) {
            console.log('Coin already flipped');
            return;
        }
        
        if (!isOnlineGame) {
            console.log('Not online game');
            return;
        }
        
        if (!gameRoomId) {
            console.log('No game room ID');
            return;
        }
        
        if (!isHost) {
            alert('Ch·ªâ Player 1 m·ªõi ƒë∆∞·ª£c tung ƒë·ªìng xu!');
            console.log('Not host, cannot flip');
            return;
        }
        
        const coin = document.getElementById('coin');
        const resultEl = document.getElementById('coin-result');
        
        if (!coin || !resultEl) {
            console.error('Coin or result element not found');
            return;
        }
        
        console.log('Starting coin flip...');
        coin.classList.add('flipping');
        coin.style.pointerEvents = 'none';
        coin.style.cursor = 'not-allowed';
        
        setTimeout(() => {
            const result = Math.random() < 0.5 ? 'heads' : 'tails';
            coinFlipped = true;
            coinResult = result;
            
            console.log('Coin flip result:', result);
            
            // Player 1 sees heads (horse) or tails (empty)
            // Player 2 will see the opposite
            if (result === 'heads') {
                resultEl.textContent = 'ü™ô B·∫°n th·∫•y M·∫∂T NG·ª¨A! Ch·ªçn b√™n b·∫°n mu·ªën ch∆°i:';
                // Show choice buttons for Player 1
                document.getElementById('player1-choice').style.display = 'block';
            } else {
                resultEl.textContent = 'ü™ô B·∫°n th·∫•y M·∫∂T √öP (m·∫∑t sau)! Ch·ªçn b√™n b·∫°n mu·ªën ch∆°i:';
                // Show choice buttons for Player 1
                document.getElementById('player1-choice').style.display = 'block';
            }
            resultEl.style.display = 'block';
            
            // Send result to server (Player 1 sees result, Player 2 sees opposite)
            socket.emit('coinFlipResult', { roomCode: gameRoomId, result, playerId: playerId });
            console.log('Coin flip result sent to server');
        }, 2000);
    }
    
    // Function for player to choose side (can be Player 1 or Player 2)
    function chooseSide(chosenSide) {
        if (!coinResult || !isOnlineGame || !gameRoomId) return;
        
        // Send choice to server (server will check if this player can choose)
        socket.emit('playerChooseSide', { 
            roomCode: gameRoomId, 
            chosenSide: chosenSide,
            coinResult: coinResult 
        });
        
        // Hide choice buttons
        document.getElementById('player1-choice').style.display = 'none';
    }
    
    // Listen for coin flip result from server
    socket.on('coinFlipCompleted', ({ result, playerView, whoChooses, canChoose }) => {
        const resultEl = document.getElementById('coin-result');
        const coin = document.getElementById('coin');
        const coinInstruction = document.getElementById('coin-flip-instruction');
        
        // Update coin display based on what player sees
        coin.classList.remove('flipping');
        coin.style.pointerEvents = 'none';
        
        // Store coin result
        coinResult = result;
        
        // Check if this player can choose
        if (canChoose) {
            // This player can choose side
            if (playerView === 'heads') {
                coin.style.transform = 'rotateY(0deg)';
                resultEl.textContent = 'ü™ô B·∫°n th·∫•y M·∫∂T NG·ª¨A! Ch·ªçn b√™n b·∫°n mu·ªën ch∆°i:';
            } else {
                coin.style.transform = 'rotateY(180deg)';
                resultEl.textContent = 'ü™ô B·∫°n th·∫•y M·∫∂T √öP (m·∫∑t sau)! Ch·ªçn b√™n b·∫°n mu·ªën ch∆°i:';
            }
            // Show choice buttons
            document.getElementById('player1-choice').style.display = 'block';
            if (coinInstruction) {
                coinInstruction.textContent = 'B·∫°n ƒë∆∞·ª£c quy·ªÅn ch·ªçn b√™n!';
            }
        } else {
            // Other player chooses
            const chooserName = whoChooses === 'player1' ? 'Player 1' : 'Player 2';
            if (playerView === 'heads') {
                coin.style.transform = 'rotateY(0deg)';
                resultEl.textContent = `ü™ô B·∫°n th·∫•y M·∫∂T NG·ª¨A! ƒêang ch·ªù ${chooserName} ch·ªçn b√™n...`;
            } else {
                coin.style.transform = 'rotateY(180deg)';
                resultEl.textContent = `ü™ô B·∫°n th·∫•y M·∫∂T √öP (m·∫∑t sau)! ƒêang ch·ªù ${chooserName} ch·ªçn b√™n...`;
            }
            document.getElementById('player1-choice').style.display = 'none';
            if (coinInstruction) {
                coinInstruction.textContent = `ƒêang ch·ªù ${chooserName} ch·ªçn b√™n...`;
            }
        }
        resultEl.style.display = 'block';
    });
    
    // Dice roll function - both players roll
    let otherPlayerDiceResult = null;
    
    function rollDice() {
        console.log('rollDice called:', { diceRolled, isOnlineGame, gameRoomId, isHost, playerId });
        
        if (diceRolled) {
            console.log('Dice already rolled');
            return;
        }
        
        if (!isOnlineGame) {
            console.log('Not online game');
            return;
        }
        
        if (!gameRoomId) {
            console.log('No game room ID');
            return;
        }
        
        const dice = document.getElementById('dice');
        const resultEl = document.getElementById('dice-result-text');
        
        if (!dice || !resultEl) {
            console.log('Dice elements not found');
            return;
        }
        
        dice.classList.add('rolling');
        dice.style.pointerEvents = 'none';
        
        setTimeout(() => {
            // Ch·ªâ tung 1 x√∫c x·∫Øc t·ª´ 1-6
            const diceResult = Math.floor(Math.random() * 6) + 1;
            diceRolled = true;
            
            const playerName = isHost ? 'Player 1' : 'Player 2';
            resultEl.innerHTML = `üé≤ <strong>${playerName}</strong>: <strong>${diceResult}</strong><br>ƒêang ch·ªù ƒë·ªëi th·ªß...`;
            resultEl.style.display = 'block';
            
            console.log('Sending dice result to server:', { roomCode: gameRoomId, diceResult });
            
            // Send result to server (ch·ªâ g·ª≠i 1 k·∫øt qu·∫£)
            socket.emit('diceRollResult', { 
                roomCode: gameRoomId, 
                diceResult: diceResult 
            });
        }, 1500);
    }
    
    // Listen for other player's dice result
    socket.on('diceRolled', ({ playerId: otherPlayerId, playerName, diceResult }) => {
        console.log('diceRolled event received:', { otherPlayerId, playerId, playerName, diceResult, diceRolled });
        if (otherPlayerId !== playerId) {
            const resultEl = document.getElementById('dice-result-text');
            if (!resultEl) return;
            
            if (diceRolled) {
                // Both players have rolled, update display
                const currentText = resultEl.innerHTML;
                resultEl.innerHTML = currentText.replace('ƒêang ch·ªù ƒë·ªëi th·ªß...', `<br>üé≤ <strong>${playerName}</strong>: <strong>${diceResult}</strong>`);
            } else {
                // Other player rolled first
                resultEl.innerHTML = `üé≤ <strong>${playerName}</strong>: <strong>${diceResult}</strong><br>ƒê·∫øn l∆∞·ª£t b·∫°n tung x√∫c x·∫Øc!`;
                resultEl.style.display = 'block';
                
                // ƒê·∫£m b·∫£o dice c√≥ th·ªÉ click ƒë∆∞·ª£c
                const dice = document.getElementById('dice');
                if (dice) {
                    dice.style.pointerEvents = 'auto';
                    dice.style.cursor = 'pointer';
                    dice.onclick = rollDice;
                }
            }
        }
    });
    
    // Copy room code function
    function copyRoomCode() {
        const roomCode = document.getElementById('room-code-display').textContent;
        if (!roomCode || roomCode === 'ABC123') {
            alert('Ch∆∞a c√≥ m√£ ph√≤ng!');
            return;
        }
        
        // Copy to clipboard
        navigator.clipboard.writeText(roomCode).then(() => {
            // Show success message
            const successMsg = document.getElementById('copy-success-msg');
            if (successMsg) {
                successMsg.style.display = 'block';
                setTimeout(() => {
                    successMsg.style.display = 'none';
                }, 2000);
            }
        }).catch(err => {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = roomCode;
            textArea.style.position = 'fixed';
            textArea.style.opacity = '0';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                const successMsg = document.getElementById('copy-success-msg');
                if (successMsg) {
                    successMsg.style.display = 'block';
                    setTimeout(() => {
                        successMsg.style.display = 'none';
                    }, 2000);
                }
            } catch (err) {
                alert('Kh√¥ng th·ªÉ copy m√£ ph√≤ng. M√£ ph√≤ng: ' + roomCode);
            }
            document.body.removeChild(textArea);
        });
    }
    
    // Reset game to menu
    function resetToMenu() {
        // Reset all game state
        isGameOver = false;
        isOnlineGame = false;
        isBotMode = false;
        gameRoomId = null;
        isHost = false;
        playerId = null;
        coinFlipped = false;
        coinResult = null;
        diceRolled = false;
        playerSide = null;
        selectedPiece = null;
        validMoves = [];
        pieces = [];
        deadChess = [];
        deadXQ = [];
        currentTurn = "chess";
        lastMove = null;
        enPassantTarget = null;
        gameHistory = [];
        viewIndex = -1;
        isReviewing = false;
        pendingPromotion = null;
        botSide = null;
        
        // Disconnect socket if connected
        if (socket && socket.connected) {
            socket.disconnect();
            console.log('Disconnected from server for menu reset');
        }
        
        // Hide all game screens
        const gameOverEl = document.getElementById('game-over');
        const startScreenEl = document.getElementById('start-screen');
        const roomInfoEl = document.getElementById('room-info');
        const diceSectionEl = document.getElementById('dice-section');
        const coinFlipSectionEl = document.getElementById('coin-flip-section');
        const boardContainerEl = document.getElementById('board-container');
        const chatButtonEl = document.getElementById('chat-button');
        const chatContainerEl = document.getElementById('chat-container');
        
        if (gameOverEl) gameOverEl.style.display = 'none';
        if (roomInfoEl) roomInfoEl.style.display = 'none';
        if (diceSectionEl) diceSectionEl.style.display = 'none';
        if (coinFlipSectionEl) coinFlipSectionEl.style.display = 'none';
        if (boardContainerEl) boardContainerEl.style.display = 'none';
        if (chatButtonEl) chatButtonEl.classList.remove('show');
        if (chatContainerEl) chatContainerEl.classList.remove('show');
        
        // Show start screen
        if (startScreenEl) {
            startScreenEl.style.display = 'flex';
        }
        
        // Reset UI
        if (msgEl) {
            msgEl.innerText = '';
            msgEl.style.color = '';
        }
        
        // Clear board
        if (boardEl) {
            boardEl.innerHTML = '';
        }
        
        console.log('Reset to menu completed');
    }
    
    // Play again function
    function playAgain() {
        if (isOnlineGame && gameRoomId) {
            // Online game - disconnect and reset
            if (socket && socket.connected) {
                socket.emit('leaveRoom', { roomCode: gameRoomId });
                socket.disconnect();
            }
            resetToMenu();
            // Reconnect after a short delay
            setTimeout(() => {
                connectToServer();
            }, 500);
        } else if (isBotMode) {
            // Bot game - just reset
            resetToMenu();
        } else {
            // Offline game - reset
            resetToMenu();
        }
    }
    
    function startOnlineGame(firstTurn) {
        console.log('startOnlineGame called:', { firstTurn, isOnlineGame, isBotMode });
        
        isOnlineGame = true;
        isBotMode = false; // ƒê·∫£m b·∫£o kh√¥ng ph·∫£i bot mode
        
        // Initialize game state
        pieces = JSON.parse(JSON.stringify(INITIAL_SETUP));
        deadChess = [];
        deadXQ = [];
        currentTurn = firstTurn;
        isGameOver = false;
        lastMove = null;
        enPassantTarget = null;
        selectedPiece = null;
        validMoves = [];
        
        // Hide start screen
        const startScreen = document.getElementById('start-screen');
        if (startScreen) {
            startScreen.style.display = 'none';
        }
        
        // Show game board container
        const boardContainer = document.getElementById('board-container');
        if (boardContainer) {
            boardContainer.style.display = 'block';
        }
        
        // Also show graves and other game elements
        const graves = document.getElementById('graves');
        if (graves) {
            graves.style.display = 'flex';
        }
        
        // Draw the board
        console.log('Drawing board...');
        drawBoard();
        
        console.log('Game started successfully:', { currentTurn, playerSide, piecesCount: pieces.length });
    }
    
    function syncGameState() {
        if (!isOnlineGame || !gameRoomId) return;
        
        const gameState = {
            pieces: pieces,
            deadChess: deadChess,
            deadXQ: deadXQ,
            currentTurn: currentTurn,
            lastMove: lastMove,
            isGameOver: isGameOver,
            winner: isGameOver ? (currentTurn === 'chess' ? 'xiangqi' : 'chess') : null
        };
        
        socket.emit('updateGameState', { roomCode: gameRoomId, gameState });
    }
    
    // --- AUDIO ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        if (type === 'move') {
            osc.frequency.setValueAtTime(600, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.start(); osc.stop(audioCtx.currentTime + 0.1);
        } else {
            osc.type = 'square'; osc.frequency.setValueAtTime(150, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.2);
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            osc.start(); osc.stop(audioCtx.currentTime + 0.2);
        }
    }

    // --- CONFIG ---
    const ROWS = 10; const COLS = 9;
    const XQ_CHARS = { "xe": "Ëªä", "m√£": "È¶¨", "t∆∞·ª£ng": "Áõ∏", "sƒ©": "‰ªï", "t∆∞·ªõng": "Â∏•", "ph√°o": "ÁÇÆ", "t·ªët": "ÂÖµ" };
    
    // --- STATE ---
    let pieces = [];
    let deadChess = []; // Qu√¢n tr·∫Øng ch·∫øt
    let deadXQ = [];    // Qu√¢n ƒë·ªè ch·∫øt
    let currentTurn = "chess";
    let selectedPiece = null;
    let isGameOver = false;
    let lastMove = null; 
    let gameHistory = []; 
    let viewIndex = -1;
    let isReviewing = false;
    let pendingPromotion = null; // Qu√¢n T·ªët ƒëang ch·ªù phong c·∫•p
    let isBotMode = false; // Ch·∫ø ƒë·ªô ch∆°i v·ªõi BOT
    let botSide = null; // B√™n m√† BOT ch∆°i (chess ho·∫∑c xiangqi)
    let enPassantTarget = null; // {r, c} - V·ªã tr√≠ t·ªët c√≥ th·ªÉ b·ªã ƒÉn en passant

    // Elements
    const boardEl = document.getElementById("board");
    const turnBadge = document.getElementById("turn-badge");
    const msgEl = document.getElementById("message");
    const graveTop = document.getElementById("grave-top"); // Ch·ª©a qu√¢n tr·∫Øng ch·∫øt
    const graveBot = document.getElementById("grave-bot"); // Ch·ª©a qu√¢n ƒë·ªè ch·∫øt
    const btnPrev = document.getElementById("btn-prev");
    const btnNext = document.getElementById("btn-next");
    const btnLive = document.getElementById("btn-live");
    const promoModal = document.getElementById("promotion-modal");

    const INITIAL_SETUP = [
        { type: "rook", side: "chess", r: 0, c: 0, hasMoved: false }, { type: "knight", side: "chess", r: 0, c: 1 },
        { type: "bishop", side: "chess", r: 0, c: 2 }, { type: "queen", side: "chess", r: 0, c: 3 },
        { type: "king", side: "chess", r: 0, c: 4, hasMoved: false }, { type: "bishop", side: "chess", r: 0, c: 5 },
        { type: "knight", side: "chess", r: 0, c: 6 }, { type: "rook", side: "chess", r: 0, c: 7, hasMoved: false },
        ...Array.from({ length: 8 }, (_, i) => ({ type: "pawn", side: "chess", r: 1, c: i, hasMoved: false, hasShield: true })),
        { type: "xe", side: "xiangqi", r: 9, c: 0 }, { type: "m√£", side: "xiangqi", r: 9, c: 1 },
        { type: "t∆∞·ª£ng", side: "xiangqi", r: 9, c: 2 }, { type: "sƒ©", side: "xiangqi", r: 9, c: 3 },
        { type: "t∆∞·ªõng", side: "xiangqi", r: 9, c: 4 }, { type: "sƒ©", side: "xiangqi", r: 9, c: 5 },
        { type: "t∆∞·ª£ng", side: "xiangqi", r: 9, c: 6 }, { type: "m√£", side: "xiangqi", r: 9, c: 7 },
        { type: "xe", side: "xiangqi", r: 9, c: 8 },
        { type: "ph√°o", side: "xiangqi", r: 7, c: 1 }, { type: "ph√°o", side: "xiangqi", r: 7, c: 7 },
        ...[0,2,4,6,8].map(c => ({ type: "t·ªët", side: "xiangqi", r: 6, c })),
    ];

    // --- START ---
    function startGame() {
        // H√†m n√†y ch·ªâ d√πng cho offline mode (index_chess.html)
        // Kh√¥ng d√πng cho online/bot mode
        pieces = JSON.parse(JSON.stringify(INITIAL_SETUP));
        deadChess = []; deadXQ = [];
        enPassantTarget = null;
        let count = 0;
        const diceInterval = setInterval(() => {
            document.getElementById("dice-result").innerText = count % 2 ? "‚ôö" : "Â∏•";
            count++;
            if (count > 10) {
                clearInterval(diceInterval);
                currentTurn = Math.random() < 0.5 ? "chess" : "xiangqi";
                document.getElementById("dice-result").innerText = currentTurn === "chess" ? "C·ªù Vua ƒëi tr∆∞·ªõc" : "C·ªù T∆∞·ªõng ƒëi tr∆∞·ªõc";
                setTimeout(() => {
                    document.getElementById("start-screen").style.display = "none";
                    saveState();
                    drawBoard();
                }, 1000);
            }
        }, 100);
    }
    
    function startBotGame() {
        // Ki·ªÉm tra ng∆∞·ªùi ch∆°i ƒë√£ ch·ªçn b√™n ch∆∞a
        if (!playerSide) {
            playerSide = "chess"; // M·∫∑c ƒë·ªãnh l√† c·ªù Vua
            botSide = "xiangqi";
            document.getElementById('btn-choose-chess').classList.add('active');
            document.getElementById('btn-choose-xiangqi').classList.remove('active');
        } else {
            botSide = playerSide === "chess" ? "xiangqi" : "chess";
        }
        
        // ·∫®n menu v√† hi·ªÉn th·ªã dice section
        document.getElementById("bot-menu").style.display = "none";
        document.getElementById("dice-section").style.display = "block";
        
        // Tung x√∫c x·∫Øc ƒë·ªÉ quy·∫øt ƒë·ªãnh ai ƒëi tr∆∞·ªõc
        let count = 0;
        const diceInterval = setInterval(() => {
            const diceEl = document.getElementById("dice-result");
            if (diceEl) {
                diceEl.innerText = count % 2 ? (playerSide === "chess" ? "‚ôö" : "Â∏•") : (playerSide === "chess" ? "Â∏•" : "‚ôö");
            }
            count++;
            if (count > 10) {
                clearInterval(diceInterval);
                currentTurn = Math.random() < 0.5 ? playerSide : botSide;
                const resultEl = document.getElementById("dice-result");
                if (resultEl) {
                    const playerSideText = playerSide === "chess" ? "üè∞ C·ªù Vua" : "‚õ©Ô∏è C·ªù T∆∞·ªõng";
                    const botSideText = botSide === "chess" ? "üè∞ C·ªù Vua" : "‚õ©Ô∏è C·ªù T∆∞·ªõng";
                    resultEl.innerText = currentTurn === playerSide 
                        ? `B·∫°n ƒëi tr∆∞·ªõc (${playerSideText})` 
                        : `BOT ƒëi tr∆∞·ªõc (${botSideText})`;
                }
                setTimeout(() => {
                    document.getElementById("start-screen").style.display = "none";
                    document.getElementById("dice-section").style.display = "none";
                    saveState();
                    drawBoard();
                    
                    // N·∫øu BOT ƒëi tr∆∞·ªõc, cho BOT ƒëi ngay
                    if (currentTurn === botSide && isBotMode) {
                        console.log('Bot goes first, making move...');
                        setTimeout(() => botMakeMove(), 1000);
                    }
                }, 1000);
            }
        }, 100);
    }

    // --- LOGIC PHONG C·∫§P ---
    function promotePawn(newType) {
        if (!pendingPromotion) return;
        
        pendingPromotion.type = newType;
        playSound('capture'); // Sound effect
        promoModal.style.display = 'none';
        pendingPromotion = null;

        // Sau khi ch·ªçn xong m·ªõi k·∫øt th√∫c l∆∞·ª£t
        finishTurn();
        
        // Sync v·ªõi server n·∫øu ƒëang ch∆°i online
        if (isOnlineGame) {
            syncGameState();
        }
    }

    function finishTurn() {
        selectedPiece = null;
        
        // X√≥a en passant target khi ƒë·ªïi l∆∞·ª£t (ch·ªâ c√≥ th·ªÉ ƒÉn en passant ·ªü l∆∞·ª£t ti·∫øp theo)
        // Nh∆∞ng gi·ªØ l·∫°i n·∫øu t·ªët v·ª´a ƒëi 2 √¥ ·ªü l∆∞·ª£t n√†y
        // (enPassantTarget s·∫Ω ƒë∆∞·ª£c set trong tryMoveTo khi t·ªët ƒëi 2 √¥)
        
        currentTurn = currentTurn === "chess" ? "xiangqi" : "chess";
        
        // X√≥a en passant target sau khi ƒë·ªïi l∆∞·ª£t (n·∫øu kh√¥ng ƒë∆∞·ª£c s·ª≠ d·ª•ng)
        // Ch·ªâ gi·ªØ l·∫°i n·∫øu t·ªët v·ª´a ƒëi 2 √¥ ·ªü l∆∞·ª£t tr∆∞·ªõc
        // Logic n√†y ƒë∆∞·ª£c x·ª≠ l√Ω trong tryMoveTo

        if (isCheckmate(currentTurn)) {
            isGameOver = true;
            const winner = currentTurn === "chess" ? "xiangqi" : "chess";
            if (isBotMode) {
                document.getElementById("winner-text").innerText = (winner === playerSide ? "B·∫†N" : "BOT") + " TH·∫ÆNG!";
            } else {
                document.getElementById("winner-text").innerText = (winner === playerSide ? "B·∫†N" : "ƒê·ªêI TH·ª¶") + " TH·∫ÆNG!";
            }
            document.getElementById("game-over").style.display = "flex";
        }
        
        saveState();
        
        // Sync v·ªõi server n·∫øu ƒëang ch∆°i online
        if (isOnlineGame) {
            syncGameState();
        }
        
        drawBoard();
        
        // N·∫øu ƒëang ch∆°i v·ªõi BOT v√† ƒë·∫øn l∆∞·ª£t BOT, cho BOT ƒëi
        if (isBotMode && !isGameOver && currentTurn === botSide && botSide) {
            console.log('Calling botMakeMove from finishTurn...');
            setTimeout(() => botMakeMove(), 800);
        }
    }
    
    // ========== BOT AI ==========
    function botMakeMove() {
        if (isGameOver || currentTurn !== botSide || !isBotMode) {
            console.log('Bot cannot move:', { isGameOver, currentTurn, botSide, isBotMode });
            return;
        }
        
        console.log('Bot making move...', { botSide, currentTurn });
        
        // T√¨m t·∫•t c·∫£ c√°c n∆∞·ªõc ƒëi h·ª£p l·ªá c·ªßa BOT
        const botPieces = pieces.filter(p => p.side === botSide);
        const allMoves = [];
        
        for (const piece of botPieces) {
            const moves = getSafeMoves(piece);
            for (const move of moves) {
                allMoves.push({ piece, move });
            }
        }
        
        console.log('Bot found moves:', allMoves.length);
        
        if (allMoves.length === 0) {
            // Ki·ªÉm tra xem c√≥ ph·∫£i l√† chi·∫øu b√≠ kh√¥ng
            if (isKingInCheck(botSide)) {
                // BOT b·ªã chi·∫øu b√≠ - ng∆∞·ªùi ch∆°i th·∫Øng
                isGameOver = true;
                document.getElementById("winner-text").innerText = "B·∫†N TH·∫ÆNG!";
                document.getElementById("game-over").style.display = "flex";
                drawBoard();
                return;
            } else {
                // H√≤a c·ªù (stalemate) - kh√¥ng c√≥ n∆∞·ªõc ƒëi h·ª£p l·ªá nh∆∞ng kh√¥ng b·ªã chi·∫øu
                isGameOver = true;
                document.getElementById("winner-text").innerText = "H√íA C·ªú!";
                document.getElementById("game-over").style.display = "flex";
                drawBoard();
                return;
            }
        }
        
        // ∆Øu ti√™n c√°c n∆∞·ªõc ƒëi c√≥ th·ªÉ ƒÉn qu√¢n ƒë·ªëi th·ªß
        const captureMoves = allMoves.filter(({ move }) => {
            return pieces.some(p => p.r === move.r && p.c === move.c && p.side !== botSide);
        });
        
        // Ch·ªçn n∆∞·ªõc ƒëi
        let chosenMove;
        if (captureMoves.length > 0) {
            // ∆Øu ti√™n ƒÉn qu√¢n c√≥ gi√° tr·ªã cao h∆°n
            captureMoves.sort((a, b) => {
                const pieceA = pieces.find(p => p.r === a.move.r && p.c === a.move.c);
                const pieceB = pieces.find(p => p.r === b.move.r && p.c === b.move.c);
                const valueA = getPieceValue(pieceA);
                const valueB = getPieceValue(pieceB);
                return valueB - valueA; // S·∫Øp x·∫øp gi·∫£m d·∫ßn
            });
            chosenMove = captureMoves[0];
        } else {
            // Ch·ªçn ng·∫´u nhi√™n m·ªôt n∆∞·ªõc ƒëi h·ª£p l·ªá
            chosenMove = allMoves[Math.floor(Math.random() * allMoves.length)];
        }
        
        // Th·ª±c hi·ªán n∆∞·ªõc ƒëi
        const { piece, move } = chosenMove;
        selectedPiece = piece;
        
        // T√¨m qu√¢n b·ªã ƒÉn (n·∫øu c√≥)
        const targetIdx = pieces.findIndex(p => p.r === move.r && p.c === move.c);
        let captured = null;
        if (targetIdx !== -1) {
            captured = pieces[targetIdx];
            pieces.splice(targetIdx, 1);
            if (captured.side === "chess") deadChess.push(captured.type);
            else deadXQ.push(captured.type);
            playSound('capture');
        } else {
            playSound('move');
        }
        
        // X·ª≠ l√Ω nh·∫≠p th√†nh (castling) cho c·ªù Vua
        if (move.isCastle) {
            if (move.c === 6) {
                const rook = pieces.find(p => p.r === (botSide === "chess" ? 0 : 9) && p.c === 7);
                if (rook) { rook.c = 5; rook.hasMoved = true; }
            }
            if (move.c === 2) {
                const rook = pieces.find(p => p.r === (botSide === "chess" ? 0 : 9) && p.c === 0);
                if (rook) { rook.c = 3; rook.hasMoved = true; }
            }
        }
        
        // X·ª≠ l√Ω ƒÉn en passant cho BOT
        if (move.isEnPassantCapture && move.enPassantTarget) {
            const enPassantPieceIdx = pieces.findIndex(p => 
                p.r === move.enPassantTarget.r && 
                p.c === move.enPassantTarget.c &&
                p.type === "pawn" &&
                p.side !== piece.side
            );
            if (enPassantPieceIdx !== -1) {
                let captured = pieces[enPassantPieceIdx];
                pieces.splice(enPassantPieceIdx, 1);
                if (captured.side === "chess") deadChess.push(captured.type);
                else deadXQ.push(captured.type);
                playSound('capture');
            }
        }
        
        // C·∫≠p nh·∫≠t v·ªã tr√≠ qu√¢n c·ªù
        lastMove = { from: {r: piece.r, c: piece.c}, to: {r: move.r, c: move.c} };
        piece.r = move.r;
        piece.c = move.c;
        if (piece.type === "king" || piece.type === "rook") piece.hasMoved = true;
        
        // X√≥a khi√™n c·ªßa t·ªët c·ªù vua khi di chuy·ªÉn
        if (piece.type === "pawn" && piece.side === "chess") {
            piece.hasMoved = true;
            piece.hasShield = false; // M·∫•t khi√™n khi di chuy·ªÉn
        }
        
        // L∆∞u th√¥ng tin en passant target n·∫øu t·ªët ƒëi 2 √¥
        if (piece.side === "chess" && piece.type === "pawn" && move.isEnPassantMove) {
            enPassantTarget = {r: 3, c: move.c};
        } else {
            enPassantTarget = null;
        }
        
        // X·ª≠ l√Ω phong c·∫•p t·ªët c·ªù Vua
        if (piece.side === "chess" && piece.type === "pawn" && move.r === 9) {
            // BOT t·ª± ƒë·ªông ch·ªçn H·∫≠u
            piece.type = "queen";
        }
        
        // C·∫≠p nh·∫≠t lastMove
        lastMove = { from: {r: piece.r, c: piece.c}, to: {r: move.r, c: move.c} };
        
        // V·∫Ω l·∫°i b√†n c·ªù tr∆∞·ªõc khi k·∫øt th√∫c l∆∞·ª£t
        drawBoard();
        
        // K·∫øt th√∫c l∆∞·ª£t
        finishTurn();
    }
    
    function getPieceValue(piece) {
        if (!piece) return 0;
        const values = {
            // C·ªù Vua
            "pawn": 1, "knight": 3, "bishop": 3, "rook": 5, "queen": 9, "king": 100,
            // C·ªù T∆∞·ªõng
            "t·ªët": 1, "m√£": 4, "t∆∞·ª£ng": 2, "sƒ©": 2, "xe": 9, "ph√°o": 4.5, "t∆∞·ªõng": 100
        };
        return values[piece.type] || 0;
    }

    // --- HISTORY ---
    function saveState() {
        const state = {
            pieces: JSON.parse(JSON.stringify(pieces)),
            deadChess: [...deadChess], deadXQ: [...deadXQ],
            turn: currentTurn, lastMove: lastMove ? {...lastMove} : null, isGameOver: isGameOver
        };
        gameHistory.push(state);
        viewIndex = gameHistory.length - 1;
        updateControls();
    }

    function reviewMove(step) {
        let newIndex = viewIndex + step;
        if (newIndex >= 0 && newIndex < gameHistory.length) {
            viewIndex = newIndex; isReviewing = (viewIndex !== gameHistory.length - 1);
            drawBoard(gameHistory[viewIndex]); updateControls();
        }
    }

    function returnToLive() {
        viewIndex = gameHistory.length - 1; isReviewing = false;
        drawBoard(gameHistory[viewIndex]); updateControls();
    }

    function updateControls() {
        btnPrev.disabled = viewIndex <= 0; btnNext.disabled = viewIndex >= gameHistory.length - 1;
        if (isReviewing) {
            btnLive.classList.remove("active-live"); btnLive.innerText = "QUAY L·∫†I"; boardEl.style.borderColor = "#f1c40f";
        } else {
            btnLive.classList.add("active-live"); btnLive.innerText = "LIVE"; boardEl.style.borderColor = "#333";
        }
    }

    // --- DRAWING ---
    function drawBoard(state = null) {
        if (!state) state = { pieces, deadChess, deadXQ, turn: currentTurn, lastMove };
        const { pieces: rPieces, turn: rTurn, deadChess: rDC, deadXQ: rDX, lastMove: rLM } = state;

        boardEl.innerHTML = "";
        
        if (isReviewing) {
            turnBadge.innerText = `XEM L·∫†I (${viewIndex}/${gameHistory.length-1})`;
            turnBadge.style.background = "#555"; turnBadge.style.color = "#ccc";
        } else {
            updateStatusUI(rTurn, rPieces);
        }

        // Draw Grid
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                let square = document.createElement("div"); square.className = "square";
                if (r < 4 && (r + c) % 2 === 1) square.classList.add("dark");
                if (r === 4) { square.classList.add("river"); square.innerHTML = "<span>S·ªû H√Ä - H√ÅN GI·ªöI</span>"; }
                if (r > 4) {
                    square.classList.add("xq-grid");
                    if (r === 7 && c === 3) square.classList.add("palace-slash");
                    if (r === 7 && c === 5) square.classList.add("palace-backslash");
                    if (r === 8 && c === 4) square.innerHTML += `<div style="position:absolute;width:100%;height:1px;background:rgba(0,0,0,0.2);transform:rotate(45deg);"></div><div style="position:absolute;width:100%;height:1px;background:rgba(0,0,0,0.2);transform:rotate(-45deg);"></div>`;
                }
                if (rLM && ((r===rLM.from.r && c===rLM.from.c) || (r===rLM.to.r && c===rLM.to.c))) square.classList.add("last-move");
                if (!isReviewing) square.onclick = () => handleSquareClick(r, c);
                boardEl.appendChild(square);
            }
        }

        // Draw Pieces
        let kingInCheck = isKingInCheck(rTurn, rPieces);
        rPieces.forEach(p => {
            let idx = p.r * COLS + p.c; if(idx >= boardEl.children.length) return;
            let square = boardEl.children[idx]; let el = createPieceEl(p);
            if (!isReviewing && selectedPiece && selectedPiece.r === p.r && selectedPiece.c === p.c) el.classList.add("selected");
            if (kingInCheck && (p.type === "king" || p.type === "t∆∞·ªõng") && p.side === rTurn) el.classList.add("in-check");
            if (!isReviewing) el.onclick = (e) => { e.stopPropagation(); handlePieceClick(p); }; else el.style.cursor = "default";
            square.appendChild(el);
        });

        // Draw Hint Dots
        if (!isReviewing && selectedPiece && !isGameOver) {
            getSafeMoves(selectedPiece).forEach(m => {
                let idx = m.r * COLS + m.c;
                if(boardEl.children[idx]) {
                    let dot = document.createElement("div"); dot.className = "move-dot";
                    if (m.isCastle) dot.style.background = "gold";
                    boardEl.children[idx].appendChild(dot);
                }
            });
        }
        
        // Render Graveyards
        renderGraveyards(rDC, rDX);
        
        // Re-append Modal if cleared
        if(!isReviewing) boardEl.appendChild(promoModal); 
    }

    function createPieceEl(p) {
        let el = document.createElement("div"); el.className = "piece";
        if (p.side === "chess") { 
            el.classList.add("chess-side"); 
            el.innerHTML = getChessIcon(p.type);
            // Th√™m icon khi√™n cho t·ªët c·ªù vua ch∆∞a ƒëi
            if (p.type === "pawn" && p.hasShield !== false) {
                let shieldEl = document.createElement("span");
                shieldEl.className = "pawn-shield";
                shieldEl.innerHTML = "üõ°Ô∏è";
                shieldEl.style.position = "absolute";
                shieldEl.style.top = "-5px";
                shieldEl.style.right = "-5px";
                shieldEl.style.fontSize = "12px";
                shieldEl.title = "T·ªët c√≥ khi√™n - Ph√°o kh√¥ng th·ªÉ b·∫Øc c·∫ßu";
                el.style.position = "relative";
                el.appendChild(shieldEl);
            }
        }
        else { el.classList.add("xq-side"); el.innerText = XQ_CHARS[p.type] || p.type; }
        return el;
    }

    function renderGraveyards(dChess, dXQ) {
        graveTop.innerHTML = '<div class="grave-label">Qu√¢n Tr·∫Øng<br>B·ªã B·∫Øt</div>';
        graveBot.innerHTML = '<div class="grave-label">Qu√¢n ƒê·ªè<br>B·ªã B·∫Øt</div>';
        
        // Nh√≥m v√† ƒë·∫øm qu√¢n Tr·∫Øng b·ªã b·∫Øt
        let chessCount = {};
        dChess.forEach(p => {
            chessCount[p] = (chessCount[p] || 0) + 1;
        });
        
        Object.keys(chessCount).forEach(type => {
            let count = chessCount[type];
            let el = document.createElement("div");
            el.classList.add("captured-piece", "chess-side");
            
            let iconEl = document.createElement("div");
            iconEl.className = "piece-icon";
            iconEl.innerHTML = getChessIcon(type);
            el.appendChild(iconEl);
            
            if (count > 1) {
                let countEl = document.createElement("span");
                countEl.className = "count";
                countEl.textContent = `x${count}`;
                el.appendChild(countEl);
            }
            
            graveTop.appendChild(el);
        });

        // Nh√≥m v√† ƒë·∫øm qu√¢n ƒê·ªè b·ªã b·∫Øt
        let xqCount = {};
        dXQ.forEach(p => {
            xqCount[p] = (xqCount[p] || 0) + 1;
        });
        
        Object.keys(xqCount).forEach(type => {
            let count = xqCount[type];
            let el = document.createElement("div");
            el.classList.add("captured-piece", "xq-side");
            
            let iconEl = document.createElement("div");
            iconEl.className = "piece-icon";
            iconEl.innerText = XQ_CHARS[type] || type;
            el.appendChild(iconEl);
            
            if (count > 1) {
                let countEl = document.createElement("span");
                countEl.className = "count";
                countEl.textContent = `x${count}`;
                el.appendChild(countEl);
            }
            
            graveBot.appendChild(el);
        });
    }

    function updateStatusUI(turn, _pieces) {
        turnBadge.innerText = turn === "chess" ? "L∆∞·ª£t: C·ªù Vua" : "L∆∞·ª£t: C·ªù T∆∞·ªõng";
        turnBadge.style.background = turn === "chess" ? "#fff" : "#cc0000";
        turnBadge.style.color = turn === "chess" ? "#000" : "#fff";
        msgEl.innerText = isKingInCheck(turn, _pieces) ? "‚ö†Ô∏è CHI·∫æU T∆Ø·ªöNG!" : "";
    }

    // --- INTERACTION ---
    function handlePieceClick(p) {
        if (isGameOver || isReviewing || pendingPromotion) return;
        
        // N·∫øu ƒë√£ ch·ªçn qu√¢n v√† click v√†o qu√¢n ƒë·ªëi th·ªß, th·ª≠ di chuy·ªÉn/ƒÉn
        if (selectedPiece && selectedPiece.side !== p.side) {
            // Ki·ªÉm tra l∆∞·ª£t ch∆°i n·∫øu ƒëang online
            if (isOnlineGame) {
                if (currentTurn !== playerSide) {
                    msgEl.innerText = "Kh√¥ng ph·∫£i l∆∞·ª£t c·ªßa b·∫°n!";
                    setTimeout(() => msgEl.innerText = "", 2000);
                    return;
                }
                if (selectedPiece.side !== playerSide) {
                    msgEl.innerText = "B·∫°n ch·ªâ c√≥ th·ªÉ di chuy·ªÉn qu√¢n c·ªßa m√¨nh!";
                    setTimeout(() => msgEl.innerText = "", 2000);
                    return;
                }
            }
            // Cho ph√©p ƒÉn qu√¢n ƒë·ªëi th·ªß
            tryMoveTo(p.r, p.c);
            return;
        }
        
        // Ki·ªÉm tra l∆∞·ª£t ch∆°i - ch·ªâ ƒë∆∞·ª£c ch·ªçn qu√¢n c·ªßa m√¨nh khi ƒë·∫øn l∆∞·ª£t m√¨nh
        if (isOnlineGame) {
            // Ki·ªÉm tra l∆∞·ª£t ch∆°i tr∆∞·ªõc
            if (currentTurn !== playerSide) {
                msgEl.innerText = "Kh√¥ng ph·∫£i l∆∞·ª£t c·ªßa b·∫°n!";
                setTimeout(() => msgEl.innerText = "", 2000);
                return;
            }
            // Ch·ªâ cho ph√©p ch·ªçn qu√¢n c·ªßa m√¨nh (kh√¥ng cho ch·ªçn qu√¢n ƒë·ªëi th·ªß khi ch∆∞a ch·ªçn qu√¢n)
            if (p.side !== playerSide) {
                msgEl.innerText = "B·∫°n ch·ªâ c√≥ th·ªÉ ch·ªçn qu√¢n c·ªßa m√¨nh!";
                setTimeout(() => msgEl.innerText = "", 2000);
                return;
            }
        }
        
        // Ki·ªÉm tra l∆∞·ª£t ch∆°i (cho c·∫£ offline v√† online)
        if (p.side !== currentTurn) {
            if (!isOnlineGame && !isBotMode) {
                msgEl.innerText = "Kh√¥ng ph·∫£i l∆∞·ª£t c·ªßa b·∫°n!";
                setTimeout(() => msgEl.innerText = "", 2000);
            }
            return;
        }
        
        // Trong ch·∫ø ƒë·ªô BOT, ch·ªâ cho ph√©p ch·ªçn qu√¢n c·ªßa m√¨nh
        if (isBotMode && p.side !== playerSide) {
            msgEl.innerText = "B·∫°n ch·ªâ c√≥ th·ªÉ ch·ªçn qu√¢n c·ªßa m√¨nh!";
            setTimeout(() => msgEl.innerText = "", 2000);
            return;
        }
        
        // Ch·ªçn qu√¢n c·ªù c·ªßa m√¨nh
        selectedPiece = p;
        drawBoard();
    }

    function handleSquareClick(r, c) {
        if (isGameOver || isReviewing || pendingPromotion || !selectedPiece) return;
        // Ki·ªÉm tra l∆∞·ª£t ch∆°i n·∫øu ƒëang online
        if (isOnlineGame && currentTurn !== playerSide) {
            msgEl.innerText = "ƒêang ch·ªù ƒë·ªëi th·ªß...";
            setTimeout(() => msgEl.innerText = "", 2000);
            return;
        }
        // Ki·ªÉm tra l∆∞·ª£t ch∆°i n·∫øu ƒëang ch∆°i v·ªõi BOT
        if (isBotMode && currentTurn !== playerSide) {
            msgEl.innerText = "ƒêang ch·ªù BOT...";
            setTimeout(() => msgEl.innerText = "", 2000);
            return;
        }
        tryMoveTo(r, c);
    }

    function tryMoveTo(r, c) {
        if (!selectedPiece) return;
        
        // Ki·ªÉm tra l∆∞·ª£t ch∆°i v√† qu√¢n c·ªù tr∆∞·ªõc khi di chuy·ªÉn
        if (isOnlineGame) {
            if (currentTurn !== playerSide) {
                msgEl.innerText = "Kh√¥ng ph·∫£i l∆∞·ª£t c·ªßa b·∫°n!";
                setTimeout(() => msgEl.innerText = "", 2000);
                selectedPiece = null;
                drawBoard();
                return;
            }
            if (selectedPiece.side !== playerSide) {
                msgEl.innerText = "B·∫°n ch·ªâ c√≥ th·ªÉ di chuy·ªÉn qu√¢n c·ªßa m√¨nh!";
                setTimeout(() => msgEl.innerText = "", 2000);
                selectedPiece = null;
                drawBoard();
                return;
            }
        }
        
        let moves = getSafeMoves(selectedPiece);
        let move = moves.find(m => m.r === r && m.c === c);

        if (move) {
            lastMove = { from: {r: selectedPiece.r, c: selectedPiece.c}, to: {r: r, c: c} };
            let targetIdx = pieces.findIndex(p => p.r === r && p.c === c);
            
            // X·ª≠ l√Ω ƒÉn en passant
            if (move.isEnPassantCapture && move.enPassantTarget) {
                // T√¨m v√† ƒÉn t·ªët ƒë·ªëi th·ªß ·ªü v·ªã tr√≠ en passant target
                const enPassantPieceIdx = pieces.findIndex(p => 
                    p.r === move.enPassantTarget.r && 
                    p.c === move.enPassantTarget.c &&
                    p.type === "pawn" &&
                    p.side !== selectedPiece.side
                );
                if (enPassantPieceIdx !== -1) {
                    let captured = pieces[enPassantPieceIdx];
                    pieces.splice(enPassantPieceIdx, 1);
                    if (captured.side === "chess") deadChess.push(captured.type);
                    else deadXQ.push(captured.type);
                    playSound('capture');
                }
            } else if (targetIdx !== -1) {
                // ƒÇn qu√¢n b√¨nh th∆∞·ªùng
                let captured = pieces[targetIdx]; pieces.splice(targetIdx, 1);
                if (captured.side === "chess") deadChess.push(captured.type); else deadXQ.push(captured.type);
                playSound('capture');
            } else {
                playSound('move');
            }

            if (move.isCastle) {
                if (c === 6) { let rook = pieces.find(p => p.r===0 && p.c===7); if (rook) { rook.c = 5; rook.hasMoved = true; } }
                if (c === 2) { let rook = pieces.find(p => p.r===0 && p.c===0); if (rook) { rook.c = 3; rook.hasMoved = true; } }
            }

            selectedPiece.r = r; selectedPiece.c = c;
            if (selectedPiece.type === "king" || selectedPiece.type === "rook") selectedPiece.hasMoved = true;
            
            // X√≥a khi√™n c·ªßa t·ªët c·ªù vua khi di chuy·ªÉn
            if (selectedPiece.type === "pawn" && selectedPiece.side === "chess") {
                selectedPiece.hasMoved = true;
                selectedPiece.hasShield = false; // M·∫•t khi√™n khi di chuy·ªÉn
            }

            // L∆∞u th√¥ng tin en passant target n·∫øu t·ªët ƒëi 2 √¥
            if (selectedPiece.side === "chess" && selectedPiece.type === "pawn" && move.isEnPassantMove) {
                // T·ªët v·ª´a ƒëi 2 √¥ t·ª´ h√†ng 1 ƒë·∫øn h√†ng 3, ƒë·ªëi th·ªß c√≥ th·ªÉ ƒÉn en passant ·ªü h√†ng 3
                enPassantTarget = {r: 3, c: c};
            } else {
                // X√≥a en passant target sau m·ªói l∆∞·ª£t (ch·ªâ c√≥ th·ªÉ ƒÉn en passant ·ªü l∆∞·ª£t ti·∫øp theo)
                enPassantTarget = null;
            }

            // CHECK PROMOTION (T·ªët c·ªù vua ƒë·∫øn h√†ng cu·ªëi)
            if (selectedPiece.side === "chess" && selectedPiece.type === "pawn" && r === 9) {
                pendingPromotion = selectedPiece;
                // Hi·ªÉn th·ªã modal phong c·∫•p v√† D·ª™NG L·∫†I, ch∆∞a ƒë·ªïi l∆∞·ª£t
                promoModal.style.display = 'flex';
                drawBoard(); // V·∫Ω l·∫°i ƒë·ªÉ th·∫•y qu√¢n t·ªët ƒë√£ ƒëi xu·ªëng
                return; // THO√ÅT H√ÄM, ch·ªù ng∆∞·ªùi ch∆°i ch·ªçn
            }

            finishTurn();
        } else {
            // N·∫øu kh√¥ng c√≥ n∆∞·ªõc ƒëi h·ª£p l·ªá
            msgEl.innerText = "N∆∞·ªõc ƒëi kh√¥ng h·ª£p l·ªá!";
            setTimeout(() => msgEl.innerText = "", 2000);
        }
    }

    // --- LOGIC MOVES ---
    function inside(r, c) { return r >= 0 && r < ROWS && c >= 0 && c < COLS; }
    function isOccupied(r, c, _pieces = pieces) { return _pieces.some(p => p.r === r && p.c === c); }
    function isAlly(r, c, side, _pieces = pieces) { return _pieces.some(p => p.r === r && p.c === c && p.side === side); }
    function isInPalace(r, c) { return r >= 7 && r <= 9 && c >= 3 && c <= 5; }

    function isSquareAttacked(r, c, sideBeingAttacked, _pieces = pieces) {
        let enemySide = sideBeingAttacked === "chess" ? "xiangqi" : "chess";
        let enemies = _pieces.filter(p => p.side === enemySide);
        for (let enemy of enemies) { if (getPseudoMoves(enemy, _pieces).some(m => m.r === r && m.c === c)) return true; }
        return false;
    }

    function isKingInCheck(side, _pieces = pieces) {
        let kingType = side === "chess" ? "king" : "t∆∞·ªõng";
        let king = _pieces.find(p => p.side === side && p.type === kingType);
        if (!king) return true; 
        return isSquareAttacked(king.r, king.c, side, _pieces);
    }

    function isCheckmate(side) {
        if (!isKingInCheck(side)) return false;
        let myPieces = pieces.filter(p => p.side === side);
        for (let p of myPieces) { if (getSafeMoves(p).length > 0) return false; }
        return true;
    }

    function getSafeMoves(p) {
        let moves = getPseudoMoves(p, pieces);
        return moves.filter(m => {
            let oldR = p.r, oldC = p.c;
            let capIdx = pieces.findIndex(t => t.r === m.r && t.c === m.c);
            let capPiece = null;
            if (capIdx !== -1) { capPiece = pieces[capIdx]; pieces.splice(capIdx, 1); }
            p.r = m.r; p.c = m.c;
            let safe = !isKingInCheck(p.side, pieces);
            p.r = oldR; p.c = oldC;
            if (capPiece) pieces.splice(capIdx, 0, capPiece);
            return safe;
        });
    }

    function getPseudoMoves(p, _pieces) {
        if (p.side === "chess") return getChessMoves(p, _pieces);
        return getXQMoves(p, _pieces);
    }

    function getChessMoves(p, _pieces) {
        let moves = [];
        const dirs = { rook: [[1,0],[-1,0],[0,1],[0,-1]], bishop: [[1,1],[1,-1],[-1,1],[-1,-1]], queen: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]] };
        if (p.type === "pawn") {
            // ƒêi th·∫≥ng 1 √¥
            if (!isOccupied(p.r+1, p.c, _pieces) && inside(p.r+1, p.c)) moves.push({r: p.r+1, c: p.c});
            // ƒêi th·∫≥ng 2 √¥ t·ª´ h√†ng ban ƒë·∫ßu
            if (p.r === 1 && !isOccupied(p.r+1, p.c, _pieces) && !isOccupied(p.r+2, p.c, _pieces)) {
                moves.push({r: p.r+2, c: p.c, isEnPassantMove: true});
            }
            // ƒÇn ch√©o b√¨nh th∆∞·ªùng
            [[1,1], [1,-1]].forEach(([dr, dc]) => {
                let nr = p.r+dr, nc = p.c+dc;
                if (inside(nr, nc) && isOccupied(nr, nc, _pieces) && !isAlly(nr, nc, p.side, _pieces)) {
                    moves.push({r: nr, c: nc});
                }
            });
            // ƒÇn en passant
            if (enPassantTarget && p.r === 3) { // T·ªët ·ªü h√†ng 3 (sau khi ƒë·ªëi th·ªß ƒëi 2 √¥)
                // Ki·ªÉm tra n·∫øu t·ªët ƒë·ªëi th·ªß ·ªü c·ªôt b√™n c·∫°nh v√† v·ª´a ƒëi 2 √¥
                if (enPassantTarget.c === p.c - 1 || enPassantTarget.c === p.c + 1) {
                    // C√≥ th·ªÉ ƒÉn en passant v√†o √¥ ph√≠a sau t·ªët ƒë·ªëi th·ªß
                    moves.push({r: enPassantTarget.r + 1, c: enPassantTarget.c, isEnPassantCapture: true, enPassantTarget: enPassantTarget});
                }
            }
        }
        else if (p.type === "knight") {
            [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dr,dc]) => {
                let nr = p.r+dr, nc = p.c+dc; if (inside(nr, nc) && !isAlly(nr, nc, p.side, _pieces)) moves.push({r: nr, c: nc});
            });
        }
        else if (p.type === "king") {
            [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc]) => {
                let nr = p.r+dr, nc = p.c+dc; if (inside(nr, nc) && !isAlly(nr, nc, p.side, _pieces)) moves.push({r: nr, c: nc});
            });
            if (_pieces === pieces && !p.hasMoved && !isKingInCheck("chess")) {
                if (!isOccupied(0, 5) && !isOccupied(0, 6)) {
                    let rook = _pieces.find(rp => rp.r===0 && rp.c===7 && rp.type==="rook" && !rp.hasMoved);
                    if (rook && !isSquareAttacked(0,5,"chess") && !isSquareAttacked(0,6,"chess")) moves.push({r: 0, c: 6, isCastle: true});
                }
                if (!isOccupied(0, 1) && !isOccupied(0, 2) && !isOccupied(0, 3)) {
                    let rook = _pieces.find(rp => rp.r===0 && rp.c===0 && rp.type==="rook" && !rp.hasMoved);
                    if (rook && !isSquareAttacked(0,3,"chess") && !isSquareAttacked(0,2,"chess")) moves.push({r: 0, c: 2, isCastle: true});
                }
            }
        }
        else if (dirs[p.type]) {
            dirs[p.type].forEach(([dr, dc]) => {
                let nr = p.r+dr, nc = p.c+dc;
                while (inside(nr, nc)) {
                    if (isAlly(nr, nc, p.side, _pieces)) break; moves.push({r: nr, c: nc}); if (isOccupied(nr, nc, _pieces)) break; nr += dr; nc += dc;
                }
            });
        }
        return moves;
    }

    function getXQMoves(p, _pieces) {
        let moves = [];
        const checkLine = (dirs, isCannon=false) => {
             dirs.forEach(([dr, dc]) => {
                let nr = p.r+dr, nc = p.c+dc; let hurdle=false; 
                while (inside(nr, nc)) {
                    let targetIdx = _pieces.findIndex(t => t.r === nr && t.c === nc);
                    let targetPiece = targetIdx !== -1 ? _pieces[targetIdx] : null;

                    if (!hurdle) {
                        if (!targetPiece) moves.push({r: nr, c: nc});
                        else {
                            if (!isCannon) {
                                if (targetPiece.side !== p.side) moves.push({r: nr, c: nc});
                                break;
                            } else {
                                // Ph√°o b·∫Øc c·∫ßu: c·∫ßn c√≥ 1 qu√¢n l√†m c·∫ßu
                                // N·∫øu g·∫∑p t·ªët c·ªù vua ch∆∞a ƒëi (c√≥ khi√™n) ‚Üí kh√¥ng th·ªÉ b·∫Øc c·∫ßu
                                if (targetPiece.side === "chess" && targetPiece.type === "pawn") {
                                    // Ki·ªÉm tra n·∫øu t·ªët c√≥ khi√™n (ch∆∞a ƒëi) ‚Üí kh√¥ng th·ªÉ b·∫Øc c·∫ßu
                                    if (targetPiece.hasShield !== false) {
                                        break; // Kh√¥ng th·ªÉ b·∫Øc c·∫ßu qua t·ªët c√≥ khi√™n
                                    } else {
                                        hurdle = true; // T·ªët ƒë√£ ƒëi ‚Üí c√≥ th·ªÉ b·∫Øc c·∫ßu
                                    }
                                } else {
                                    hurdle = true; // Qu√¢n kh√°c ‚Üí c√≥ th·ªÉ b·∫Øc c·∫ßu
                                }
                            }
                        }
                    } else {
                        if (targetPiece) {
                            if (targetPiece.side !== p.side) moves.push({r: nr, c: nc});
                            break;
                        }
                    }
                    nr += dr; nc += dc;
                }
            });
        }

        if (p.type==="xe") checkLine([[1,0],[-1,0],[0,1],[0,-1]]);
        if (p.type==="ph√°o") checkLine([[1,0],[-1,0],[0,1],[0,-1]], true);
        if (p.type==="m√£") {
            // M√£ ƒëi ch·ªØ L v·ªõi 8 h∆∞·ªõng: (2,1), (2,-1), (-2,1), (-2,-1), (1,2), (1,-2), (-1,2), (-1,-2)
            // M·ªói h∆∞·ªõng c√≥ 1 ƒëi·ªÉm ch·∫∑n (ƒëi·ªÉm ƒë·∫ßu ti√™n tr√™n ƒë∆∞·ªùng ƒëi)
            // N·∫øu ƒëi·ªÉm ch·∫∑n c√≥ qu√¢n ‚Üí kh√¥ng th·ªÉ ƒëi h∆∞·ªõng ƒë√≥ (lu·∫≠t c·∫£n m√£)
            const maMoves = [
                { dr: 2, dc: 1, blockR: 1, blockC: 0 },   // ƒêi xu·ªëng ph·∫£i ‚Üí ch·∫∑n ·ªü (1,0)
                { dr: 2, dc: -1, blockR: 1, blockC: 0 },  // ƒêi xu·ªëng tr√°i ‚Üí ch·∫∑n ·ªü (1,0)
                { dr: -2, dc: 1, blockR: -1, blockC: 0 }, // ƒêi l√™n ph·∫£i ‚Üí ch·∫∑n ·ªü (-1,0)
                { dr: -2, dc: -1, blockR: -1, blockC: 0 },// ƒêi l√™n tr√°i ‚Üí ch·∫∑n ·ªü (-1,0)
                { dr: 1, dc: 2, blockR: 0, blockC: 1 },    // ƒêi ph·∫£i xu·ªëng ‚Üí ch·∫∑n ·ªü (0,1)
                { dr: 1, dc: -2, blockR: 0, blockC: -1 }, // ƒêi tr√°i xu·ªëng ‚Üí ch·∫∑n ·ªü (0,-1)
                { dr: -1, dc: 2, blockR: 0, blockC: 1 },    // ƒêi ph·∫£i l√™n ‚Üí ch·∫∑n ·ªü (0,1)
                { dr: -1, dc: -2, blockR: 0, blockC: -1 }  // ƒêi tr√°i l√™n ‚Üí ch·∫∑n ·ªü (0,-1)
            ];
            
            maMoves.forEach(({dr, dc, blockR, blockC}) => {
                // Ki·ªÉm tra ƒëi·ªÉm ch·∫∑n (ƒëi·ªÉm ƒë·∫ßu ti√™n tr√™n ƒë∆∞·ªùng ƒëi)
                let blockRPos = p.r + blockR;
                let blockCPos = p.c + blockC;
                
                // N·∫øu ƒëi·ªÉm ch·∫∑n c√≥ qu√¢n ‚Üí kh√¥ng th·ªÉ ƒëi h∆∞·ªõng n√†y (b·ªã c·∫£n m√£)
                // NH∆ØNG: N·∫øu qu√¢n ch·∫∑n l√† t·ªët c·ªù vua (pawn) th√¨ KH√îNG ch·∫∑n m√£ c·ªù t∆∞·ªõng
                if (isOccupied(blockRPos, blockCPos, _pieces)) {
                    const blockingPiece = _pieces.find(piece => piece.r === blockRPos && piece.c === blockCPos);
                    // N·∫øu qu√¢n ch·∫∑n l√† t·ªët c·ªù vua v√† m√£ l√† c·ªù t∆∞·ªõng ‚Üí kh√¥ng b·ªã ch·∫∑n
                    if (blockingPiece && blockingPiece.type === 'pawn' && blockingPiece.side === 'chess' && p.side === 'xiangqi') {
                        // Kh√¥ng b·ªã ch·∫∑n, ti·∫øp t·ª•c ƒëi
                    } else {
                        return; // B·ªè qua h∆∞·ªõng n√†y (b·ªã ch·∫∑n)
                    }
                }
                
                // N·∫øu ƒëi·ªÉm ch·∫∑n kh√¥ng c√≥ qu√¢n ‚Üí c√≥ th·ªÉ ƒëi
                let nr = p.r + dr;
                let nc = p.c + dc;
                
                if (inside(nr, nc) && !isAlly(nr, nc, p.side, _pieces)) {
                    moves.push({r: nr, c: nc});
                }
            });
        }
        if (p.type==="t·ªët") {
             let nr=p.r-1; if(inside(nr,p.c) && !isAlly(nr,p.c,p.side, _pieces)) moves.push({r:nr, c:p.c});
             if(p.r<5) { if(inside(p.r,p.c-1)&&!isAlly(p.r,p.c-1,p.side, _pieces)) moves.push({r:p.r,c:p.c-1}); if(inside(p.r,p.c+1)&&!isAlly(p.r,p.c+1,p.side, _pieces)) moves.push({r:p.r,c:p.c+1}); }
        }
        if (p.type==="t∆∞·ªõng"||p.type==="sƒ©") {
            let dirs = p.type==="t∆∞·ªõng" ? [[1,0],[-1,0],[0,1],[0,-1]] : [[1,1],[1,-1],[-1,1],[-1,-1]];
            dirs.forEach(([dr,dc]) => {
                let nr=p.r+dr, nc=p.c+dc; if(inside(nr,nc) && isInPalace(nr,nc) && !isAlly(nr,nc,p.side, _pieces)) moves.push({r:nr, c:nc});
            });
        }
        if (p.type==="t∆∞·ª£ng") {
             [[2,2],[2,-2],[-2,2],[-2,-2]].forEach(([dr,dc]) => {
                let nr=p.r+dr, nc=p.c+dc;
                if(inside(nr,nc) && nr>=5 && !isAlly(nr,nc,p.side, _pieces)) {
                    let er=p.r+dr/2, ec=p.c+dc/2; if(!isOccupied(er,ec, _pieces)) moves.push({r:nr, c:nc});
                }
            });
        }
        return moves;
    }

    function getChessIcon(type) {
        switch (type) {
            case "king": return "‚ôö"; case "queen": return "‚ôõ"; case "rook": return "‚ôú";
            case "bishop": return "‚ôù"; case "knight": return "‚ôû"; case "pawn": return "‚ôü"; default: return "?";
        }
    }
</script>
</body>
</html>