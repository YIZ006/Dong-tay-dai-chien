<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ƒê√¥ng T√¢y ƒê·∫°i Chi·∫øn - Online Multiplayer (Socket.io)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Socket.io Client -->
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
    <style>
        :root {
            --cell: 60px;
            --board-bg: #deb887; /* M√†u n·ªÅn d·ª± ph√≤ng n·∫øu kh√¥ng d√πng ·∫£nh */
            --board-image: url('board-image.jpg'); /* Thay 'board-image.jpg' b·∫±ng t√™n file ·∫£nh c·ªßa b·∫°n */
            --river-color: #87ceeb;
            --bg-color: #1a1a1a;
            --panel-bg: #222;
            --text-gold: #f1c40f;
        }
        
        body {
            background: var(--bg-color);
            color: white;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            min-height: 100vh;
            user-select: none;
            overflow-x: hidden; /* Tr√°nh thanh cu·ªôn ngang */
            padding-bottom: 50px; /* Ch·ª´a ch·ªó cho footer */
        }

        /* --- LAYOUT --- */
        .game-wrapper {
            display: flex;
            flex-direction: column; /* X·∫øp d·ªçc */
            align-items: center;
            gap: 10px;
            margin-top: 5px;
        }

        /* --- TOP GRAVEYARD BAR --- */
        #graveyard-bar {
            width: calc(var(--cell) * 9 + 20px); /* B·∫±ng chi·ªÅu r·ªông b√†n c·ªù */
            background: #2a2a2a;
            border: 2px solid #555;
            border-radius: 8px;
            padding: 4px 8px;
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .grave-row {
            height: 28px;
            display: flex;
            align-items: center;
            gap: 3px;
            background: rgba(0,0,0,0.3);
            padding: 0 8px;
            border-radius: 4px;
            flex-wrap: wrap;
        }
        
        /* Nh√£n cho h√†ng t√π binh */
        .grave-label {
            font-size: 8px; color: #888; width: 50px; flex-shrink: 0;
            text-transform: uppercase; font-weight: bold; line-height: 1.2;
        }

        /* Qu√¢n c·ªù trong t√π binh */
        .captured-piece {
            display: flex;
            align-items: center;
            gap: 2px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            padding: 2px 6px;
            flex-shrink: 0;
        }
        .captured-piece .piece-icon {
            width: 18px;
            height: 18px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .captured-piece.chess-side { 
            font-size: 12px !important; 
            color: #bbb; 
            text-shadow: none; 
        }
        .captured-piece.chess-side .piece-icon {
            font-size: 12px !important;
            color: #bbb;
        }
        .captured-piece.xq-side { 
            font-size: 10px !important; 
            color: #e74c3c; 
            border: 1px solid #8b0000; 
            background: #f5deb3; 
        }
        .captured-piece.xq-side .piece-icon {
            font-size: 10px !important;
            color: #e74c3c;
        }
        .captured-piece .count {
            font-size: 10px;
            color: #aaa;
            font-weight: bold;
            margin-left: 2px;
        }
        .captured-piece.xq-side .count {
            color: #8b0000;
        }

        /* --- BOARD --- */
        #board-container {
            padding: 10px 35px 35px 10px; background: #5c4033; border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            position: relative;
            overflow: visible; /* Cho ph√©p hi·ªÉn th·ªã g√≥c b√†n c·ªù */
            margin: 10px;
        }
        
        /* Nh√£n s·ªë v√† ch·ªØ cho b√†n c·ªù - ch·ªâ hi·ªÉn th·ªã h√†ng d∆∞·ªõi v√† c·ªôt ph·∫£i */
        .board-label {
            position: absolute;
            color: #ffd700; /* M√†u v√†ng r√µ r√†ng, kh√¥ng tr√πng v·ªõi b√†n c·ªù */
            font-weight: bold;
            font-size: 18px;
            z-index: 10;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,1);
            user-select: none;
            background: rgba(0,0,0,0.3); /* N·ªÅn t·ªëi ƒë·ªÉ d·ªÖ nh√¨n */
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        /* Nh√£n s·ªë h√†ng b√™n ph·∫£i (ra ngo√†i r√¨a) */
        .board-label.row-label-right {
            right: -30px;
            top: 10px; /* CƒÉn v·ªõi padding top c·ªßa board-container */
            display: flex;
            flex-direction: column;
            height: calc(var(--cell) * 10);
            justify-content: flex-start;
            align-items: center;
            gap: 0;
            margin: 0;
            padding: 0;
        }
        
        /* Nh√£n ch·ªØ c·ªôt ph√≠a d∆∞·ªõi (ra ngo√†i r√¨a) */
        .board-label.col-label-bottom {
            bottom: -30px;
            left: 10px; /* CƒÉn v·ªõi padding left c·ªßa board-container */
            display: flex;
            width: calc(var(--cell) * 9);
            justify-content: flex-start;
            align-items: center;
            gap: 0;
            margin: 0;
            padding: 0;
        }
        
        .board-label-item {
            display: flex;
            align-items: center;
            justify-content: center;
            width: var(--cell);
            height: var(--cell);
            flex-shrink: 0;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        @media (max-width: 768px) {
            .board-label {
                font-size: 14px;
            }
            .board-label.row-label-right {
                right: -25px;
                top: 10px;
            }
            .board-label.col-label-bottom {
                bottom: -25px;
                left: 10px;
            }
        }
        
        /* Fix cho mobile - kh√¥ng b·ªã khu·∫•t g√≥c b√†n c·ªù */
        @media (max-width: 768px) {
            #board-container {
                padding: 5px;
                margin: 5px;
                overflow: visible;
            }
            #board {
                overflow: visible;
            }
            body {
                overflow-x: auto; /* Cho ph√©p scroll ngang n·∫øu c·∫ßn */
            }
        }
        #board {
            display: grid;
            grid-template-columns: repeat(9, var(--cell));
            grid-template-rows: repeat(10, var(--cell));
            background-color: var(--board-bg); /* M√†u n·ªÅn b√†n c·ªù c≈© */
            border: 3px solid #8b4513; /* Vi·ªÅn n√¢u ƒë·∫≠m */
            position: relative;
            /* V·∫Ω c√°c ƒë∆∞·ªùng k·∫ª ngang v√† d·ªçc b·∫±ng CSS */
            background-image: 
                /* ƒê∆∞·ªùng k·∫ª d·ªçc */
                repeating-linear-gradient(to right, 
                    transparent 0, 
                    transparent calc(var(--cell) - 2px),
                    rgba(0,0,0,0.4) calc(var(--cell) - 2px),
                    rgba(0,0,0,0.4) var(--cell)
                ),
                /* ƒê∆∞·ªùng k·∫ª ngang */
                repeating-linear-gradient(to bottom,
                    transparent 0,
                    transparent calc(var(--cell) - 2px),
                    rgba(0,0,0,0.4) calc(var(--cell) - 2px),
                    rgba(0,0,0,0.4) var(--cell)
                );
            background-size: 100% 100%;
        }
        
        /* V·∫Ω River (S√¥ng) ·ªü gi·ªØa */
        #board::before {
            content: '';
            position: absolute;
            top: calc(var(--cell) * 4);
            left: 0;
            right: 0;
            height: var(--cell);
            background: var(--river-color);
            z-index: 1;
            border-top: 2px solid rgba(0,0,0,0.3);
            border-bottom: 2px solid rgba(0,0,0,0.3);
        }
        
        /* Palace cho b√™n d∆∞·ªõi (C·ªù T∆∞·ªõng) - ch·ªâ c√≥ palace ·ªü ph·∫ßn c·ªù t∆∞·ªõng */
        .palace-bottom {
            position: absolute;
            bottom: calc(var(--cell) * 0);
            left: calc(var(--cell) * 3);
            width: calc(var(--cell) * 3);
            height: calc(var(--cell) * 3);
            border: 2px solid rgba(0,0,0,0.5);
            z-index: 1;
            pointer-events: none;
            /* V·∫Ω ƒë∆∞·ªùng ch√©o trong palace */
            background-image: 
                linear-gradient(to bottom right, transparent calc(50% - 1px), rgba(0,0,0,0.3) 50%, transparent calc(50% + 1px)),
                linear-gradient(to bottom left, transparent calc(50% - 1px), rgba(0,0,0,0.3) 50%, transparent calc(50% + 1px));
        }

        /* --- CONTROLS --- */
        #control-bar {
            margin-top: 10px; display: flex; gap: 10px; background: #333;
            padding: 8px 20px; border-radius: 50px; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .ctrl-btn {
            width: 40px; height: 40px; border-radius: 50%; border: none;
            background: #444; color: white; font-size: 1rem; cursor: pointer;
            transition: 0.2s; display: flex; justify-content: center; align-items: center;
        }
        .ctrl-btn:hover { background: #666; transform: scale(1.1); }
        .ctrl-btn:disabled { opacity: 0.3; cursor: not-allowed; transform: none; }
        .ctrl-btn.active-live { background: #e74c3c; box-shadow: 0 0 10px red; width: auto; padding: 0 20px; border-radius: 20px; font-weight: bold;}

        /* --- RULES MODAL --- */
        #rules-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 200;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow-y: auto;
        }
        #rules-modal.show {
            display: flex;
        }
        #rules-container {
            width: 100%;
            max-width: 800px;
            max-height: 90vh;
            background: #232323;
            border: 2px solid #555;
            border-radius: 12px;
            padding: 25px;
            box-sizing: border-box;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            overflow-y: auto;
            position: relative;
        }
        #rules-container::-webkit-scrollbar {
            width: 8px;
        }
        #rules-container::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }
        #rules-container::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }
        #rules-container::-webkit-scrollbar-thumb:hover {
            background: #666;
        }
        .rules-title {
            text-align: center;
            color: var(--text-gold);
            margin-top: 0;
            margin-bottom: 20px;
            border-bottom: 2px solid #444;
            padding-bottom: 15px;
            font-size: 1.6rem;
        }
        .rules-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .rule-box h3 {
            color: #e74c3c;
            font-size: 1.1rem;
            margin-bottom: 12px;
            margin-top: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .rule-box:first-child h3 { color: #dcdcdc; }
        .rule-box ul {
            padding-left: 20px;
            margin: 0;
            font-size: 0.95rem;
            color: #ccc;
            line-height: 1.7;
        }
        .rule-box li {
            margin-bottom: 8px;
        }
        .full-width {
            grid-column: span 2;
            border-top: 1px dashed #444;
            padding-top: 20px;
            margin-top: 10px;
        }
        .close-rules-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        .close-rules-btn:hover {
            background: #c0392b;
            transform: scale(1.1);
        }
        .rules-btn {
            margin-top: 15px;
            padding: 12px 25px;
            font-size: 1rem;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .rules-btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }
        @media (max-width: 700px) {
            #rules-container {
                max-width: 95%;
                padding: 20px;
            }
            .rules-grid {
                grid-template-columns: 1fr;
            }
            .full-width {
                grid-column: span 1;
            }
        }

        /* --- PROMOTION MODAL --- */
        #promotion-modal {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85); z-index: 50; border-radius: 8px;
            display: none; flex-direction: column; justify-content: center; align-items: center;
        }
        #promotion-modal h3 { color: var(--text-gold); margin-bottom: 20px; font-size: 1.5rem; }
        .promo-options { display: flex; gap: 20px; }
        .promo-btn {
            width: 60px; height: 60px; font-size: 40px; background: #444; color: #fdf5e6;
            border: 2px solid #fff; border-radius: 10px; cursor: pointer; transition: 0.2s;
        }
        .promo-btn:hover { background: #666; transform: scale(1.1); border-color: var(--text-gold); }
        
        /* --- SPECIAL TILE ACTIVATION MODAL --- */
        #special-activation-modal {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9); z-index: 100;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .activation-modal-content {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            border: 3px solid #f1c40f;
            border-radius: 20px;
            padding: 40px 50px;
            text-align: center;
            box-shadow: 0 10px 50px rgba(241, 196, 15, 0.5);
            max-width: 500px;
            animation: slideUp 0.4s ease-out;
        }
        
        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .activation-modal-content h2 {
            color: #f1c40f;
            font-size: 2rem;
            margin: 0 0 20px 0;
            text-shadow: 0 0 10px rgba(241, 196, 15, 0.8);
        }
        
        .activation-modal-content .icon {
            font-size: 4rem;
            margin: 20px 0;
            animation: pulse 1s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .activation-modal-content .description {
            color: #fdf5e6;
            font-size: 1.2rem;
            line-height: 1.6;
            margin: 20px 0;
        }
        
        .activation-modal-content .effect-detail {
            color: #2ecc71;
            font-size: 1rem;
            margin-top: 15px;
            padding: 15px;
            background: rgba(46, 204, 113, 0.1);
            border-radius: 10px;
            border: 1px solid rgba(46, 204, 113, 0.3);
        }
        
        .activation-modal-content button {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 1.1rem;
            background: #f1c40f;
            color: #1a1a1a;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(241, 196, 15, 0.4);
        }
        
        .activation-modal-content button:hover {
            background: #f39c12;
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(241, 196, 15, 0.6);
        }
        
        .activation-modal-content button:active {
            transform: scale(0.98);
        }

        /* --- VISUALS --- */
        .square { 
            width: var(--cell); 
            height: var(--cell); 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            position: relative; 
            z-index: 2; /* ƒê·∫£m b·∫£o square ·ªü tr√™n c√°c ƒë∆∞·ªùng k·∫ª */
        }
        .square.dark { background: rgba(139, 69, 19, 0.2); }
        
        /* Special Tile Styling - M√†u xanh da tr·ªùi ph√°t s√°ng */
        .square.special-tile {
            background: linear-gradient(135deg, rgba(30, 144, 255, 0.4), rgba(0, 191, 255, 0.4)) !important;
            border: 2px solid rgba(30, 144, 255, 0.8);
            position: relative;
            box-shadow: 0 0 15px rgba(30, 144, 255, 0.6), inset 0 0 10px rgba(0, 191, 255, 0.3);
            animation: glowBlue 2s ease-in-out infinite;
        }
        
        @keyframes glowBlue {
            0%, 100% { 
                box-shadow: 0 0 15px rgba(30, 144, 255, 0.6), inset 0 0 10px rgba(0, 191, 255, 0.3);
                border-color: rgba(30, 144, 255, 0.8);
            }
            50% { 
                box-shadow: 0 0 25px rgba(30, 144, 255, 0.9), 0 0 35px rgba(0, 191, 255, 0.6), inset 0 0 15px rgba(0, 191, 255, 0.5);
                border-color: rgba(0, 191, 255, 1);
            }
        }
        
        .square.special-tile::before {
            content: '‚ö°';
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 12px;
            z-index: 5;
            filter: drop-shadow(0 0 3px rgba(0, 191, 255, 0.8));
        }
        
        .square.special-tile-activated {
            animation: flashSpecialBlue 0.5s ease-in-out;
        }
        
        @keyframes flashSpecialBlue {
            0%, 100% { 
                background: linear-gradient(135deg, rgba(30, 144, 255, 0.4), rgba(0, 191, 255, 0.4));
                box-shadow: 0 0 15px rgba(30, 144, 255, 0.6);
            }
            50% { 
                background: linear-gradient(135deg, rgba(30, 144, 255, 0.9), rgba(0, 191, 255, 0.9));
                box-shadow: 0 0 30px rgba(30, 144, 255, 1), 0 0 50px rgba(0, 191, 255, 0.8);
            }
        }
        
        .square.special-tile-destroyed {
            background: rgba(100, 100, 100, 0.4) !important;
            border: 2px dashed rgba(150, 150, 150, 0.6);
            animation: none;
            box-shadow: none;
        }
        
        .square.special-tile-destroyed::before {
            content: 'üí•';
        }
        
        /* Unlocked General Overlay */
        .piece.unlocked-general {
            position: relative;
        }
        
        .piece.unlocked-general::after {
            content: '‚ú®';
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 16px;
            animation: sparkle 1.5s ease-in-out infinite;
            z-index: 10;
        }
        
        @keyframes sparkle {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.2); }
        }
        
        .river { 
            background: var(--river-color) !important; 
            position: relative; 
            z-index: 2;
        }
        .river span { 
            position: absolute; 
            width: 100%; 
            text-align: center; 
            font-size: 11px; 
            color: #444; 
            font-weight: bold; 
            pointer-events: none; 
            z-index: 3;
            top: 50%;
            transform: translateY(-50%);
        }
        .last-move { 
            background-color: rgba(255, 255, 0, 0.4) !important; 
            box-shadow: inset 0 0 10px orange; 
            z-index: 2;
        }
        
        /* Marker "L" cho c√°c v·ªã tr√≠ ƒë·∫∑c bi·ªát (Cannon v√† Pawn) */
        .square.marker::before {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            border: 2px solid rgba(0,0,0,0.4);
            border-top: none;
            border-right: none;
            z-index: 1;
        }
        .square.marker-top-left::before {
            top: 2px;
            left: 2px;
        }
        .square.marker-top-right::before {
            top: 2px;
            right: 2px;
            transform: rotate(90deg);
        }
        .square.marker-bottom-left::before {
            bottom: 2px;
            left: 2px;
            transform: rotate(-90deg);
        }
        .square.marker-bottom-right::before {
            bottom: 2px;
            right: 2px;
            transform: rotate(180deg);
        }

        .piece { width: 85%; height: 85%; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: transform 0.2s; position: relative; z-index: 10; }
        .piece:hover { transform: scale(1.1); }
        .piece.selected { transform: scale(1.15); filter: drop-shadow(0 0 5px yellow); }
        .in-check { background-color: rgba(255, 0, 0, 0.6) !important; box-shadow: 0 0 15px red; border-radius: 50%; }

        .piece.chess-side { font-size: 40px; color: #fdf5e6; text-shadow: 1px 1px 2px black; }
        .piece.xq-side { background: #f5deb3; border-radius: 50%; border: 3px solid #8b0000; color: #cc0000; font-family: "KaiTi", serif; font-weight: bold; font-size: 22px; box-shadow: 2px 2px 5px rgba(0,0,0,0.4); }
        .piece.xq-side::before { content: ''; position: absolute; top: 2px; left: 2px; right: 2px; bottom: 2px; border-radius: 50%; border: 1px dashed rgba(139, 0, 0, 0.3); }

        .move-dot { width: 16px; height: 16px; background: rgba(0, 255, 0, 0.6); border-radius: 50%; position: absolute; z-index: 20; pointer-events: none; box-shadow: 0 0 5px #fff; }

        #status-bar { display: flex; gap: 20px; align-items: center; margin-bottom: 5px; flex-wrap: wrap; }
        
        /* Timer Display */
        .timer-badge {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #555;
            border-radius: 8px;
            padding: 8px 15px;
            font-size: 1.1rem;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            color: #fff;
            min-width: 80px;
            text-align: center;
            transition: all 0.3s;
        }
        .timer-badge.active {
            border-color: #f1c40f;
            box-shadow: 0 0 10px rgba(241, 196, 15, 0.5);
            background: rgba(241, 196, 15, 0.1);
            color: #f1c40f;
        }
        .timer-badge.warning {
            border-color: #f39c12;
            color: #f39c12;
            animation: pulseTimer 1s ease-in-out infinite;
        }
        .timer-badge.danger {
            border-color: #e74c3c;
            color: #e74c3c;
            animation: pulseTimer 0.5s ease-in-out infinite;
        }
        @keyframes pulseTimer {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        .badge { padding: 5px 25px; border-radius: 15px; font-weight: bold; border: 2px solid #fff; width: 250px; text-align: center; font-size: 1.1rem; }
        .game-action-btn {
            padding: 8px 20px;
            border-radius: 8px;
            border: 2px solid;
            font-size: 0.95rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            white-space: nowrap;
        }
        .game-action-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .btn-resign {
            background: #e74c3c;
            color: white;
            border-color: #c0392b;
        }
        .btn-resign:hover {
            background: #c0392b;
        }
        .btn-draw {
            background: #f39c12;
            color: white;
            border-color: #e67e22;
        }
        .btn-draw:hover {
            background: #e67e22;
        }
        .game-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Chat Box Styles */
        #chat-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            max-height: 400px;
            background: rgba(34, 34, 34, 0.95);
            border: 2px solid #555;
            border-radius: 10px;
            display: none;
            flex-direction: column;
            z-index: 50;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }
        #chat-container.show {
            display: flex;
        }
        #chat-header {
            background: #2c3e50;
            padding: 10px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        #chat-header h3 {
            margin: 0;
            font-size: 1rem;
            color: #f1c40f;
        }
        #chat-toggle {
            background: none;
            border: none;
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0 5px;
        }
        #chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            max-height: 250px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .chat-message {
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.9rem;
            word-wrap: break-word;
            max-width: 85%;
        }
        .chat-message.own {
            background: #3498db;
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 2px;
        }
        .chat-message.other {
            background: #555;
            color: #fff;
            align-self: flex-start;
            border-bottom-left-radius: 2px;
        }
        .chat-message .sender {
            font-weight: bold;
            font-size: 0.8rem;
            margin-bottom: 3px;
            opacity: 0.9;
        }
        .chat-message .time {
            font-size: 0.7rem;
            opacity: 0.7;
            margin-top: 3px;
        }
        #chat-input-container {
            display: flex;
            gap: 5px;
            padding: 10px;
            border-top: 1px solid #555;
            position: relative;
        }
        #chat-input {
            flex: 1;
            padding: 8px;
            border: 1px solid #555;
            border-radius: 5px;
            background: #222;
            color: white;
            font-size: 0.9rem;
        }
        #chat-input:focus {
            outline: none;
            border-color: #3498db;
        }
        #chat-emoji-btn {
            padding: 8px 10px;
            background: #555;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #chat-emoji-btn:hover {
            background: #666;
        }
        #chat-send {
            padding: 8px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        #chat-send:hover {
            background: #2980b9;
        }
        #chat-send:disabled {
            background: #555;
            cursor: not-allowed;
        }
        /* Emoji Picker */
        #emoji-picker {
            position: absolute;
            bottom: 100%;
            right: 0;
            width: 280px;
            height: 300px;
            background: #2c3e50;
            border: 2px solid #555;
            border-radius: 10px;
            padding: 10px;
            display: none;
            flex-direction: column;
            z-index: 100;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.5);
            margin-bottom: 5px;
        }
        #emoji-picker.show {
            display: flex;
        }
        #emoji-picker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 8px;
            border-bottom: 1px solid #555;
            margin-bottom: 8px;
        }
        #emoji-picker-header h4 {
            margin: 0;
            font-size: 0.9rem;
            color: #f1c40f;
        }
        #emoji-picker-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0 5px;
        }
        #emoji-picker-body {
            flex: 1;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 5px;
            padding: 5px;
        }
        .emoji-item {
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            text-align: center;
            transition: background 0.2s;
            user-select: none;
        }
        .emoji-item:hover {
            background: rgba(255,255,255,0.1);
        }
        .emoji-item:active {
            transform: scale(0.9);
        }
        #chat-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #3498db;
            color: white;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
            z-index: 49;
            display: none;
        }
        #chat-button:hover {
            background: #2980b9;
            transform: scale(1.1);
        }
        #chat-button.show {
            display: block;
        }
        #chat-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #e74c3c;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
        }
        
        #start-screen, #game-over {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding: 40px 20px;
            overflow-y: auto;
        }
        #start-screen::-webkit-scrollbar,
        #game-over::-webkit-scrollbar {
            width: 8px;
        }
        #start-screen::-webkit-scrollbar-track,
        #game-over::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }
        #start-screen::-webkit-scrollbar-thumb,
        #game-over::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }
        #start-screen::-webkit-scrollbar-thumb:hover,
        #game-over::-webkit-scrollbar-thumb:hover {
            background: #666;
        }
        button.main-btn { padding: 10px 30px; font-size: 1.2rem; background: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 20px; }
        
        /* Online Multiplayer UI */
        .room-container { display: flex; flex-direction: column; gap: 15px; align-items: center; margin-top: 20px; }
        .room-input { padding: 10px 15px; font-size: 1rem; border-radius: 5px; border: 2px solid #555; background: #333; color: white; width: 250px; text-align: center; }
        .room-code { font-size: 2rem; font-weight: bold; color: var(--text-gold); letter-spacing: 5px; margin: 10px 0; }
        .player-info { 
            margin-top: 15px; 
            padding: 15px; 
            background: rgba(255,255,255,0.1); 
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 300px;
        }
        .player-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            border-radius: 6px;
            background: rgba(0,0,0,0.3);
        }
        .player-item.player1 {
            border-left: 4px solid #3498db;
        }
        .player-item.player2 {
            border-left: 4px solid #e74c3c;
        }
        .player-badge {
            font-weight: bold;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
        }
        .player-badge.player1 {
            background: #3498db;
            color: white;
        }
        .player-badge.player2 {
            background: #e74c3c;
            color: white;
        }
        .player-side {
            font-size: 0.9rem;
            color: #aaa;
        }
        .waiting-msg { color: #f1c40f; margin-top: 10px; }
        
        /* Coin Flip Animation */
        .coin-container {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        .coin {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(135deg, #f1c40f 0%, #f39c12 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            box-shadow: 0 10px 30px rgba(241, 196, 15, 0.5);
            cursor: pointer;
            transition: transform 0.3s;
            position: relative;
            overflow: hidden;
        }
        .coin.flipping {
            animation: coinFlip 2s ease-in-out;
        }
        @keyframes coinFlip {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(1800deg) scale(1.2); }
            100% { transform: rotateY(3600deg); }
        }
        .coin-side {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            backface-visibility: hidden;
        }
        .coin-heads { 
            background: linear-gradient(135deg, #f1c40f 0%, #f39c12 100%); 
        }
        .coin-tails { 
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%); 
            transform: rotateY(180deg);
            border: 3px solid #1a1a1a;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }
        /* M·∫∑t sau ƒë·ªìng xu - c√≥ pattern ƒë·∫∑c bi·ªát */
        .coin-tails::before {
            content: '‚óè';
            font-size: 2rem;
            color: rgba(255,255,255,0.2);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .coin-tails::after {
            content: '';
            position: absolute;
            width: 80%;
            height: 80%;
            top: 10%;
            left: 10%;
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.3);
        }
        
        /* Dice Animation */
        .dice-container {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        .dice {
            width: 80px;
            height: 80px;
            background: white;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: transform 0.3s;
        }
        .dice.rolling {
            animation: diceRoll 1.5s ease-in-out;
        }
        @keyframes diceRoll {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(90deg) scale(1.1); }
            50% { transform: rotate(180deg) scale(0.9); }
            75% { transform: rotate(270deg) scale(1.1); }
        }
        .result-display {
            margin-top: 15px;
            padding: 15px;
            background: rgba(241, 196, 15, 0.2);
            border-radius: 8px;
            border: 2px solid #f1c40f;
            font-size: 1.1rem;
            font-weight: bold;
            color: #f1c40f;
            text-align: center;
        }
        
        /* Network Mode Selection */
        .mode-selector { display: flex; gap: 15px; margin-bottom: 20px; }
        .mode-btn { 
            padding: 12px 25px; 
            font-size: 1rem; 
            background: #444; 
            color: white; 
            border: 2px solid #666; 
            border-radius: 8px; 
            cursor: pointer; 
            transition: all 0.3s;
            flex: 1;
        }
        .mode-btn:hover { background: #555; border-color: #888; }
        .mode-btn.active { 
            background: #e74c3c; 
            border-color: #c0392b; 
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.5);
        }
        .server-url-container { 
            margin-top: 15px; 
            display: none; 
            flex-direction: column; 
            gap: 10px; 
            align-items: center;
        }
        .server-url-container.show { display: flex; }
        .server-url-input { 
            padding: 10px 15px; 
            font-size: 0.9rem; 
            border-radius: 5px; 
            border: 2px solid #555; 
            background: #333; 
            color: white; 
            width: 100%; 
            max-width: 400px;
        }
        .server-url-input::placeholder { color: #888; }
        .local-info { 
            margin-top: 10px; 
            padding: 10px; 
            background: rgba(52, 152, 219, 0.2); 
            border-radius: 5px; 
            font-size: 0.85rem; 
            color: #3498db;
            text-align: center;
        }
        .local-info strong { color: #2980b9; }

    </style>
</head>
<body>

    <div id="start-screen">
        <button onclick="resetToMenu()" style="position: fixed; top: 20px; left: 20px; padding: 10px 20px; background: #555; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 0.9rem; z-index: 101;">
            üè† V·ªÅ Menu
        </button>
        <div style="text-align: center; margin-bottom: 30px;">
            <h1 style="color: var(--text-gold); margin-bottom: 10px; font-size: 2.5rem;">ƒê√îNG T√ÇY ƒê·∫†I CHI·∫æN</h1>
            <p style="color: #ccc; font-size: 1.1rem; margin-bottom: 20px;">Ch·ªçn ch·∫ø ƒë·ªô ch∆°i</p>
            <button class="rules-btn" onclick="showRules()">
                üìú Xem Lu·∫≠t Ch∆°i
            </button>
        </div>
        
        <!-- Game Mode Selection -->
        <div class="mode-selector" style="margin-bottom: 20px;">
            <button class="mode-btn" id="btn-online" onclick="selectGameMode('online')">
                üåê Ch∆°i Online
            </button>
            <button class="mode-btn" id="btn-bot" onclick="selectGameMode('bot')">
                ü§ñ Ch∆°i v·ªõi BOT
            </button>
        </div>
        
        <!-- Dice Section (for Bot Mode) -->
        <div id="dice-section" class="dice-container" style="display: none;">
            <h3 style="color: #f1c40f; margin-bottom: 15px;">üé≤ TUNG X√öC X·∫ÆC - QUY·∫æT ƒê·ªäNH AI ƒêI TR∆Ø·ªöC</h3>
            <div class="dice" id="dice">üé≤</div>
            <div id="dice-result" class="result-display" style="display: block;"></div>
        </div>
        
        <!-- Network Mode Selection (only for online) -->
        <div class="mode-selector" id="network-mode-selector" style="display: none;">
            <button class="mode-btn active" id="btn-local" onclick="selectMode('local')">
                üåê M·∫°ng LAN (Local)
            </button>
            <button class="mode-btn" id="btn-global" onclick="selectMode('global')">
                üåç Global (Online)
            </button>
        </div>
        
        <!-- Server URL Input (for Global mode) -->
        <div class="server-url-container" id="server-url-container">
            <input type="text" 
                   id="server-url-input" 
                   class="server-url-input" 
                   placeholder="Nh·∫≠p server URL (v√≠ d·ª•: https://your-server.com)"
                   value="">
            <div style="font-size: 0.85rem; color: #888; text-align: center;">
                ƒê·ªÉ tr·ªëng ƒë·ªÉ d√πng server m·∫∑c ƒë·ªãnh
            </div>
        </div>
        
        <!-- Local Network Info -->
        <div class="local-info" id="local-info" style="display: none;">
            <strong>üåê M·∫°ng LAN:</strong> Ch∆°i v·ªõi ng∆∞·ªùi c√πng WiFi<br>
            <strong>Server URL:</strong> <span id="local-server-url" style="color: #f1c40f; font-weight: bold;">ƒêang t·∫£i...</span><br>
            <div style="margin-top: 8px; font-size: 0.85rem; color: #aaa;">
                Ng∆∞·ªùi ch∆°i kh√°c v√†o URL n√†y tr√™n ƒëi·ªán tho·∫°i/m√°y t√≠nh c√πng WiFi
            </div>
        </div>
        
        <!-- Online Mode Menu -->
        <div class="room-container" id="room-menu" style="display: none;">
            <button class="main-btn" onclick="createRoom()">T·∫°o Ph√≤ng M·ªõi</button>
            <div style="margin: 20px 0; color: #888;">HO·∫∂C</div>
            <input type="text" id="room-code-input" class="room-input" placeholder="Nh·∫≠p m√£ ph√≤ng" maxlength="6">
            <button class="main-btn" onclick="joinRoom()">Tham Gia Ph√≤ng</button>
        </div>
        
        <!-- Bot Mode Menu -->
        <div class="room-container" id="bot-menu" style="display: none;">
            <div style="margin-bottom: 20px;">
                <h3 style="color: #f1c40f; margin-bottom: 15px;">Ch·ªçn b√™n c·ªßa b·∫°n:</h3>
                <div class="mode-selector">
                    <button class="mode-btn active" id="btn-choose-chess" onclick="selectBotSide('chess')">
                        üè∞ C·ªù Vua (Tr·∫Øng)
                    </button>
                    <button class="mode-btn" id="btn-choose-xiangqi" onclick="selectBotSide('xiangqi')">
                        ‚õ©Ô∏è C·ªù T∆∞·ªõng (ƒê·ªè)
                    </button>
                </div>
            </div>
            <div style="margin: 20px 0;">
                <div style="color: var(--text-gold); font-size: 1rem; margin-bottom: 10px; text-align: center;">
                    üéØ Ch·ªçn ƒê·ªô Kh√≥ Bot:
                </div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="mode-btn" id="btn-difficulty-easy" onclick="selectBotDifficulty('easy')" style="flex: 1;">
                        üòä D·ªÖ
                    </button>
                    <button class="mode-btn" id="btn-difficulty-medium" onclick="selectBotDifficulty('medium')" style="flex: 1;">
                        üòê Trung B√¨nh
                    </button>
                    <button class="mode-btn" id="btn-difficulty-hard" onclick="selectBotDifficulty('hard')" style="flex: 1;">
                        üò§ Kh√≥
                    </button>
                </div>
            </div>
            <button class="main-btn" onclick="startBotGame()" style="font-size: 1.3rem; padding: 15px 40px;">
                ü§ñ B·∫Øt ƒê·∫ßu Ch∆°i V·ªõi BOT
            </button>
        </div>
        
        <div id="room-info" style="display: none;">
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 10px;">
                <div class="room-code" id="room-code-display">ABC123</div>
                <button id="copy-room-code" onclick="copyRoomCode()" style="padding: 10px 20px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 0.9rem;" title="Copy m√£ ph√≤ng">
                    üìã Copy
                </button>
            </div>
            <div id="copy-success-msg" style="display: none; color: #2ecc71; text-align: center; margin-bottom: 10px; font-size: 0.9rem;">
                ‚úì ƒê√£ copy m√£ ph√≤ng!
            </div>
            
            <!-- Player Info -->
            <div class="player-info">
                <div class="player-item player1">
                    <div>
                        <span class="player-badge player1">PLAYER 1</span>
                        <span id="player1-name" style="margin-left: 10px;">B·∫°n</span>
                    </div>
                    <div class="player-side" id="player1-side">-</div>
                </div>
                <div class="player-item player2">
                    <div>
                        <span class="player-badge player2">PLAYER 2</span>
                        <span id="player2-name" style="margin-left: 10px;">ƒêang ch·ªù...</span>
                    </div>
                    <div class="player-side" id="player2-side">-</div>
                </div>
            </div>
            
            <!-- Waiting Message -->
            <div id="waiting-msg" class="waiting-msg">ƒêang ch·ªù ng∆∞·ªùi ch∆°i th·ª© 2...</div>
            
            <!-- Coin Flip Section (Choose Side) -->
            <div id="coin-flip-section" class="coin-container" style="display: none;">
                <div style="font-size: 1.2rem; color: #f1c40f; font-weight: bold; margin-bottom: 10px;">
                    ü™ô TUNG ƒê·ªíNG XU - CH·ªåN B√äN
                </div>
                <div style="font-size: 0.9rem; color: #aaa; margin-bottom: 15px; text-align: center;">
                    <span id="coin-flip-instruction">Player 1 click v√†o ƒë·ªìng xu ƒë·ªÉ tung</span>
                </div>
                <div class="coin" id="coin">
                    <div class="coin-side coin-heads">‚ôö</div>
                    <div class="coin-side coin-tails"></div>
                </div>
                <div id="coin-result" class="result-display" style="display: none;"></div>
                <!-- Player 1 choice buttons (only shown to Player 1 after coin flip) -->
                <div id="player1-choice" style="display: none; margin-top: 20px;">
                    <div id="player1-choice-text" style="font-size: 1rem; color: #f1c40f; margin-bottom: 10px; text-align: center;">
                        Ch·ªçn b√™n b·∫°n mu·ªën ch∆°i:
                    </div>
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button class="main-btn" onclick="chooseSide('chess')" style="background: #3498db;">
                            üè∞ Ch∆°i C·ªù Vua (Tr·∫Øng)
                        </button>
                        <button class="main-btn" onclick="chooseSide('xiangqi')" style="background: #e74c3c;">
                            ‚õ©Ô∏è Ch∆°i C·ªù T∆∞·ªõng (ƒê·ªè)
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Dice Section (Choose First Turn) -->
            <div id="dice-section" class="dice-container" style="display: none;">
                <div style="font-size: 1.2rem; color: #f1c40f; font-weight: bold; margin-bottom: 10px;">
                    üé≤ TUNG X√öC X·∫ÆC - CH·ªåN NG∆Ø·ªúI ƒêI TR∆Ø·ªöC
                </div>
                <div style="font-size: 0.9rem; color: #aaa; margin-bottom: 15px; text-align: center;">
                    C·∫£ 2 ng∆∞·ªùi ch∆°i ƒë·ªÅu tung x√∫c x·∫Øc. Ai c√≥ t·ªïng cao h∆°n s·∫Ω ƒëi tr∆∞·ªõc!
                </div>
                <div class="dice" id="dice" onclick="rollDice()">üé≤</div>
                <div id="dice-result-text" class="result-display" style="display: none;"></div>
            </div>
        </div>
    </div>

    <div id="game-over" style="display: none;">
        <h1 id="winner-text" style="color: var(--text-gold);">WINNER</h1>
        <div style="display: flex; gap: 15px; flex-wrap: wrap; justify-content: center;">
            <button class="main-btn" onclick="resetToMenu()" style="background: #3498db;">
                üè† V·ªÅ Menu Ch√≠nh
            </button>
            <button class="main-btn" onclick="playAgain()">
                üîÑ Ch∆°i L·∫°i
            </button>
        </div>
    </div>

    <div id="status-bar">
        <div id="turn-badge" class="badge">...</div>
        <div id="timer-display" style="display: flex; gap: 15px; align-items: center; margin-left: 15px;">
            <div id="chess-timer" class="timer-badge" style="display: none;">
                <span style="font-size: 0.85rem; color: #888; margin-right: 5px;">üè∞</span>
                <span id="chess-timer-text">10:00</span>
            </div>
            <div id="xiangqi-timer" class="timer-badge" style="display: none;">
                <span style="font-size: 0.85rem; color: #888; margin-right: 5px;">‚õ©Ô∏è</span>
                <span id="xiangqi-timer-text">10:00</span>
            </div>
        </div>
        <div id="message" style="color: red; font-weight: bold;"></div>
        <div id="keyboard-hints" style="display: flex; gap: 8px; margin-left: 10px; font-size: 0.75rem; color: #888; align-items: center;">
            <span title="ƒêi l·∫°i (ch·ªâ trong ch·∫ø ƒë·ªô bot)">‚å®Ô∏è Z: ƒêi l·∫°i</span>
            <span title="Reset game">R: Reset</span>
            <span title="ƒê·∫ßu h√†ng">S: ƒê·∫ßu h√†ng</span>
            <span title="Xin h√≤a">D: Xin h√≤a</span>
        </div>
        <div style="display: flex; gap: 10px; margin-left: auto;">
            <button id="btn-resign" class="game-action-btn btn-resign" onclick="resignGame()" title="ƒê·∫ßu h√†ng (S)">
                üè≥Ô∏è ƒê·∫ßu H√†ng
            </button>
            <button id="btn-draw" class="game-action-btn btn-draw" onclick="offerDraw()" title="Xin h√≤a (D)">
                ü§ù Xin H√≤a
            </button>
        </div>
    </div>
    
    <!-- Chat Button -->
    <button id="chat-button" onclick="toggleChat()" title="M·ªü Chat">üí¨</button>
    
    <!-- Chat Container -->
    <div id="chat-container">
        <div id="chat-header" onclick="toggleChat()">
            <h3>üí¨ Chat</h3>
            <button id="chat-toggle">‚àí</button>
        </div>
        <div id="chat-messages"></div>
        <div id="chat-input-container">
            <input type="text" id="chat-input" placeholder="Nh·∫≠p tin nh·∫Øn..." maxlength="200" onkeypress="handleChatKeyPress(event)">
            <button id="chat-emoji-btn" onclick="toggleEmojiPicker()" title="Ch·ªçn emoji">üòÄ</button>
            <button id="chat-send" onclick="sendChatMessage()">G·ª≠i</button>
            
            <!-- Emoji Picker -->
            <div id="emoji-picker">
                <div id="emoji-picker-header">
                    <h4>üòÄ Ch·ªçn Emoji</h4>
                    <button id="emoji-picker-close" onclick="toggleEmojiPicker()">√ó</button>
                </div>
                <div id="emoji-picker-body"></div>
            </div>
        </div>
    </div>

    <div class="game-wrapper">
        
        <div id="graveyard-bar">
            <div class="grave-row" id="grave-top">
                <div class="grave-label">Qu√¢n Tr·∫Øng<br>B·ªã B·∫Øt</div>
                </div>
            <div class="grave-row" id="grave-bot">
                <div class="grave-label">Qu√¢n ƒê·ªè<br>B·ªã B·∫Øt</div>
                </div>
        </div>

        <div id="board-container">
            <div id="board"></div>
            
            <div id="promotion-modal">
                <h3>PHONG C·∫§P!</h3>
                <div class="promo-options">
                    <button class="promo-btn" onclick="promotePawn('queen')" title="H·∫≠u">‚ôõ</button>
                    <button class="promo-btn" onclick="promotePawn('rook')" title="Xe">‚ôú</button>
                    <button class="promo-btn" onclick="promotePawn('bishop')" title="T∆∞·ª£ng">‚ôù</button>
                    <button class="promo-btn" onclick="promotePawn('knight')" title="M√£">‚ôû</button>
                </div>
            </div>
            
            <!-- Special Tile Activation Modal -->
            <div id="special-activation-modal">
                <div class="activation-modal-content">
                    <h2 id="activation-title">√î Ch·ª©c NƒÉng ƒê√£ ƒê∆∞·ª£c K√≠ch Ho·∫°t!</h2>
                    <div class="icon" id="activation-icon">‚ö°</div>
                    <div class="description" id="activation-description"></div>
                    <div class="effect-detail" id="activation-effect"></div>
                    <button onclick="closeActivationModal()">ƒê√£ Hi·ªÉu</button>
                </div>
            </div>
        </div>
    </div>

    <div id="control-bar">
        <button class="ctrl-btn" id="btn-prev" onclick="reviewMove(-1)" title="L√πi l·∫°i"><i class="fa-solid fa-backward"></i></button>
        <button class="ctrl-btn" id="btn-next" onclick="reviewMove(1)" title="Ti·∫øn t·ªõi"><i class="fa-solid fa-forward"></i></button>
        <button class="ctrl-btn active-live" id="btn-live" onclick="returnToLive()" title="V·ªÅ tr·∫≠n ƒë·∫•u hi·ªán t·∫°i">LIVE</button>
    </div>

    <!-- Rules Modal -->
    <div id="rules-modal">
        <div id="rules-container">
            <button class="close-rules-btn" onclick="closeRules()" title="ƒê√≥ng">√ó</button>
            <h2 class="rules-title">üìú LU·∫¨T CH∆†I CHI TI·∫æT</h2>
            <div class="rules-grid">
                <div class="rule-box">
                    <h3>üè∞ Phe C·ªù Vua (Tr·∫Øng)</h3>
                    <ul>
                        <li><strong>Lu·∫≠t di chuy·ªÉn:</strong> Tu√¢n theo lu·∫≠t C·ªù Vua qu·ªëc t·∫ø.</li>
                        <li><strong>Phong c·∫•p T·ªët:</strong> T·ªët khi ƒëi ƒë·∫øn h√†ng cu·ªëi c√πng (h√†ng ƒë√°y b√™n phe ƒë·ªè) ƒë∆∞·ª£c ph√©p phong c·∫•p th√†nh: H·∫≠u, Xe, T∆∞·ª£ng ho·∫∑c M√£.</li>
                        <li><strong>ƒê·∫∑c quy·ªÅn:</strong> Qu√¢n C·ªù Vua kh√¥ng b·ªã gi·ªõi h·∫°n b·ªüi S√¥ng hay Cung T∆∞·ªõng.</li>
                        <li><strong>Nh·∫≠p th√†nh:</strong> ƒê∆∞·ª£c ph√©p n·∫øu Vua v√† Xe ch∆∞a di chuy·ªÉn v√† ƒë∆∞·ªùng ƒëi tho√°ng.</li>
                    </ul>
                </div>
                <div class="rule-box">
                    <h3>‚õ©Ô∏è Phe C·ªù T∆∞·ªõng (ƒê·ªè)</h3>
                    <ul>
                        <li><strong>Lu·∫≠t di chuy·ªÉn:</strong> Tu√¢n theo lu·∫≠t C·ªù T∆∞·ªõng c∆° b·∫£n.</li>
                        <li><strong>T·ªët:</strong> Qua s√¥ng ƒë∆∞·ª£c ph√©p ƒëi ngang v√† th·∫≥ng (m·ªói l·∫ßn 1 √¥).</li>
                        <li><strong>H·∫°n ch·∫ø:</strong> T∆∞·ªõng v√† Sƒ© kh√¥ng ƒë∆∞·ª£c ra kh·ªèi Cung (√¥ vu√¥ng 3x3). T∆∞·ª£ng kh√¥ng ƒë∆∞·ª£c ƒëi qua s√¥ng.</li>
                        <li><strong>C·∫£n ch√¢n:</strong> M√£ v√† T∆∞·ª£ng tu√¢n th·ªß lu·∫≠t c·∫£n ch√¢n nh∆∞ b√¨nh th∆∞·ªùng.</li>
                    </ul>
                </div>
                <div class="rule-box full-width">
                    <h3>‚öîÔ∏è Quy T·∫Øc Chung & Th·∫Øng Thua</h3>
                    <ul>
                        <li><strong>M·ª•c ti√™u:</strong> Chi·∫øu b√≠ T∆∞·ªõng (C·ªù T∆∞·ªõng) ho·∫∑c Vua (C·ªù Vua).</li>
                        <li><strong>üõ°Ô∏è Khi√™n c·ªßa T·ªët C·ªù Vua:</strong> T·ªët c·ªù vua khi ch∆∞a di chuy·ªÉn c√≥ khi√™n (üõ°Ô∏è). Ph√°o c·ªù t∆∞·ªõng kh√¥ng th·ªÉ b·∫Øc c·∫ßu qua t·ªët c√≥ khi√™n. Khi t·ªët di chuy·ªÉn, khi√™n s·∫Ω m·∫•t v√† ph√°o c√≥ th·ªÉ b·∫Øc c·∫ßu ƒë∆∞·ª£c.</li>
                        <li><strong>M√£ C·ªù T∆∞·ªõng:</strong> M√£ c·ªù t∆∞·ªõng kh√¥ng b·ªã ch·∫∑n b·ªüi t·ªët c·ªù vua khi ƒëi ch·ªØ L.</li>
                        <li><strong>En Passant:</strong> T·ªët c·ªù vua c√≥ th·ªÉ ƒÉn t·ªët ƒë·ªëi ph∆∞∆°ng ƒëi 2 √¥ ngang qua m·∫∑t m√¨nh.</li>
                        <li><strong>L·∫∑p l·∫°i n∆∞·ªõc ƒëi:</strong> N·∫øu c√πng m·ªôt tr·∫°ng th√°i b√†n c·ªù xu·∫•t hi·ªán 4 l·∫ßn, game s·∫Ω t·ª± ƒë·ªông h√≤a c·ªù.</li>
                        <li><strong>√î ƒë·∫∑c bi·ªát:xu·∫•t hi·ªán t·∫°i v·ªã tr√≠ I10 ,ch·ª©c nƒÉng ban kh·∫£ nƒÉng kh√¥ng b·ªã gi·ªõi h·∫°n kh·ªèi th√†nh khi 1 qu√¢n b·∫•t k√¨ b√™n t∆∞·ªõng ch·∫°m v√†o ,ban kh·∫£ nƒÉng d·ªãch chuy·ªÉn c·ªßa vua sang v·ªã tr√≠ A10, ch·ª©c nƒÉng ch·ªâ k√≠ch ho·∫°t 1 l·∫ßn cho m·ªói b√™n , khi h·∫øt t√°c d·ª•ng √¥ s·∫Ω m·∫•t ch·ª©c nƒÉng</strong></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

<script>
    // ========== RULES MODAL FUNCTIONS ==========
    function showRules() {
        const rulesModal = document.getElementById('rules-modal');
        if (rulesModal) {
            rulesModal.classList.add('show');
            document.body.style.overflow = 'hidden'; // NgƒÉn scroll body khi modal m·ªü
        }
    }
    
    function closeRules() {
        const rulesModal = document.getElementById('rules-modal');
        if (rulesModal) {
            rulesModal.classList.remove('show');
            document.body.style.overflow = ''; // Kh√¥i ph·ª•c scroll body
        }
    }
    
    // ƒê√≥ng modal khi click b√™n ngo√†i
    document.addEventListener('click', function(event) {
        const rulesModal = document.getElementById('rules-modal');
        const rulesContainer = document.getElementById('rules-container');
        if (rulesModal && rulesContainer && event.target === rulesModal) {
            closeRules();
        }
    });
    
    // ƒê√≥ng modal b·∫±ng ph√≠m ESC
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            const rulesModal = document.getElementById('rules-modal');
            if (rulesModal && rulesModal.classList.contains('show')) {
                closeRules();
            }
        }
    });
    
    // ========== NETWORK MODE CONFIGURATION ==========
    let networkMode = 'local'; // 'local' or 'global'
    let socket = null;
    let currentServerURL = window.location.origin;
    
    // ========== MULTIPLAYER STATE ==========
    let gameRoomId = null;
    let playerId = null;
    let playerSide = null; // "chess" ho·∫∑c "xiangqi"
    let isHost = false;
    let isOnlineGame = false;
    
    // ========== GAME MODE SELECTION ==========
    function selectGameMode(mode) {
        // Reset UI
        document.querySelectorAll('.mode-btn').forEach(btn => {
            // Ch·ªâ reset c√°c n√∫t ch·∫ø ƒë·ªô ch∆°i, kh√¥ng reset n√∫t ch·ªçn b√™n
            if (btn.id === 'btn-online' || btn.id === 'btn-bot') {
                btn.classList.remove('active');
            }
        });
        
        if (mode === 'online') {
            document.getElementById('btn-online').classList.add('active');
            document.getElementById('network-mode-selector').style.display = 'flex';
            document.getElementById('room-menu').style.display = 'flex';
            document.getElementById('bot-menu').style.display = 'none';
            document.getElementById('server-url-container').style.display = 'block';
            isBotMode = false;
        } else if (mode === 'bot') {
            document.getElementById('btn-bot').classList.add('active');
            document.getElementById('network-mode-selector').style.display = 'none';
            document.getElementById('room-menu').style.display = 'none';
            document.getElementById('bot-menu').style.display = 'flex';
            document.getElementById('server-url-container').style.display = 'none';
            document.getElementById('local-info').style.display = 'none';
            isBotMode = true;
        }
    }
    
    // ========== BOT SIDE SELECTION ==========
    function selectBotSide(side) {
        document.getElementById('btn-choose-chess').classList.toggle('active', side === 'chess');
        document.getElementById('btn-choose-xiangqi').classList.toggle('active', side === 'xiangqi');
        playerSide = side;
        botSide = side === 'chess' ? 'xiangqi' : 'chess';
    }
    
    // ========== BOT DIFFICULTY SELECTION ==========
    function selectBotDifficulty(difficulty) {
        botDifficulty = difficulty;
        const btnEasy = document.getElementById('btn-difficulty-easy');
        const btnMedium = document.getElementById('btn-difficulty-medium');
        const btnHard = document.getElementById('btn-difficulty-hard');
        
        if (btnEasy && btnMedium && btnHard) {
            btnEasy.classList.remove('active');
            btnMedium.classList.remove('active');
            btnHard.classList.remove('active');
            
            if (difficulty === 'easy') btnEasy.classList.add('active');
            else if (difficulty === 'medium') btnMedium.classList.add('active');
            else if (difficulty === 'hard') btnHard.classList.add('active');
        }
    }
    
    // ========== MODE SELECTION ==========
    function selectMode(mode) {
        networkMode = mode;
        
        // Update UI
        document.getElementById('btn-local').classList.toggle('active', mode === 'local');
        document.getElementById('btn-global').classList.toggle('active', mode === 'global');
        document.getElementById('server-url-container').classList.toggle('show', mode === 'global');
        document.getElementById('local-info').style.display = mode === 'local' ? 'block' : 'none';
        
        // Update server URL
        if (mode === 'local') {
            currentServerURL = window.location.origin;
            // Show local info immediately
            const localInfo = document.getElementById('local-info');
            if (localInfo) {
                localInfo.style.display = 'block';
            }
            // Update IP info
            updateLocalServerInfo();
        } else {
            const urlInput = document.getElementById('server-url-input').value.trim();
            currentServerURL = urlInput || window.location.origin;
            // Hide local info
            const localInfo = document.getElementById('local-info');
            if (localInfo) {
                localInfo.style.display = 'none';
            }
        }
        
        // Reconnect socket if already connected
        if (socket && socket.connected) {
            socket.disconnect();
            connectToServer();
        }
    }
    
    function updateLocalServerInfo() {
        const urlElement = document.getElementById('local-server-url');
        if (!urlElement) return;
        
        // Try to get local IP from server
        fetch(`${currentServerURL}/api/ip`)
            .then(res => res.json())
            .then(data => {
                if (data.ip && data.ip !== 'localhost' && data.ip !== '127.0.0.1') {
                    urlElement.textContent = `http://${data.ip}:3000`;
                    urlElement.style.color = '#f1c40f';
                } else {
                    // Fallback: try to get IP from WebRTC
                    getLocalIP().then(ip => {
                        if (ip) {
                            urlElement.textContent = `http://${ip}:3000`;
                            urlElement.style.color = '#f1c40f';
                        } else {
                            urlElement.textContent = 'http://localhost:3000';
                            urlElement.style.color = '#e74c3c';
                            urlElement.title = 'Kh√¥ng th·ªÉ l·∫•y IP t·ª± ƒë·ªông. H√£y ki·ªÉm tra IP b·∫±ng l·ªánh ipconfig';
                        }
                    });
                }
            })
            .catch(() => {
                // Fallback: try WebRTC method
                getLocalIP().then(ip => {
                    if (ip) {
                        urlElement.textContent = `http://${ip}:3000`;
                        urlElement.style.color = '#f1c40f';
                    } else {
                        urlElement.textContent = 'http://localhost:3000';
                        urlElement.style.color = '#e74c3c';
                        urlElement.title = 'Kh√¥ng th·ªÉ l·∫•y IP t·ª± ƒë·ªông. Ch·∫°y ipconfig ƒë·ªÉ l·∫•y IP';
                    }
                });
            });
    }
    
    // Get local IP using WebRTC (fallback method)
    function getLocalIP() {
        return new Promise((resolve) => {
            const RTCPeerConnection = window.RTCPeerConnection || 
                                     window.mozRTCPeerConnection || 
                                     window.webkitRTCPeerConnection;
            
            if (!RTCPeerConnection) {
                resolve(null);
                return;
            }
            
            const pc = new RTCPeerConnection({
                iceServers: []
            });
            
            pc.createDataChannel('');
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    const candidate = event.candidate.candidate;
                    const match = candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
                    if (match) {
                        const ip = match[1];
                        // Filter out localhost and invalid IPs
                        if (ip && !ip.startsWith('127.') && !ip.startsWith('169.254.')) {
                            pc.close();
                            resolve(ip);
                            return;
                        }
                    }
                }
            };
            
            pc.createOffer()
                .then(offer => pc.setLocalDescription(offer))
                .catch(() => resolve(null));
            
            // Timeout after 2 seconds
            setTimeout(() => {
                pc.close();
                resolve(null);
            }, 2000);
        });
    }
    
    function connectToServer() {
        if (socket) {
            socket.disconnect();
        }
        
        socket = io(currentServerURL, {
            reconnection: true,
            reconnectionDelay: 2000, // TƒÉng delay cho m·∫°ng y·∫øu
            reconnectionAttempts: 10, // TƒÉng s·ªë l·∫ßn th·ª≠ l·∫°i
            reconnectionDelayMax: 10000, // Delay t·ªëi ƒëa 10 gi√¢y
            timeout: 20000, // Timeout 20 gi√¢y cho m·∫°ng y·∫øu
            transports: ['websocket', 'polling'], // Th·ª≠ websocket tr∆∞·ªõc, fallback polling
            upgrade: true,
            rememberUpgrade: false
        });
        
        setupSocketEvents();
    }
    
    function setupSocketEvents() {
    
        // Socket.io event handlers
        socket.on('connect', () => {
            console.log('Connected to server:', socket.id, 'at', currentServerURL);
            if (msgEl) {
                msgEl.innerText = 'ƒê√£ k·∫øt n·ªëi ƒë·∫øn server';
                msgEl.style.color = '#2ecc71';
                setTimeout(() => {
                    if (msgEl) {
                        msgEl.innerText = '';
                        msgEl.style.color = '';
                    }
                }, 2000);
            }
        });
        
        socket.on('disconnect', (reason) => {
            console.log('Disconnected from server:', reason);
            if (isOnlineGame && msgEl) {
                msgEl.innerText = 'M·∫•t k·∫øt n·ªëi v·ªõi server! ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i...';
                msgEl.style.color = '#e74c3c';
            }
        });
        
        socket.on('reconnect', (attemptNumber) => {
            console.log('Reconnected after', attemptNumber, 'attempts');
            if (msgEl) {
                msgEl.innerText = 'ƒê√£ k·∫øt n·ªëi l·∫°i th√†nh c√¥ng!';
                msgEl.style.color = '#2ecc71';
                setTimeout(() => {
                    if (msgEl) {
                        msgEl.innerText = '';
                        msgEl.style.color = '';
                    }
                }, 2000);
            }
        });
        
        socket.on('reconnect_attempt', (attemptNumber) => {
            console.log('Reconnection attempt', attemptNumber);
            if (msgEl) {
                msgEl.innerText = `ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i... (L·∫ßn ${attemptNumber})`;
                msgEl.style.color = '#f39c12';
            }
        });
        
        socket.on('reconnect_failed', () => {
            console.error('Reconnection failed');
            if (msgEl) {
                msgEl.innerText = 'Kh√¥ng th·ªÉ k·∫øt n·ªëi l·∫°i! Vui l√≤ng refresh trang.';
                msgEl.style.color = '#e74c3c';
            }
        });
        
        socket.on('connect_error', (error) => {
            console.error('Connection error:', error);
            if (msgEl) {
                msgEl.innerText = `Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server: ${currentServerURL}. ƒêang th·ª≠ l·∫°i...`;
                msgEl.style.color = '#e74c3c';
            }
        });
        
        socket.on('error', (data) => {
            console.error('Socket error:', data);
            const errorMsg = data.message || 'C√≥ l·ªói x·∫£y ra!';
            
            // Hi·ªÉn th·ªã l·ªói trong UI thay v√¨ alert ƒë·ªÉ kh√¥ng l√†m gi√°n ƒëo·∫°n
            if (msgEl) {
                msgEl.innerText = errorMsg;
                msgEl.style.color = '#e74c3c';
                setTimeout(() => {
                    if (msgEl) {
                        msgEl.innerText = '';
                        msgEl.style.color = '';
                    }
                }, 5000);
            } else {
                alert(errorMsg);
            }
        });
    
        socket.on('roomCreated', ({ roomCode, playerId: pid }) => {
            gameRoomId = roomCode;
            playerId = pid;
            isHost = true;
            isOnlineGame = true; // Set online game mode khi v√†o ph√≤ng
            coinFlipped = false;
            diceRolled = false;
            
            console.log('Room created - isOnlineGame set to true', { roomCode, playerId: pid, isHost });
            
            document.getElementById('room-menu').style.display = 'none';
            document.getElementById('room-info').style.display = 'block';
            document.getElementById('room-code-display').textContent = roomCode;
            document.getElementById('player1-name').textContent = 'B·∫°n';
            document.getElementById('player1-side').textContent = '-';
            document.getElementById('player2-name').textContent = 'ƒêang ch·ªù...';
            document.getElementById('player2-side').textContent = '-';
        });
        
        socket.on('roomJoined', ({ roomCode, playerId: pid }) => {
            // Clear timeout n·∫øu c√≥
            if (joinRoomTimeout) {
                clearTimeout(joinRoomTimeout);
                joinRoomTimeout = null;
            }
            
            // Reset button
            if (joinRoomButton) {
                joinRoomButton.disabled = false;
                joinRoomButton.textContent = 'Tham Gia Ph√≤ng';
            }
            
            gameRoomId = roomCode;
            playerId = pid;
            isHost = false;
            isOnlineGame = true; // Set online game mode khi v√†o ph√≤ng
            coinFlipped = false;
            diceRolled = false;
            
            console.log('Room joined successfully:', { roomCode, playerId: pid, isHost });
            
            if (msgEl) {
                msgEl.innerText = 'ƒê√£ tham gia ph√≤ng th√†nh c√¥ng!';
                msgEl.style.color = '#2ecc71';
                setTimeout(() => {
                    if (msgEl) msgEl.innerText = '';
                }, 2000);
            }
            
            document.getElementById('room-menu').style.display = 'none';
            document.getElementById('room-info').style.display = 'block';
            document.getElementById('room-code-display').textContent = roomCode;
            document.getElementById('player2-name').textContent = 'B·∫°n';
            document.getElementById('player2-side').textContent = '-';
        });
        
        socket.on('playerJoined', ({ players: playersList }) => {
            playersList.forEach((p, idx) => {
                if (idx === 0) {
                    document.getElementById('player1-name').textContent = p.name || 'Ng∆∞·ªùi ch∆°i 1';
                    if (p.id === playerId) {
                        document.getElementById('player1-name').textContent += ' (B·∫°n)';
                    }
                } else if (idx === 1) {
                    document.getElementById('player2-name').textContent = p.name || 'Ng∆∞·ªùi ch∆°i 2';
                    if (p.id === playerId) {
                        document.getElementById('player2-name').textContent += ' (B·∫°n)';
                    }
                }
            });
        });
        
        socket.on('readyToChooseSides', ({ players: playersList }) => {
            console.log('readyToChooseSides received', playersList, { isOnlineGame, gameRoomId, isHost, playerId });
            
            // ƒê·∫£m b·∫£o isOnlineGame ƒë∆∞·ª£c set
            isOnlineGame = true;
            
            document.getElementById('waiting-msg').style.display = 'none';
            document.getElementById('coin-flip-section').style.display = 'block';
            document.getElementById('room-info').style.display = 'block';
            
            // Update player names
            playersList.forEach((p, idx) => {
                if (idx === 0) {
                    document.getElementById('player1-name').textContent = (p.id === playerId ? 'B·∫°n' : p.name) || 'Ng∆∞·ªùi ch∆°i 1';
                } else if (idx === 1) {
                    document.getElementById('player2-name').textContent = (p.id === playerId ? 'B·∫°n' : p.name) || 'Ng∆∞·ªùi ch∆°i 2';
                }
            });
            
            // Update coin flip instruction
            const coinInstruction = document.getElementById('coin-flip-instruction');
            const coinElement = document.getElementById('coin');
            
            if (isHost) {
                coinInstruction.textContent = 'B·∫°n (Player 1) click v√†o ƒë·ªìng xu ƒë·ªÉ tung';
                coinElement.style.cursor = 'pointer';
                coinElement.style.pointerEvents = 'auto';
                // ƒê·∫£m b·∫£o event listener ƒë∆∞·ª£c g·∫Øn
                coinElement.onclick = flipCoin;
                console.log('Player 1 - Coin flip enabled', { isOnlineGame, gameRoomId, isHost, playerId });
            } else {
                coinInstruction.textContent = 'ƒêang ch·ªù Player 1 tung ƒë·ªìng xu...';
                coinElement.style.cursor = 'not-allowed';
                coinElement.style.pointerEvents = 'none';
                coinElement.onclick = null;
                console.log('Player 2 - Coin flip disabled', { isOnlineGame, gameRoomId, isHost, playerId });
            }
        });
        
        socket.on('sidesAssigned', ({ players: playersList }) => {
            document.getElementById('coin-flip-section').style.display = 'none';
            document.getElementById('player1-choice').style.display = 'none';
            document.getElementById('dice-section').style.display = 'block';
            
            // Reset dice state ƒë·ªÉ c·∫£ 2 player ƒë·ªÅu c√≥ th·ªÉ tung
            diceRolled = false;
            
            // Update player sides
            playersList.forEach((p, idx) => {
                const sideText = p.side === 'chess' ? 'üè∞ C·ªù Vua (Tr·∫Øng)' : '‚õ©Ô∏è C·ªù T∆∞·ªõng (ƒê·ªè)';
                if (p.id === playerId) {
                    playerSide = p.side;
                }
                
                if (idx === 0) {
                    document.getElementById('player1-side').textContent = sideText;
                } else if (idx === 1) {
                    document.getElementById('player2-side').textContent = sideText;
                }
            });
            
            // ƒê·∫£m b·∫£o dice c√≥ th·ªÉ click ƒë∆∞·ª£c
            const dice = document.getElementById('dice');
            if (dice) {
                dice.style.pointerEvents = 'auto';
                dice.style.cursor = 'pointer';
                dice.onclick = rollDice;
            }
        });
        
        socket.on('gameStarted', ({ players: playersList, currentTurn, diceResults, firstTurnPlayer }) => {
            console.log('gameStarted event received:', { playersList, currentTurn, diceResults, firstTurnPlayer });
            
            // Hide dice section
            const diceSection = document.getElementById('dice-section');
            if (diceSection) {
                diceSection.style.display = 'none';
            }
            
            // Hide room info
            const roomInfo = document.getElementById('room-info');
            if (roomInfo) {
                roomInfo.style.display = 'none';
            }
            
            const myPlayer = playersList.find(p => p.id === playerId);
            if (myPlayer) {
                playerSide = myPlayer.side;
            }
            
            // Update final player info
            playersList.forEach((p, idx) => {
                const sideText = p.side === 'chess' ? 'üè∞ C·ªù Vua (Tr·∫Øng)' : '‚õ©Ô∏è C·ªù T∆∞·ªõng (ƒê·ªè)';
                const isMe = p.id === playerId;
                if (idx === 0) {
                    const player1Name = document.getElementById('player1-name');
                    const player1Side = document.getElementById('player1-side');
                    if (player1Name) player1Name.textContent = (isMe ? 'B·∫°n' : p.name) || 'Ng∆∞·ªùi ch∆°i 1';
                    if (player1Side) player1Side.textContent = sideText;
                } else if (idx === 1) {
                    const player2Name = document.getElementById('player2-name');
                    const player2Side = document.getElementById('player2-side');
                    if (player2Name) player2Name.textContent = (isMe ? 'B·∫°n' : p.name) || 'Ng∆∞·ªùi ch∆°i 2';
                    if (player2Side) player2Side.textContent = sideText;
                }
            });
            
            // Show who goes first with dice comparison
            if (firstTurnPlayer && diceResults) {
                const resultEl = document.getElementById('dice-result-text');
                if (resultEl) {
                    const firstTurnSide = currentTurn === 'chess' ? 'üè∞ C·ªù Vua' : '‚õ©Ô∏è C·ªù T∆∞·ªõng';
                    const player1Result = diceResults.player1?.diceResult || diceResults.player1?.diceResult || 0;
                    const player2Result = diceResults.player2?.diceResult || diceResults.player2?.diceResult || 0;
                    
                    // X√°c ƒë·ªãnh ai l√† player 1 v√† player 2
                    const myPlayer = playersList.find(p => p.id === playerId);
                    const isPlayer1 = myPlayer && playersList.indexOf(myPlayer) === 0;
                    const myResult = isPlayer1 ? player1Result : player2Result;
                    const otherResult = isPlayer1 ? player2Result : player1Result;
                    const otherPlayerName = isPlayer1 ? 'Player 2' : 'Player 1';
                    
                    // So s√°nh k·∫øt qu·∫£
                    let comparisonText = '';
                    if (myResult > otherResult) {
                        comparisonText = '<span style="color: #2ecc71; font-weight: bold;">‚úì B·∫°n th·∫Øng!</span>';
                    } else if (myResult < otherResult) {
                        comparisonText = '<span style="color: #e74c3c; font-weight: bold;">‚úó B·∫°n thua!</span>';
                    } else {
                        comparisonText = '<span style="color: #f39c12; font-weight: bold;">= H√≤a!</span>';
                    }
                    
                    resultEl.innerHTML = `<br><br>üé≤ <strong>B·∫°n</strong>: <strong>${myResult}</strong> | <strong>${otherPlayerName}</strong>: <strong>${otherResult}</strong><br>${comparisonText}<br><br>‚è≥ ƒêang so s√°nh k·∫øt qu·∫£...`;
                }
            }
            
            // Hi·ªÉn th·ªã chat khi game b·∫Øt ƒë·∫ßu
            const chatButton = document.getElementById('chat-button');
            const chatContainer = document.getElementById('chat-container');
            if (chatButton) chatButton.classList.add('show');
            if (chatContainer) chatContainer.classList.add('show');
            chatMinimized = false;
            
            console.log('Starting game with:', { currentTurn, playerSide, isOnlineGame, gameRoomId });
            
            // Delay 5 gi√¢y tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu game ƒë·ªÉ hi·ªÉn th·ªã k·∫øt qu·∫£ so x√∫c s·∫Øc
            setTimeout(() => {
                // C·∫≠p nh·∫≠t l·∫°i hi·ªÉn th·ªã k·∫øt qu·∫£ cu·ªëi c√πng
                if (firstTurnPlayer && diceResults) {
                    const resultEl = document.getElementById('dice-result-text');
                    if (resultEl) {
                        const firstTurnSide = currentTurn === 'chess' ? 'üè∞ C·ªù Vua' : '‚õ©Ô∏è C·ªù T∆∞·ªõng';
                        const player1Result = diceResults.player1?.diceResult || diceResults.player1?.diceResult || 0;
                        const player2Result = diceResults.player2?.diceResult || diceResults.player2?.diceResult || 0;
                        
                        const myPlayer = playersList.find(p => p.id === playerId);
                        const isPlayer1 = myPlayer && playersList.indexOf(myPlayer) === 0;
                        const myResult = isPlayer1 ? player1Result : player2Result;
                        const otherResult = isPlayer1 ? player2Result : player1Result;
                        const otherPlayerName = isPlayer1 ? 'Player 2' : 'Player 1';
                        
                        let comparisonText = '';
                        if (myResult > otherResult) {
                            comparisonText = '<span style="color: #2ecc71; font-weight: bold;">‚úì B·∫°n th·∫Øng!</span>';
                        } else if (myResult < otherResult) {
                            comparisonText = '<span style="color: #e74c3c; font-weight: bold;">‚úó B·∫°n thua!</span>';
                        } else {
                            comparisonText = '<span style="color: #f39c12; font-weight: bold;">= H√≤a!</span>';
                        }
                        
                        resultEl.innerHTML = `<br><br>üé≤ <strong>B·∫°n</strong>: <strong>${myResult}</strong> | <strong>${otherPlayerName}</strong>: <strong>${otherResult}</strong><br>${comparisonText}<br><br><strong>${firstTurnPlayer}</strong> ƒëi tr∆∞·ªõc (${firstTurnSide})`;
                    }
                }
                
                // Kh·ªüi t·∫°o game sau delay
                startOnlineGame(currentTurn);
            }, 5000);
        });
        
        socket.on('gameStateUpdated', ({ gameState }) => {
            // C·∫≠p nh·∫≠t game state t·ª´ server
            pieces = gameState.pieces || [];
            deadChess = gameState.deadChess || [];
            deadXQ = gameState.deadXQ || [];
            currentTurn = gameState.currentTurn || 'chess';
            isGameOver = gameState.isGameOver || false;
            lastMove = gameState.lastMove || null;
            
            drawBoard();
        });
        
        socket.on('gameOver', ({ winner }) => {
            isGameOver = true;
            const winnerText = document.getElementById('winner-text');
            if (winnerText) {
                winnerText.innerText = (winner === playerSide ? 'B·∫†N' : 'ƒê·ªêI TH·ª¶') + ' TH·∫ÆNG!';
            }
            const gameOverEl = document.getElementById('game-over');
            if (gameOverEl) {
                gameOverEl.style.display = 'flex';
            }
        });
        
        socket.on('playerLeft', ({ playerId: pid }) => {
            if (isOnlineGame && msgEl) {
                msgEl.innerText = 'ƒê·ªëi th·ªß ƒë√£ r·ªùi ph√≤ng!';
                setTimeout(() => {
                    location.reload();
                }, 3000);
            }
        });
        
        // Chat message received
        socket.on('chatMessage', ({ playerId: senderId, playerName, message, timestamp }) => {
            addChatMessage(senderId === playerId, playerName, message, timestamp);
        });
        
        // Resign event
        socket.on('playerResigned', ({ playerId: resignedPlayerId, playerName }) => {
            if (isGameOver) return;
            
            isGameOver = true;
            const winner = resignedPlayerId === playerId ? (playerSide === 'chess' ? 'xiangqi' : 'chess') : playerSide;
            const winnerText = document.getElementById('winner-text');
            if (winnerText) {
                winnerText.innerText = (winner === playerSide ? 'B·∫†N' : 'ƒê·ªêI TH·ª¶') + ' TH·∫ÆNG!\n(' + playerName + ' ƒë√£ ƒë·∫ßu h√†ng)';
            }
            const gameOverEl = document.getElementById('game-over');
            if (gameOverEl) {
                gameOverEl.style.display = 'flex';
            }
            if (msgEl) {
                msgEl.innerText = playerName + ' ƒë√£ ƒë·∫ßu h√†ng!';
                msgEl.style.color = '#e74c3c';
            }
        });
        
        // Draw offer events
        socket.on('drawOffered', ({ playerId: offererId, playerName }) => {
            if (offererId !== playerId && !isGameOver) {
                const accept = confirm(`${playerName} mu·ªën h√≤a c·ªù. B·∫°n c√≥ ƒë·ªìng √Ω kh√¥ng?`);
                if (accept) {
                    socket.emit('acceptDraw', { roomCode: gameRoomId });
                } else {
                    socket.emit('rejectDraw', { roomCode: gameRoomId });
                }
            }
        });
        
        socket.on('drawAccepted', ({ playerId: accepterId, playerName }) => {
            if (isGameOver) return;
            
            isGameOver = true;
            const winnerText = document.getElementById('winner-text');
            if (winnerText) {
                winnerText.innerText = 'H√íA C·ªú!';
            }
            const gameOverEl = document.getElementById('game-over');
            if (gameOverEl) {
                gameOverEl.style.display = 'flex';
            }
            if (msgEl) {
                msgEl.innerText = 'C·∫£ hai ng∆∞·ªùi ch∆°i ƒë√£ ƒë·ªìng √Ω h√≤a c·ªù!';
                msgEl.style.color = '#f39c12';
            }
        });
        
        socket.on('drawRejected', ({ playerId: rejecterId, playerName }) => {
            if (msgEl) {
                msgEl.innerText = playerName + ' ƒë√£ t·ª´ ch·ªëi h√≤a c·ªù.';
                msgEl.style.color = '#e74c3c';
                setTimeout(() => {
                    if (msgEl) msgEl.innerText = '';
                }, 3000);
            }
        });
    
    }
    
    // ========== CHAT FUNCTIONS ==========
    let chatUnreadCount = 0;
    let chatMinimized = false;
    
    function toggleChat() {
        const chatContainer = document.getElementById('chat-container');
        const chatButton = document.getElementById('chat-button');
        
        if (chatContainer.classList.contains('show')) {
            chatContainer.classList.remove('show');
            chatButton.classList.add('show');
            chatMinimized = true;
        } else {
            chatContainer.classList.add('show');
            chatButton.classList.remove('show');
            chatMinimized = false;
            chatUnreadCount = 0;
            updateChatBadge();
        }
    }
    
    function addChatMessage(isOwn, senderName, message, timestamp) {
        const chatMessages = document.getElementById('chat-messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-message ${isOwn ? 'own' : 'other'}`;
        
        const senderSpan = document.createElement('div');
        senderSpan.className = 'sender';
        senderSpan.textContent = isOwn ? 'B·∫°n' : senderName;
        
        const messageText = document.createElement('div');
        messageText.textContent = message;
        
        const timeSpan = document.createElement('div');
        timeSpan.className = 'time';
        const time = timestamp ? new Date(timestamp) : new Date();
        timeSpan.textContent = time.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });
        
        messageDiv.appendChild(senderSpan);
        messageDiv.appendChild(messageText);
        messageDiv.appendChild(timeSpan);
        
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        // N·∫øu chat ƒëang minimized, tƒÉng unread count
        if (chatMinimized && !isOwn) {
            chatUnreadCount++;
            updateChatBadge();
        }
    }
    
    function updateChatBadge() {
        const chatButton = document.getElementById('chat-button');
        let badge = document.getElementById('chat-badge');
        
        if (chatUnreadCount > 0) {
            if (!badge) {
                badge = document.createElement('div');
                badge.id = 'chat-badge';
                chatButton.appendChild(badge);
            }
            badge.textContent = chatUnreadCount > 9 ? '9+' : chatUnreadCount;
        } else {
            if (badge) {
                badge.remove();
            }
        }
    }
    
    function sendChatMessage() {
        const chatInput = document.getElementById('chat-input');
        const message = chatInput.value.trim();
        
        if (!message || !isOnlineGame || !gameRoomId) return;
        
        // G·ª≠i tin nh·∫Øn ƒë·∫øn server
        socket.emit('chatMessage', {
            roomCode: gameRoomId,
            message: message
        });
        
        // Clear input
        chatInput.value = '';
    }
    
    function handleChatKeyPress(event) {
        if (event.key === 'Enter') {
            sendChatMessage();
        }
    }
    
    // Emoji Picker Functions
    const emojiList = [
        'üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'üòÇ', 'ü§£',
        'üòä', 'üòá', 'üôÇ', 'üôÉ', 'üòâ', 'üòå', 'üòç', 'ü•∞',
        'üòò', 'üòó', 'üòô', 'üòö', 'üòã', 'üòõ', 'üòù', 'üòú',
        'ü§™', 'ü§®', 'üßê', 'ü§ì', 'üòé', 'ü§©', 'ü•≥', 'üòè',
        'üòí', 'üòû', 'üòî', 'üòü', 'üòï', 'üôÅ', '‚òπÔ∏è', 'üò£',
        'üòñ', 'üò´', 'üò©', 'ü•∫', 'üò¢', 'üò≠', 'üò§', 'üò†',
        'üò°', 'ü§¨', 'ü§Ø', 'üò≥', 'ü•µ', 'ü•∂', 'üò±', 'üò®',
        'üò∞', 'üò•', 'üòì', 'ü§ó', 'ü§î', 'ü§≠', 'ü§´', 'ü§•',
        'üò∂', 'üòê', 'üòë', 'üò¨', 'üôÑ', 'üòØ', 'üò¶', 'üòß',
        'üòÆ', 'üò≤', 'ü•±', 'üò¥', 'ü§§', 'üò™', 'üòµ', 'ü§ê',
        'üëç', 'üëé', 'üëå', '‚úåÔ∏è', 'ü§û', 'ü§ü', 'ü§ò', 'ü§ô',
        'üëè', 'üôå', 'üëê', 'ü§≤', 'ü§ù', 'üôè', '‚úçÔ∏è', 'üí™',
        '‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'üñ§', 'ü§ç',
        'üíî', '‚ù£Ô∏è', 'üíï', 'üíû', 'üíì', 'üíó', 'üíñ', 'üíò',
        'üíù', 'üíü', '‚òÆÔ∏è', '‚úùÔ∏è', '‚ò™Ô∏è', 'üïâ', '‚ò∏Ô∏è', '‚ú°Ô∏è',
        'üîØ', 'üïé', '‚òØÔ∏è', '‚ò¶Ô∏è', 'üõê', '‚õé', '‚ôà', '‚ôâ',
        '‚ôä', '‚ôã', '‚ôå', '‚ôç', '‚ôé', '‚ôè', '‚ôê', '‚ôë',
        '‚ôí', '‚ôì', 'üÜî', '‚öõÔ∏è', 'üâë', '‚ò¢Ô∏è', '‚ò£Ô∏è', 'üì¥',
        'üì≥', 'üà∂', 'üàö', 'üà∏', 'üà∫', 'üà∑Ô∏è', '‚ú¥Ô∏è', 'üÜö',
        'üíÆ', 'üâê', '„äôÔ∏è', '„äóÔ∏è', 'üà¥', 'üàµ', 'üàπ', 'üà≤',
        'üÖ∞Ô∏è', 'üÖ±Ô∏è', 'üÜé', 'üÜë', 'üÖæÔ∏è', 'üÜò', '‚ùå', '‚≠ï',
        'üõë', '‚õî', 'üìõ', 'üö´', 'üíØ', 'üí¢', '‚ô®Ô∏è', 'üö∑',
        'üöØ', 'üö≥', 'üö±', 'üîû', 'üìµ', 'üö≠', '‚ùó', '‚ùì',
        '‚ùï', '‚ùî', '‚ÄºÔ∏è', '‚ÅâÔ∏è', 'üîÖ', 'üîÜ', '„ÄΩÔ∏è', '‚ö†Ô∏è',
        'üö∏', 'üî±', '‚öúÔ∏è', 'üî∞', '‚ôªÔ∏è', '‚úÖ', 'üàØ', 'üíπ',
        '‚ùáÔ∏è', '‚ú≥Ô∏è', '‚ùé', 'üåê', 'üí†', '‚ìÇÔ∏è', 'üåÄ', 'üí§',
        'üèß', 'üöæ', '‚ôø', 'üÖøÔ∏è', 'üà≥', 'üàÇÔ∏è', 'üõÇ', 'üõÉ',
        'üõÑ', 'üõÖ', 'üöπ', 'üö∫', 'üöº', 'üöª', 'üöÆ', 'üé¶',
        'üì∂', 'üàÅ', 'üî£', '‚ÑπÔ∏è', 'üî§', 'üî°', 'üî†', 'üî¢'
    ];
    
    let emojiPickerVisible = false;
    
    function toggleEmojiPicker() {
        const emojiPicker = document.getElementById('emoji-picker');
        emojiPickerVisible = !emojiPickerVisible;
        
        if (emojiPickerVisible) {
            emojiPicker.classList.add('show');
            // Populate emoji picker if empty
            if (emojiPicker.querySelector('#emoji-picker-body').children.length === 0) {
                populateEmojiPicker();
            }
        } else {
            emojiPicker.classList.remove('show');
        }
    }
    
    function populateEmojiPicker() {
        const emojiPickerBody = document.getElementById('emoji-picker-body');
        emojiPickerBody.innerHTML = '';
        
        emojiList.forEach(emoji => {
            const emojiItem = document.createElement('div');
            emojiItem.className = 'emoji-item';
            emojiItem.textContent = emoji;
            emojiItem.onclick = () => insertEmoji(emoji);
            emojiPickerBody.appendChild(emojiItem);
        });
    }
    
    function insertEmoji(emoji) {
        const chatInput = document.getElementById('chat-input');
        const cursorPos = chatInput.selectionStart;
        const textBefore = chatInput.value.substring(0, cursorPos);
        const textAfter = chatInput.value.substring(cursorPos);
        
        chatInput.value = textBefore + emoji + textAfter;
        chatInput.focus();
        
        // Set cursor position after inserted emoji
        const newCursorPos = cursorPos + emoji.length;
        chatInput.setSelectionRange(newCursorPos, newCursorPos);
        
        // Close emoji picker after selection
        toggleEmojiPicker();
    }
    
    // Close emoji picker when clicking outside
    document.addEventListener('click', (e) => {
        const emojiPicker = document.getElementById('emoji-picker');
        const emojiBtn = document.getElementById('chat-emoji-btn');
        
        if (emojiPickerVisible && 
            !emojiPicker.contains(e.target) && 
            !emojiBtn.contains(e.target)) {
            toggleEmojiPicker();
        }
    });
    
    
    // Initialize connection
    connectToServer();
    
    // Update server URL when input changes (for global mode)
    document.getElementById('server-url-input').addEventListener('change', function() {
        if (networkMode === 'global') {
            const newURL = this.value.trim() || window.location.origin;
            if (newURL !== currentServerURL) {
                currentServerURL = newURL;
                if (socket && socket.connected) {
                    socket.disconnect();
                    connectToServer();
                }
            }
        }
    });
    
    // ========== ROOM MANAGEMENT ==========
    function createRoom() {
        if (!socket || !socket.connected) {
            alert('Ch∆∞a k·∫øt n·ªëi ƒë·∫øn server! Vui l√≤ng ki·ªÉm tra l·∫°i.');
            connectToServer();
            return;
        }
        socket.emit('createRoom');
    }
    
    let joinRoomTimeout = null;
    let joinRoomButton = null;
    
    function joinRoom() {
        const codeInput = document.getElementById('room-code-input');
        const code = codeInput.value.trim().toUpperCase();
        
        if (!code || code.length !== 6) {
            alert('M√£ ph√≤ng kh√¥ng h·ª£p l·ªá! Vui l√≤ng nh·∫≠p ƒë√∫ng 6 k√Ω t·ª±.');
            codeInput.focus();
            return;
        }
        
        // L·∫•y button
        joinRoomButton = document.querySelector('button[onclick="joinRoom()"]');
        
        // Ki·ªÉm tra k·∫øt n·ªëi
        if (!socket) {
            if (msgEl) {
                msgEl.innerText = 'ƒêang k·∫øt n·ªëi ƒë·∫øn server...';
                msgEl.style.color = '#f39c12';
            }
            connectToServer();
            // ƒê·ª£i k·∫øt n·ªëi r·ªìi th·ª≠ l·∫°i
            setTimeout(() => {
                if (socket && socket.connected) {
                    joinRoom();
                } else {
                    if (msgEl) {
                        msgEl.innerText = 'Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server. Vui l√≤ng ki·ªÉm tra l·∫°i k·∫øt n·ªëi m·∫°ng.';
                        msgEl.style.color = '#e74c3c';
                    }
                }
            }, 3000);
            return;
        }
        
        if (!socket.connected) {
            if (msgEl) {
                msgEl.innerText = 'ƒêang k·∫øt n·ªëi l·∫°i... Vui l√≤ng ƒë·ª£i.';
                msgEl.style.color = '#f39c12';
            }
            socket.connect();
            // ƒê·ª£i k·∫øt n·ªëi r·ªìi th·ª≠ l·∫°i
            let retryCount = 0;
            const checkConnection = setInterval(() => {
                retryCount++;
                if (socket.connected) {
                    clearInterval(checkConnection);
                    if (msgEl) msgEl.innerText = '';
                    joinRoom(); // G·ªçi l·∫°i h√†m
                } else if (retryCount > 10) {
                    clearInterval(checkConnection);
                    if (msgEl) {
                        msgEl.innerText = 'Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server. Vui l√≤ng refresh trang.';
                        msgEl.style.color = '#e74c3c';
                    }
                }
            }, 1000);
            return;
        }
        
        // Hi·ªÉn th·ªã loading
        if (joinRoomButton) {
            joinRoomButton.disabled = true;
            joinRoomButton.textContent = 'ƒêang tham gia...';
        }
        
        if (msgEl) {
            msgEl.innerText = 'ƒêang tham gia ph√≤ng...';
            msgEl.style.color = '#3498db';
        }
        
        // Clear timeout c≈© n·∫øu c√≥
        if (joinRoomTimeout) {
            clearTimeout(joinRoomTimeout);
        }
        
        // Set timeout cho joinRoom (15 gi√¢y cho m·∫°ng y·∫øu)
        joinRoomTimeout = setTimeout(() => {
            if (joinRoomButton) {
                joinRoomButton.disabled = false;
                joinRoomButton.textContent = 'Tham Gia Ph√≤ng';
            }
            if (msgEl) {
                msgEl.innerText = 'Kh√¥ng th·ªÉ tham gia ph√≤ng. C√≥ th·ªÉ ph√≤ng kh√¥ng t·ªìn t·∫°i ho·∫∑c m·∫°ng qu√° ch·∫≠m.';
                msgEl.style.color = '#e74c3c';
            }
            joinRoomTimeout = null;
        }, 15000); // 15 gi√¢y timeout cho m·∫°ng y·∫øu
        
        // G·ª≠i request join room
        console.log('Sending joinRoom request:', code);
        socket.emit('joinRoom', { roomCode: code });
    }
    
    // Coin flip function - only host can flip
    // coinFlipped and coinResult are declared above in MULTIPLAYER STATE section
    
    function flipCoin() {
        console.log('flipCoin called', { coinFlipped, isOnlineGame, gameRoomId, isHost, playerId });
        
        // Ki·ªÉm tra ƒëi·ªÅu ki·ªán
        if (coinFlipped) {
            console.log('Coin already flipped');
            return;
        }
        
        if (!isOnlineGame) {
            console.log('Not online game');
            return;
        }
        
        if (!gameRoomId) {
            console.log('No game room ID');
            return;
        }
        
        if (!isHost) {
            alert('Ch·ªâ Player 1 m·ªõi ƒë∆∞·ª£c tung ƒë·ªìng xu!');
            console.log('Not host, cannot flip');
            return;
        }
        
        const coin = document.getElementById('coin');
        const resultEl = document.getElementById('coin-result');
        
        if (!coin || !resultEl) {
            console.error('Coin or result element not found');
            return;
        }
        
        console.log('Starting coin flip...');
        coin.classList.add('flipping');
        coin.style.pointerEvents = 'none';
        coin.style.cursor = 'not-allowed';
        
        setTimeout(() => {
            const result = Math.random() < 0.5 ? 'heads' : 'tails';
            coinFlipped = true;
            coinResult = result;
            
            console.log('Coin flip result:', result);
            
            // Player 1 sees heads (horse) or tails (empty)
            // Player 2 will see the opposite
            if (result === 'heads') {
                resultEl.textContent = 'ü™ô B·∫°n th·∫•y M·∫∂T NG·ª¨A! Ch·ªçn b√™n b·∫°n mu·ªën ch∆°i:';
                // Show choice buttons for Player 1
                document.getElementById('player1-choice').style.display = 'block';
            } else {
                resultEl.textContent = 'ü™ô B·∫°n th·∫•y M·∫∂T √öP (m·∫∑t sau)! Ch·ªçn b√™n b·∫°n mu·ªën ch∆°i:';
                // Show choice buttons for Player 1
                document.getElementById('player1-choice').style.display = 'block';
            }
            resultEl.style.display = 'block';
            
            // Send result to server (Player 1 sees result, Player 2 sees opposite)
            socket.emit('coinFlipResult', { roomCode: gameRoomId, result, playerId: playerId });
            console.log('Coin flip result sent to server');
        }, 2000);
    }
    
    // Function for player to choose side (can be Player 1 or Player 2)
    function chooseSide(chosenSide) {
        if (!coinResult || !isOnlineGame || !gameRoomId) return;
        
        // Send choice to server (server will check if this player can choose)
        socket.emit('playerChooseSide', { 
            roomCode: gameRoomId, 
            chosenSide: chosenSide,
            coinResult: coinResult 
        });
        
        // Hide choice buttons
        document.getElementById('player1-choice').style.display = 'none';
    }
    
    // Listen for coin flip result from server
    socket.on('coinFlipCompleted', ({ result, playerView, whoChooses, canChoose }) => {
        const resultEl = document.getElementById('coin-result');
        const coin = document.getElementById('coin');
        const coinInstruction = document.getElementById('coin-flip-instruction');
        
        // Update coin display based on what player sees
        coin.classList.remove('flipping');
        coin.style.pointerEvents = 'none';
        
        // Store coin result
        coinResult = result;
        
        // Check if this player can choose
        if (canChoose) {
            // This player can choose side
            if (playerView === 'heads') {
                coin.style.transform = 'rotateY(0deg)';
                resultEl.textContent = 'ü™ô B·∫°n th·∫•y M·∫∂T NG·ª¨A! Ch·ªçn b√™n b·∫°n mu·ªën ch∆°i:';
            } else {
                coin.style.transform = 'rotateY(180deg)';
                resultEl.textContent = 'ü™ô B·∫°n th·∫•y M·∫∂T √öP (m·∫∑t sau)! Ch·ªçn b√™n b·∫°n mu·ªën ch∆°i:';
            }
            // Show choice buttons
            document.getElementById('player1-choice').style.display = 'block';
            if (coinInstruction) {
                coinInstruction.textContent = 'B·∫°n ƒë∆∞·ª£c quy·ªÅn ch·ªçn b√™n!';
            }
        } else {
            // Other player chooses
            const chooserName = whoChooses === 'player1' ? 'Player 1' : 'Player 2';
            if (playerView === 'heads') {
                coin.style.transform = 'rotateY(0deg)';
                resultEl.textContent = `ü™ô B·∫°n th·∫•y M·∫∂T NG·ª¨A! ƒêang ch·ªù ${chooserName} ch·ªçn b√™n...`;
            } else {
                coin.style.transform = 'rotateY(180deg)';
                resultEl.textContent = `ü™ô B·∫°n th·∫•y M·∫∂T √öP (m·∫∑t sau)! ƒêang ch·ªù ${chooserName} ch·ªçn b√™n...`;
            }
            document.getElementById('player1-choice').style.display = 'none';
            if (coinInstruction) {
                coinInstruction.textContent = `ƒêang ch·ªù ${chooserName} ch·ªçn b√™n...`;
            }
        }
        resultEl.style.display = 'block';
    });
    
    // Dice roll function - both players roll
    let otherPlayerDiceResult = null;
    
    function rollDice() {
        console.log('rollDice called:', { diceRolled, isOnlineGame, gameRoomId, isHost, playerId });
        
        if (diceRolled) {
            console.log('Dice already rolled');
            return;
        }
        
        if (!isOnlineGame) {
            console.log('Not online game');
            return;
        }
        
        if (!gameRoomId) {
            console.log('No game room ID');
            return;
        }
        
        const dice = document.getElementById('dice');
        const resultEl = document.getElementById('dice-result-text');
        
        if (!dice || !resultEl) {
            console.log('Dice elements not found');
            return;
        }
        
        dice.classList.add('rolling');
        dice.style.pointerEvents = 'none';
        
        setTimeout(() => {
            // Ch·ªâ tung 1 x√∫c x·∫Øc t·ª´ 1-6
            const diceResult = Math.floor(Math.random() * 6) + 1;
            diceRolled = true;
            
            const playerName = isHost ? 'Player 1' : 'Player 2';
            resultEl.innerHTML = `üé≤ <strong>${playerName}</strong>: <strong>${diceResult}</strong><br>ƒêang ch·ªù ƒë·ªëi th·ªß...`;
            resultEl.style.display = 'block';
            
            console.log('Sending dice result to server:', { roomCode: gameRoomId, diceResult });
            
            // Send result to server (ch·ªâ g·ª≠i 1 k·∫øt qu·∫£)
            socket.emit('diceRollResult', { 
                roomCode: gameRoomId, 
                diceResult: diceResult 
            });
            
            dice.classList.remove('rolling');
        }, 1500);
    }
    
    // Listen for other player's dice result
    socket.on('diceRolled', ({ playerId: otherPlayerId, playerName, diceResult }) => {
        console.log('diceRolled event received:', { otherPlayerId, playerId, playerName, diceResult, diceRolled });
        if (otherPlayerId !== playerId) {
            const resultEl = document.getElementById('dice-result-text');
            if (!resultEl) return;
            
            if (diceRolled) {
                // Both players have rolled, update display with comparison
                const currentText = resultEl.innerHTML;
                // L·∫•y s·ªë x√∫c s·∫Øc c·ªßa m√¨nh t·ª´ text hi·ªán t·∫°i
                const myMatch = currentText.match(/<strong>(\d+)<\/strong>/);
                const myResult = myMatch ? parseInt(myMatch[1]) : 0;
                const otherResult = diceResult;
                
                // So s√°nh v√† hi·ªÉn th·ªã k·∫øt qu·∫£
                let comparisonText = '';
                if (myResult > otherResult) {
                    comparisonText = '<br><span style="color: #2ecc71; font-weight: bold;">‚úì B·∫°n th·∫Øng!</span>';
                } else if (myResult < otherResult) {
                    comparisonText = '<br><span style="color: #e74c3c; font-weight: bold;">‚úó B·∫°n thua!</span>';
                } else {
                    comparisonText = '<br><span style="color: #f39c12; font-weight: bold;">= H√≤a!</span>';
                }
                
                resultEl.innerHTML = currentText.replace('ƒêang ch·ªù ƒë·ªëi th·ªß...', `<br>üé≤ <strong>${playerName}</strong>: <strong>${otherResult}</strong>${comparisonText}<br><br>‚è≥ ƒêang so s√°nh k·∫øt qu·∫£...`);
                
                // Delay 5 gi√¢y tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu game
                setTimeout(() => {
                    if (resultEl) {
                        resultEl.innerHTML = currentText.replace('ƒêang ch·ªù ƒë·ªëi th·ªß...', `<br>üé≤ <strong>${playerName}</strong>: <strong>${otherResult}</strong>${comparisonText}`);
                    }
                }, 5000);
            } else {
                // Other player rolled first
                resultEl.innerHTML = `üé≤ <strong>${playerName}</strong>: <strong>${diceResult}</strong><br>ƒê·∫øn l∆∞·ª£t b·∫°n tung x√∫c x·∫Øc!`;
                resultEl.style.display = 'block';
                
                // ƒê·∫£m b·∫£o dice c√≥ th·ªÉ click ƒë∆∞·ª£c
                const dice = document.getElementById('dice');
                if (dice) {
                    dice.style.pointerEvents = 'auto';
                    dice.style.cursor = 'pointer';
                    dice.onclick = rollDice;
                }
            }
        }
    });
    
    // Copy room code function
    function copyRoomCode() {
        const roomCode = document.getElementById('room-code-display').textContent;
        if (!roomCode || roomCode === 'ABC123') {
            alert('Ch∆∞a c√≥ m√£ ph√≤ng!');
            return;
        }
        
        // Copy to clipboard
        navigator.clipboard.writeText(roomCode).then(() => {
            // Show success message
            const successMsg = document.getElementById('copy-success-msg');
            if (successMsg) {
                successMsg.style.display = 'block';
                setTimeout(() => {
                    successMsg.style.display = 'none';
                }, 2000);
            }
        }).catch(err => {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = roomCode;
            textArea.style.position = 'fixed';
            textArea.style.opacity = '0';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                const successMsg = document.getElementById('copy-success-msg');
                if (successMsg) {
                    successMsg.style.display = 'block';
                    setTimeout(() => {
                        successMsg.style.display = 'none';
                    }, 2000);
                }
            } catch (err) {
                alert('Kh√¥ng th·ªÉ copy m√£ ph√≤ng. M√£ ph√≤ng: ' + roomCode);
            }
            document.body.removeChild(textArea);
        });
    }
    
    // Reset game to menu
    function resetToMenu() {
        // D·ª´ng timer
        stopTimer();
        
        // Reset all game state
        isGameOver = false;
        isOnlineGame = false;
        isBotMode = false;
        botDifficulty = 'medium'; // Reset ƒë·ªô kh√≥ v·ªÅ m·∫∑c ƒë·ªãnh
        gameRoomId = null;
        isHost = false;
        playerId = null;
        coinFlipped = false;
        coinResult = null;
        diceRolled = false;
        playerSide = null;
        selectedPiece = null;
        validMoves = [];
        pieces = [];
        deadChess = [];
        deadXQ = [];
        currentTurn = "chess";
        lastMove = null;
        enPassantTarget = null;
        
        // Reset special tile state
        specialTileState = {
            activatedBy: null,
            activatedByChess: false,
            activatedByXiangqi: false,
            xiangqiGeneralUnlocked: false
        };
        gameHistory = [];
        viewIndex = -1;
        isReviewing = false;
        positionHistory = []; // Reset l·ªãch s·ª≠ tr·∫°ng th√°i
        pendingPromotion = null;
        botSide = null;
        
        // Reset timer
        resetTimers();
        firstMoveMade = false; // Reset flag n∆∞·ªõc ƒëi ƒë·∫ßu ti√™n
        
        // ·∫®n timer display
        if (chessTimerEl) chessTimerEl.style.display = 'none';
        if (xiangqiTimerEl) xiangqiTimerEl.style.display = 'none';
        
        // Disconnect socket if connected
        if (socket && socket.connected) {
            socket.disconnect();
            console.log('Disconnected from server for menu reset');
        }
        
        // Hide all game screens
        const gameOverEl = document.getElementById('game-over');
        const startScreenEl = document.getElementById('start-screen');
        const roomInfoEl = document.getElementById('room-info');
        const diceSectionEl = document.getElementById('dice-section');
        const coinFlipSectionEl = document.getElementById('coin-flip-section');
        const boardContainerEl = document.getElementById('board-container');
        const chatButtonEl = document.getElementById('chat-button');
        const chatContainerEl = document.getElementById('chat-container');
        
        if (gameOverEl) gameOverEl.style.display = 'none';
        if (roomInfoEl) roomInfoEl.style.display = 'none';
        if (diceSectionEl) diceSectionEl.style.display = 'none';
        if (coinFlipSectionEl) coinFlipSectionEl.style.display = 'none';
        if (boardContainerEl) boardContainerEl.style.display = 'none';
        if (chatButtonEl) chatButtonEl.classList.remove('show');
        if (chatContainerEl) chatContainerEl.classList.remove('show');
        
        // Show start screen
        if (startScreenEl) {
            startScreenEl.style.display = 'flex';
        }
        
        // Reset UI
        if (msgEl) {
            msgEl.innerText = '';
            msgEl.style.color = '';
        }
        
        // Clear board
        if (boardEl) {
            boardEl.innerHTML = '';
        }
        
        console.log('Reset to menu completed');
    }
    
    // Play again function
    function playAgain() {
        if (isOnlineGame && gameRoomId) {
            // Online game - disconnect and reset
            if (socket && socket.connected) {
                socket.emit('leaveRoom', { roomCode: gameRoomId });
                socket.disconnect();
            }
            resetToMenu();
            // Reconnect after a short delay
            setTimeout(() => {
                connectToServer();
            }, 500);
        } else if (isBotMode) {
            // Bot game - just reset
            resetToMenu();
        } else {
            // Offline game - reset
            resetToMenu();
        }
    }
    
    function startOnlineGame(firstTurn) {
        console.log('startOnlineGame called:', { firstTurn, isOnlineGame, isBotMode });
        
        isOnlineGame = true;
        isBotMode = false; // ƒê·∫£m b·∫£o kh√¥ng ph·∫£i bot mode
        
        // Initialize game state
        pieces = JSON.parse(JSON.stringify(INITIAL_SETUP));
        deadChess = [];
        deadXQ = [];
        currentTurn = firstTurn;
        isGameOver = false;
        lastMove = null;
        enPassantTarget = null;
        selectedPiece = null;
        validMoves = [];
        
        // Reset special tile state
        specialTileState = {
            activatedBy: null,
            activatedByChess: false,
            activatedByXiangqi: false,
            xiangqiGeneralUnlocked: false
        };
        
        // Reset position history
        positionHistory = [];
        
        // Reset v√† kh·ªüi ƒë·ªông timer
        resetTimers();
        
        // Hide start screen
        const startScreen = document.getElementById('start-screen');
        if (startScreen) {
            startScreen.style.display = 'none';
        }
        
        // Show game board container
        const boardContainer = document.getElementById('board-container');
        if (boardContainer) {
            boardContainer.style.display = 'block';
        }
        
        // Also show graves and other game elements
        const graves = document.getElementById('graves');
        if (graves) {
            graves.style.display = 'flex';
        }
        
        // Draw the board
        console.log('Drawing board...');
        drawBoard();
        updateStatusUI(currentTurn, pieces);
        
        // B·∫Øt ƒë·∫ßu timer
        startTimer();
        
        console.log('Game started successfully:', { currentTurn, playerSide, piecesCount: pieces.length });
    }
    
    function syncGameState() {
        if (!isOnlineGame || !gameRoomId) return;
        
        const gameState = {
            pieces: pieces,
            deadChess: deadChess,
            deadXQ: deadXQ,
            currentTurn: currentTurn,
            lastMove: lastMove,
            isGameOver: isGameOver,
            winner: isGameOver ? (currentTurn === 'chess' ? 'xiangqi' : 'chess') : null
        };
        
        socket.emit('updateGameState', { roomCode: gameRoomId, gameState });
    }
    
    // Resign game function
    function resignGame() {
        if (isGameOver) return;
        
        if (!confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën ƒë·∫ßu h√†ng kh√¥ng?')) {
            return;
        }
        
        stopTimer(); // D·ª´ng timer khi ƒë·∫ßu h√†ng
        
        if (isOnlineGame && gameRoomId) {
            // Online game - send to server
            socket.emit('resignGame', { roomCode: gameRoomId });
        } else {
            // Offline/Bot game - local resign
            isGameOver = true;
            const winner = currentTurn === 'chess' ? 'xiangqi' : 'chess';
            const winnerText = document.getElementById('winner-text');
            if (winnerText) {
                winnerText.innerText = (winner === playerSide ? 'B·∫†N' : 'ƒê·ªêI TH·ª¶') + ' TH·∫ÆNG!\n(B·∫°n ƒë√£ ƒë·∫ßu h√†ng)';
            }
            const gameOverEl = document.getElementById('game-over');
            if (gameOverEl) {
                gameOverEl.style.display = 'flex';
            }
            if (msgEl) {
                msgEl.innerText = 'B·∫°n ƒë√£ ƒë·∫ßu h√†ng!';
                msgEl.style.color = '#e74c3c';
            }
            drawBoard();
        }
    }
    
    // Offer draw function
    function offerDraw() {
        if (isGameOver) return;
        
        if (isOnlineGame && gameRoomId) {
            // Online game - send to server
            socket.emit('offerDraw', { roomCode: gameRoomId });
            if (msgEl) {
                msgEl.innerText = 'ƒê√£ g·ª≠i y√™u c·∫ßu h√≤a c·ªù...';
                msgEl.style.color = '#f39c12';
                setTimeout(() => {
                    if (msgEl && msgEl.innerText === 'ƒê√£ g·ª≠i y√™u c·∫ßu h√≤a c·ªù...') {
                        msgEl.innerText = '';
                    }
                }, 3000);
            }
        } else {
            // Offline/Bot game - auto accept
            if (confirm('B·∫°n mu·ªën h√≤a c·ªù kh√¥ng?')) {
                stopTimer(); // D·ª´ng timer khi h√≤a c·ªù
                isGameOver = true;
                const winnerText = document.getElementById('winner-text');
                if (winnerText) {
                    winnerText.innerText = 'H√íA C·ªú!';
                }
                const gameOverEl = document.getElementById('game-over');
                if (gameOverEl) {
                    gameOverEl.style.display = 'flex';
                }
                if (msgEl) {
                    msgEl.innerText = 'H√≤a c·ªù!';
                    msgEl.style.color = '#f39c12';
                }
                drawBoard();
            }
        }
    }
    
    // --- AUDIO ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        if (type === 'move') {
            osc.frequency.setValueAtTime(600, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.start(); osc.stop(audioCtx.currentTime + 0.1);
        } else {
            osc.type = 'square'; osc.frequency.setValueAtTime(150, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.2);
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            osc.start(); osc.stop(audioCtx.currentTime + 0.2);
        }
    }

    // --- CONFIG ---
    const ROWS = 10; const COLS = 9;
    const XQ_CHARS = { "xe": "Ëªä", "m√£": "È¶¨", "t∆∞·ª£ng": "Áõ∏", "sƒ©": "‰ªï", "t∆∞·ªõng": "Â∏•", "ph√°o": "ÁÇÆ", "t·ªët": "ÂÖµ" };
    
    // --- STATE ---
    let pieces = [];
    let deadChess = []; // Qu√¢n tr·∫Øng ch·∫øt
    let deadXQ = [];    // Qu√¢n ƒë·ªè ch·∫øt
    let currentTurn = "chess";
    let selectedPiece = null;
    let isGameOver = false;
    let lastMove = null; 
    let gameHistory = []; 
    let viewIndex = -1;
    let isReviewing = false;
    let pendingPromotion = null; // Qu√¢n T·ªët ƒëang ch·ªù phong c·∫•p
    let isBotMode = false; // Ch·∫ø ƒë·ªô ch∆°i v·ªõi BOT
    let botSide = null; // B√™n m√† BOT ch∆°i (chess ho·∫∑c xiangqi)
    let enPassantTarget = null; // {r, c} - V·ªã tr√≠ t·ªët c√≥ th·ªÉ b·ªã ƒÉn en passant
    let positionHistory = []; // L∆∞u l·ªãch s·ª≠ c√°c tr·∫°ng th√°i b√†n c·ªù ƒë·ªÉ ki·ªÉm tra l·∫∑p l·∫°i
    
    // ========== TIMER SYSTEM ==========
    const TIMER_DURATION = 10 * 60; // 10 ph√∫t = 600 gi√¢y
    let chessTimer = TIMER_DURATION; // Th·ªùi gian c√≤n l·∫°i c·ªßa C·ªù Vua (gi√¢y)
    let xiangqiTimer = TIMER_DURATION; // Th·ªùi gian c√≤n l·∫°i c·ªßa C·ªù T∆∞·ªõng (gi√¢y)
    let timerInterval = null; // Interval cho timer
    let timerPaused = false; // Timer c√≥ ƒëang t·∫°m d·ª´ng kh√¥ng
    let firstMoveMade = false; // ƒê√£ c√≥ n∆∞·ªõc ƒëi ƒë·∫ßu ti√™n ch∆∞a (timer ch·ªâ b·∫Øt ƒë·∫ßu sau n∆∞·ªõc ƒëi ƒë·∫ßu ti√™n)
    
    // ========== SPECIAL TILE SYSTEM ==========
    const SPECIAL_TILE = { r: 0, c: 8 }; // √î ƒë·∫∑c bi·ªát ·ªü g√≥c tr√™n b√™n ph·∫£i, b√™n c·∫°nh Xe c·ªù Vua
    let specialTileState = {
        activatedBy: null, // null | 'chess' | 'xiangqi' | 'both' (khi c·∫£ 2 b√™n ƒë√£ d√πng)
        activatedByChess: false, // C·ªù Vua ƒë√£ k√≠ch ho·∫°t ch∆∞a
        activatedByXiangqi: false, // C·ªù T∆∞·ªõng ƒë√£ k√≠ch ho·∫°t ch∆∞a
        xiangqiGeneralUnlocked: false // T∆∞·ªõng c·ªù t∆∞·ªõng ƒë√£ ƒë∆∞·ª£c unlock ch∆∞a
    };

    // Elements
    const boardEl = document.getElementById("board");
    const turnBadge = document.getElementById("turn-badge");
    const msgEl = document.getElementById("message");
    const graveTop = document.getElementById("grave-top"); // Ch·ª©a qu√¢n tr·∫Øng ch·∫øt
    const graveBot = document.getElementById("grave-bot"); // Ch·ª©a qu√¢n ƒë·ªè ch·∫øt
    const btnPrev = document.getElementById("btn-prev");
    const btnNext = document.getElementById("btn-next");
    const btnLive = document.getElementById("btn-live");
    const promoModal = document.getElementById("promotion-modal");
    const activationModal = document.getElementById("special-activation-modal");
    const chessTimerEl = document.getElementById("chess-timer");
    const xiangqiTimerEl = document.getElementById("xiangqi-timer");
    const chessTimerTextEl = document.getElementById("chess-timer-text");
    const xiangqiTimerTextEl = document.getElementById("xiangqi-timer-text");

    const INITIAL_SETUP = [
        { type: "rook", side: "chess", r: 0, c: 0, hasMoved: false }, { type: "knight", side: "chess", r: 0, c: 1 },
        { type: "bishop", side: "chess", r: 0, c: 2 }, { type: "queen", side: "chess", r: 0, c: 3 },
        { type: "king", side: "chess", r: 0, c: 4, hasMoved: false }, { type: "bishop", side: "chess", r: 0, c: 5 },
        { type: "knight", side: "chess", r: 0, c: 6 }, { type: "rook", side: "chess", r: 0, c: 7, hasMoved: false },
        ...Array.from({ length: 8 }, (_, i) => ({ type: "pawn", side: "chess", r: 1, c: i, hasMoved: false, hasShield: true })),
        { type: "xe", side: "xiangqi", r: 9, c: 0 }, { type: "m√£", side: "xiangqi", r: 9, c: 1 },
        { type: "t∆∞·ª£ng", side: "xiangqi", r: 9, c: 2 }, { type: "sƒ©", side: "xiangqi", r: 9, c: 3 },
        { type: "t∆∞·ªõng", side: "xiangqi", r: 9, c: 4 }, { type: "sƒ©", side: "xiangqi", r: 9, c: 5 },
        { type: "t∆∞·ª£ng", side: "xiangqi", r: 9, c: 6 }, { type: "m√£", side: "xiangqi", r: 9, c: 7 },
        { type: "xe", side: "xiangqi", r: 9, c: 8 },
        { type: "ph√°o", side: "xiangqi", r: 7, c: 1 }, { type: "ph√°o", side: "xiangqi", r: 7, c: 7 },
        ...[0,2,4,6,8].map(c => ({ type: "t·ªët", side: "xiangqi", r: 6, c })),
        // Con t·ªët c·ªù vua ·ªü h√†ng ngang (h√†ng 1, c·ªôt 8) ƒë·ªÉ b·∫£o v·ªá √¥ ƒë·∫∑c bi·ªát ·ªü g√≥c tr√™n b√™n ph·∫£i
        { type: "pawn", side: "chess", r: 1, c: 8, hasMoved: false, hasShield: true },
    ];

    // --- START ---
    function startGame() {
        // H√†m n√†y ch·ªâ d√πng cho offline mode (index_chess.html)
        // Kh√¥ng d√πng cho online/bot mode
        pieces = JSON.parse(JSON.stringify(INITIAL_SETUP));
        deadChess = []; deadXQ = [];
        enPassantTarget = null;
        let count = 0;
        const diceInterval = setInterval(() => {
            document.getElementById("dice-result").innerText = count % 2 ? "‚ôö" : "Â∏•";
            count++;
            if (count > 10) {
                clearInterval(diceInterval);
                currentTurn = Math.random() < 0.5 ? "chess" : "xiangqi";
                document.getElementById("dice-result").innerText = currentTurn === "chess" ? "C·ªù Vua ƒëi tr∆∞·ªõc" : "C·ªù T∆∞·ªõng ƒëi tr∆∞·ªõc";
                setTimeout(() => {
                    document.getElementById("start-screen").style.display = "none";
                    saveState();
                    drawBoard();
                }, 1000);
            }
        }, 100);
    }
    
    function startBotGame() {
        // Ki·ªÉm tra ng∆∞·ªùi ch∆°i ƒë√£ ch·ªçn b√™n ch∆∞a
        if (!playerSide) {
            playerSide = "chess"; // M·∫∑c ƒë·ªãnh l√† c·ªù Vua
            botSide = "xiangqi";
            document.getElementById('btn-choose-chess').classList.add('active');
            document.getElementById('btn-choose-xiangqi').classList.remove('active');
        } else {
            botSide = playerSide === "chess" ? "xiangqi" : "chess";
        }
        
        // ·∫®n menu v√† hi·ªÉn th·ªã dice section
        document.getElementById("bot-menu").style.display = "none";
        document.getElementById("dice-section").style.display = "block";
        
        // Tung x√∫c x·∫Øc ƒë·ªÉ quy·∫øt ƒë·ªãnh ai ƒëi tr∆∞·ªõc
        let count = 0;
        const diceInterval = setInterval(() => {
            const diceEl = document.getElementById("dice-result-text");
            if (diceEl) {
                diceEl.style.display = "block";
                diceEl.innerText = count % 2 ? (playerSide === "chess" ? "‚ôö" : "Â∏•") : (playerSide === "chess" ? "Â∏•" : "‚ôö");
            }
            count++;
            if (count > 10) {
                clearInterval(diceInterval);
                currentTurn = Math.random() < 0.5 ? playerSide : botSide;
                const resultEl = document.getElementById("dice-result-text");
                if (resultEl) {
                    const playerSideText = playerSide === "chess" ? "üè∞ C·ªù Vua" : "‚õ©Ô∏è C·ªù T∆∞·ªõng";
                    const botSideText = botSide === "chess" ? "üè∞ C·ªù Vua" : "‚õ©Ô∏è C·ªù T∆∞·ªõng";
                    resultEl.innerText = currentTurn === playerSide 
                        ? `B·∫°n ƒëi tr∆∞·ªõc (${playerSideText})` 
                        : `BOT ƒëi tr∆∞·ªõc (${botSideText})`;
                }
                setTimeout(() => {
                    // ƒê·∫£m b·∫£o isBotMode ƒë∆∞·ª£c set
                    isBotMode = true;
                    isOnlineGame = false;
                    
                    // Kh·ªüi t·∫°o tr·∫°ng th√°i game
                    pieces = JSON.parse(JSON.stringify(INITIAL_SETUP));
                    deadChess = [];
                    deadXQ = [];
                    isGameOver = false;
                    lastMove = null;
                    enPassantTarget = null;
                    selectedPiece = null;
                    validMoves = [];
                    
                    // Reset special tile state
                    specialTileState = {
                        activatedBy: null,
                        activatedByChess: false,
                        activatedByXiangqi: false,
                        xiangqiGeneralUnlocked: false
                    };
                    
                    // Reset position history
                    positionHistory = [];
                    
                    // ·∫®n c√°c m√†n h√¨nh menu
                    document.getElementById("start-screen").style.display = "none";
                    document.getElementById("dice-section").style.display = "none";
                    
                    // Hi·ªÉn th·ªã b√†n c·ªù v√† c√°c ph·∫ßn t·ª≠ game
                    const boardContainer = document.getElementById('board-container');
                    if (boardContainer) {
                        boardContainer.style.display = 'block';
                    }
                    
                    const graves = document.getElementById('graves');
                    if (graves) {
                        graves.style.display = 'flex';
                    }
                    
                    saveState();
                    drawBoard();
                    
                    // N·∫øu BOT ƒëi tr∆∞·ªõc, cho BOT ƒëi ngay
                    if (currentTurn === botSide && isBotMode) {
                        console.log('Bot goes first, making move...');
                        setTimeout(() => botMakeMove(), 1000);
                    }
                }, 1000);
            }
        }, 100);
    }

    // --- LOGIC PHONG C·∫§P ---
    function promotePawn(newType) {
        if (!pendingPromotion) return;
        
        pendingPromotion.type = newType;
        playSound('capture'); // Sound effect
        promoModal.style.display = 'none';
        pendingPromotion = null;

        // Sau khi ch·ªçn xong m·ªõi k·∫øt th√∫c l∆∞·ª£t
        finishTurn();
        
        // Sync v·ªõi server n·∫øu ƒëang ch∆°i online
        if (isOnlineGame) {
            syncGameState();
        }
    }

    function finishTurn() {
        selectedPiece = null;
        
        // X√≥a en passant target khi ƒë·ªïi l∆∞·ª£t (ch·ªâ c√≥ th·ªÉ ƒÉn en passant ·ªü l∆∞·ª£t ti·∫øp theo)
        // Nh∆∞ng gi·ªØ l·∫°i n·∫øu t·ªët v·ª´a ƒëi 2 √¥ ·ªü l∆∞·ª£t n√†y
        // (enPassantTarget s·∫Ω ƒë∆∞·ª£c set trong tryMoveTo khi t·ªët ƒëi 2 √¥)
        
        // L∆∞u state tr∆∞·ªõc khi ƒë·ªïi l∆∞·ª£t (ƒë·ªÉ ki·ªÉm tra l·∫∑p l·∫°i v·ªõi tr·∫°ng th√°i ƒë√∫ng)
        saveState();
        
        currentTurn = currentTurn === "chess" ? "xiangqi" : "chess";
        
        // ƒê·ªïi timer sang b√™n m·ªõi
        startTimer();
        
        // X√≥a en passant target sau khi ƒë·ªïi l∆∞·ª£t (n·∫øu kh√¥ng ƒë∆∞·ª£c s·ª≠ d·ª•ng)
        // Ch·ªâ gi·ªØ l·∫°i n·∫øu t·ªët v·ª´a ƒëi 2 √¥ ·ªü l∆∞·ª£t tr∆∞·ªõc
        // Logic n√†y ƒë∆∞·ª£c x·ª≠ l√Ω trong tryMoveTo

        if (isCheckmate(currentTurn)) {
            stopTimer();
            isGameOver = true;
            const winner = currentTurn === "chess" ? "xiangqi" : "chess";
            if (isBotMode) {
                document.getElementById("winner-text").innerText = (winner === playerSide ? "B·∫†N" : "BOT") + " TH·∫ÆNG!";
            } else {
                document.getElementById("winner-text").innerText = (winner === playerSide ? "B·∫†N" : "ƒê·ªêI TH·ª¶") + " TH·∫ÆNG!";
            }
            document.getElementById("game-over").style.display = "flex";
        }
        
        // Ki·ªÉm tra l·∫∑p l·∫°i tr·∫°ng th√°i (threefold repetition)
        // Ki·ªÉm tra v·ªõi tr·∫°ng th√°i sau khi ƒë·ªïi l∆∞·ª£t (v√¨ c√πng m·ªôt tr·∫°ng th√°i b√†n c·ªù c√≥ th·ªÉ xu·∫•t hi·ªán ·ªü c√°c l∆∞·ª£t kh√°c nhau)
        if (!isGameOver && checkThreefoldRepetition()) {
            stopTimer();
            isGameOver = true;
            const winnerText = document.getElementById('winner-text');
            if (winnerText) {
                winnerText.innerText = 'H√íA C·ªú!\n(L·∫∑p l·∫°i n∆∞·ªõc ƒëi 4 l·∫ßn)';
            }
            const gameOverEl = document.getElementById('game-over');
            if (gameOverEl) {
                gameOverEl.style.display = 'flex';
            }
            if (msgEl) {
                msgEl.innerText = 'H√≤a c·ªù do l·∫∑p l·∫°i n∆∞·ªõc ƒëi!';
                msgEl.style.color = '#f39c12';
            }
            drawBoard();
            return; // D·ª´ng l·∫°i, kh√¥ng ti·∫øp t·ª•c
        }
        
        // Sync v·ªõi server n·∫øu ƒëang ch∆°i online
        if (isOnlineGame) {
            syncGameState();
        }
        
        drawBoard();
        updateStatusUI(currentTurn, pieces);
        
        // N·∫øu ƒëang ch∆°i v·ªõi BOT v√† ƒë·∫øn l∆∞·ª£t BOT, cho BOT ƒëi
        if (isBotMode && !isGameOver && currentTurn === botSide && botSide) {
            console.log('Calling botMakeMove from finishTurn...');
            setTimeout(() => botMakeMove(), 800);
        }
    }
    
    // ========== SPECIAL TILE SYSTEM ==========
    /**
     * X·ª≠ l√Ω khi qu√¢n c·ªù di chuy·ªÉn v√†o √¥ ƒë·∫∑c bi·ªát
     * @param {Object} piece - Qu√¢n c·ªù v·ª´a di chuy·ªÉn v√†o √¥ ƒë·∫∑c bi·ªát
     */
    function handleSpecialTileActivation(piece) {
        // Ki·ªÉm tra n·∫øu c·∫£ 2 b√™n ƒë√£ k√≠ch ho·∫°t r·ªìi
        if (specialTileState.activatedByChess && specialTileState.activatedByXiangqi) {
            if (msgEl) {
                msgEl.innerText = `‚ö†Ô∏è √î ƒë·∫∑c bi·ªát ƒë√£ h·∫øt ch·ª©c nƒÉng!`;
                msgEl.style.color = '#888';
                setTimeout(() => { if (msgEl) msgEl.innerText = ''; }, 3000);
            }
            return;
        }
        
        // Ki·ªÉm tra n·∫øu √¥ ƒë√£ b·ªã k√≠ch ho·∫°t b·ªüi b√™n n√†y
        if ((piece.side === 'chess' && specialTileState.activatedByChess) ||
            (piece.side === 'xiangqi' && specialTileState.activatedByXiangqi)) {
            if (msgEl) {
                msgEl.innerText = `‚ö†Ô∏è √î ƒë·∫∑c bi·ªát ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t b·ªüi ${piece.side === 'chess' ? 'C·ªù Vua' : 'C·ªù T∆∞·ªõng'}!`;
                msgEl.style.color = '#ffaa00';
                setTimeout(() => { if (msgEl) msgEl.innerText = ''; }, 3000);
            }
            return;
        }
        
        // Ki·ªÉm tra lo·∫°i qu√¢n c·ªù
        if (piece.side === 'xiangqi') {
            // Qu√¢n c·ªù t∆∞·ªõng ch·∫°m v√†o -> unlock T∆∞·ªõng
            unlockXiangqiGeneral();
            specialTileState.activatedByXiangqi = true;
        } else if (piece.side === 'chess' && piece.type === 'king') {
            // Vua c·ªù vua ch·∫°m v√†o -> teleport
            teleportKingToA9(piece);
            specialTileState.activatedByChess = true;
        } else {
            // Qu√¢n kh√°c kh√¥ng k√≠ch ho·∫°t
            return;
        }
        
        // ƒê√°nh d·∫•u ƒë√£ k√≠ch ho·∫°t
        if (specialTileState.activatedByChess && specialTileState.activatedByXiangqi) {
            specialTileState.activatedBy = 'both';
        } else {
            specialTileState.activatedBy = piece.side;
        }
        
        // Hi·ªáu ·ª©ng visual
        flashSpecialTile();
        
        // V·∫Ω l·∫°i board ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i √¥ ƒë·∫∑c bi·ªát
        drawBoard();
    }
    
    /**
     * M·ªü kh√≥a T∆∞·ªõng c·ªù t∆∞·ªõng - cho ph√©p ƒëi ngang ho·∫∑c d·ªçc 1 √¥ v√† ra kh·ªèi cung th√†nh
     */
    function unlockXiangqiGeneral() {
        const general = pieces.find(p => p.side === 'xiangqi' && p.type === 't∆∞·ªõng');
        if (!general) return;
        
        specialTileState.xiangqiGeneralUnlocked = true;
        general.unlocked = true; // ƒê√°nh d·∫•u T∆∞·ªõng ƒë√£ ƒë∆∞·ª£c unlock
        
        // Hi·ªÉn th·ªã modal th√¥ng b√°o
        showActivationModal(
            '‚ú® T∆Ø·ªöNG ƒê√É ƒê∆Ø·ª¢C M·ªû KH√ìA!',
            '‚õ©Ô∏è',
            'Qu√¢n c·ªù T∆∞·ªõng c·ªßa b·∫°n ƒë√£ ch·∫°m v√†o √¥ ch·ª©c nƒÉng ƒë·∫∑c bi·ªát!',
            'T∆∞·ªõng gi·ªù ƒë√¢y c√≥ th·ªÉ:\n‚Ä¢ ƒêi ngang ho·∫∑c d·ªçc 1 √¥ m·ªói l∆∞·ª£t\n‚Ä¢ Ra kh·ªèi cung th√†nh\n‚Ä¢ Di chuy·ªÉn t·ª± do tr√™n b√†n c·ªù'
        );
        
        // Hi·ªáu ·ª©ng v√† th√¥ng b√°o tr√™n message bar
        if (msgEl) {
            msgEl.innerText = '‚ú® T∆Ø·ªöNG ƒê√É ƒê∆Ø·ª¢C M·ªû KH√ìA! C√≥ th·ªÉ ƒëi ngang ho·∫∑c d·ªçc 1 √¥, ra kh·ªèi cung th√†nh!';
            msgEl.style.color = '#2ecc71';
            msgEl.style.fontWeight = 'bold';
            setTimeout(() => { 
                if (msgEl) {
                    msgEl.style.fontWeight = 'normal';
                    msgEl.style.color = '';
                }
            }, 5000);
        }
        
        playSound('capture'); // Sound effect
        drawBoard(); // V·∫Ω l·∫°i ƒë·ªÉ hi·ªÉn th·ªã overlay
    }
    
    /**
     * Teleport Vua c·ªù vua ƒë·∫øn √¥ A9 (r=0, c=0)
     * @param {Object} kingPiece - Qu√¢n Vua c·∫ßn teleport
     */
    function teleportKingToA9(kingPiece) {
        const targetR = 0;
        const targetC = 0; // A9 = c·ªôt 0, h√†ng 0
        
        // Ki·ªÉm tra √¥ ƒë√≠ch c√≥ h·ª£p l·ªá kh√¥ng
        if (!inside(targetR, targetC)) {
            console.error('Invalid teleport target: A9 is out of bounds');
            if (msgEl) {
                msgEl.innerText = '‚ùå L·ªói: Kh√¥ng th·ªÉ teleport!';
                msgEl.style.color = '#e74c3c';
            }
            return;
        }
        
        // Ki·ªÉm tra √¥ ƒë√≠ch c√≥ qu√¢n kh√¥ng
        const targetPiece = pieces.find(p => p.r === targetR && p.c === targetC);
        
        if (targetPiece) {
            if (targetPiece.side === kingPiece.side) {
                // ƒê·ªìng minh -> ƒë·ªïi ch·ªó
                const tempR = kingPiece.r;
                const tempC = kingPiece.c;
                kingPiece.r = targetR;
                kingPiece.c = targetC;
                targetPiece.r = tempR;
                targetPiece.c = tempC;
                
                // Hi·ªÉn th·ªã modal th√¥ng b√°o
                showActivationModal(
                    '‚ú® VUA ƒê√É TELEPORT!',
                    'üëë',
                    'Vua c·ªßa b·∫°n ƒë√£ ch·∫°m v√†o √¥ ch·ª©c nƒÉng ƒë·∫∑c bi·ªát!',
                    'Vua ƒë√£ ƒë∆∞·ª£c d·ªãch chuy·ªÉn ƒë·∫øn √¥ A9 v√† ƒë·ªïi ch·ªó v·ªõi ƒë·ªìng minh!'
                );
                
                if (msgEl) {
                    msgEl.innerText = '‚ú® Vua ƒë√£ teleport v√† ƒë·ªïi ch·ªó v·ªõi ƒë·ªìng minh!';
                    msgEl.style.color = '#3498db';
                }
            } else {
                // ƒê·ªãch -> ƒÉn qu√¢n ƒë·ªãch
                const capIdx = pieces.indexOf(targetPiece);
                pieces.splice(capIdx, 1);
                if (targetPiece.side === "chess") deadChess.push(targetPiece.type);
                else deadXQ.push(targetPiece.type);
                
                kingPiece.r = targetR;
                kingPiece.c = targetC;
                
                playSound('capture');
                
                // Hi·ªÉn th·ªã modal th√¥ng b√°o
                showActivationModal(
                    '‚ú® VUA ƒê√É TELEPORT!',
                    'üëë',
                    'Vua c·ªßa b·∫°n ƒë√£ ch·∫°m v√†o √¥ ch·ª©c nƒÉng ƒë·∫∑c bi·ªát!',
                    'Vua ƒë√£ ƒë∆∞·ª£c d·ªãch chuy·ªÉn ƒë·∫øn √¥ A9 v√† ƒÉn qu√¢n ƒë·ªãch!'
                );
                
                if (msgEl) {
                    msgEl.innerText = '‚ú® Vua ƒë√£ teleport v√† ƒÉn qu√¢n ƒë·ªãch!';
                    msgEl.style.color = '#e74c3c';
                }
            }
        } else {
            // √î tr·ªëng -> teleport b√¨nh th∆∞·ªùng
            kingPiece.r = targetR;
            kingPiece.c = targetC;
            
            // Hi·ªÉn th·ªã modal th√¥ng b√°o
            showActivationModal(
                '‚ú® VUA ƒê√É TELEPORT!',
                'üëë',
                'Vua c·ªßa b·∫°n ƒë√£ ch·∫°m v√†o √¥ ch·ª©c nƒÉng ƒë·∫∑c bi·ªát!',
                'Vua ƒë√£ ƒë∆∞·ª£c d·ªãch chuy·ªÉn ngay l·∫≠p t·ª©c ƒë·∫øn √¥ A9!'
            );
            
            if (msgEl) {
                msgEl.innerText = '‚ú® Vua ƒë√£ teleport ƒë·∫øn A9!';
                msgEl.style.color = '#9b59b6';
            }
        }
        
        // Hi·ªáu ·ª©ng warp
        playSound('move');
        setTimeout(() => {
            drawBoard();
        }, 100);
    }
    
    /**
     * Hi·ªÉn th·ªã modal th√¥ng b√°o k√≠ch ho·∫°t √¥ ch·ª©c nƒÉng
     * @param {string} title - Ti√™u ƒë·ªÅ modal
     * @param {string} icon - Icon hi·ªÉn th·ªã
     * @param {string} description - M√¥ t·∫£ ng·∫Øn
     * @param {string} effect - Chi ti·∫øt hi·ªáu ·ª©ng
     */
    function showActivationModal(title, icon, description, effect) {
        if (!activationModal) return;
        
        document.getElementById('activation-title').textContent = title;
        document.getElementById('activation-icon').textContent = icon;
        document.getElementById('activation-description').textContent = description;
        document.getElementById('activation-effect').textContent = effect;
        
        activationModal.style.display = 'flex';
    }
    
    /**
     * ƒê√≥ng modal th√¥ng b√°o k√≠ch ho·∫°t
     */
    function closeActivationModal() {
        if (activationModal) {
            activationModal.style.display = 'none';
        }
    }
    
    /**
     * Ki·ªÉm tra xem qu√¢n c·ªù c√≥ th·ªÉ k√≠ch ho·∫°t √¥ ƒë·∫∑c bi·ªát kh√¥ng
     * @param {Object} piece - Qu√¢n c·ªù c·∫ßn ki·ªÉm tra
     * @returns {boolean}
     */
    function canPieceActivate(piece) {
        if (!piece) return false;
        
        // C·ªù t∆∞·ªõng: b·∫•t k·ª≥ qu√¢n n√†o
        if (piece.side === 'xiangqi') return true;
        
        // C·ªù vua: ch·ªâ Vua
        if (piece.side === 'chess' && piece.type === 'king') return true;
        
        return false;
    }
    
    /**
     * Hi·ªáu ·ª©ng flash cho √¥ ƒë·∫∑c bi·ªát khi ƒë∆∞·ª£c k√≠ch ho·∫°t
     */
    function flashSpecialTile() {
        setTimeout(() => {
            const squareIdx = SPECIAL_TILE.r * COLS + SPECIAL_TILE.c;
            if (boardEl && boardEl.children[squareIdx]) {
                const square = boardEl.children[squareIdx];
                square.classList.add('special-tile-activated');
                setTimeout(() => {
                    square.classList.remove('special-tile-activated');
                }, 1000);
            }
        }, 100);
    }
    
    // ========== BOT AI ==========
    function botMakeMove() {
        if (isGameOver || currentTurn !== botSide || !isBotMode) {
            console.log('Bot cannot move:', { isGameOver, currentTurn, botSide, isBotMode });
            return;
        }
        
        console.log('Bot making move...', { botSide, currentTurn });
        
        // T√¨m t·∫•t c·∫£ c√°c n∆∞·ªõc ƒëi h·ª£p l·ªá c·ªßa BOT
        const botPieces = pieces.filter(p => p.side === botSide);
        const allMoves = [];
        
        for (const piece of botPieces) {
            const moves = getSafeMoves(piece);
            for (const move of moves) {
                allMoves.push({ piece, move });
            }
        }
        
        console.log('Bot found moves:', allMoves.length);
        
        if (allMoves.length === 0) {
            // Ki·ªÉm tra xem c√≥ ph·∫£i l√† chi·∫øu b√≠ kh√¥ng
            if (isKingInCheck(botSide)) {
                // BOT b·ªã chi·∫øu b√≠ - ng∆∞·ªùi ch∆°i th·∫Øng
                isGameOver = true;
                document.getElementById("winner-text").innerText = "B·∫†N TH·∫ÆNG!";
                document.getElementById("game-over").style.display = "flex";
                drawBoard();
                return;
            } else {
                // H√≤a c·ªù (stalemate) - kh√¥ng c√≥ n∆∞·ªõc ƒëi h·ª£p l·ªá nh∆∞ng kh√¥ng b·ªã chi·∫øu
                isGameOver = true;
                document.getElementById("winner-text").innerText = "H√íA C·ªú!";
                document.getElementById("game-over").style.display = "flex";
                drawBoard();
                return;
            }
        }
        
        // ƒê√°nh gi√° v√† s·∫Øp x·∫øp c√°c n∆∞·ªõc ƒëi theo ƒëi·ªÉm s·ªë
        const scoredMoves = allMoves.map(({ piece, move }) => {
            let score = 0;
            
            // 1. Ki·ªÉm tra chi·∫øu b√≠ - ƒëi·ªÉm cao nh·∫•t
            const testPieces = JSON.parse(JSON.stringify(pieces));
            const testPiece = testPieces.find(p => p.r === piece.r && p.c === piece.c);
            const targetPiece = testPieces.find(p => p.r === move.r && p.c === move.c);
            
            if (targetPiece && targetPiece.side !== botSide) {
                testPieces.splice(testPieces.indexOf(targetPiece), 1);
            }
            testPiece.r = move.r;
            testPiece.c = move.c;
            
            const opponentSide = botSide === "chess" ? "xiangqi" : "chess";
            // Ki·ªÉm tra chi·∫øu v·ªõi testPieces
            if (isKingInCheck(opponentSide, testPieces)) {
                // Ki·ªÉm tra xem c√≥ ph·∫£i chi·∫øu b√≠ kh√¥ng (t·∫•t c·∫£ n∆∞·ªõc ƒëi ƒë·ªÅu kh√¥ng h·ª£p l·ªá)
                let opponentPieces = testPieces.filter(p => p.side === opponentSide);
                let hasValidMove = false;
                for (let oppPiece of opponentPieces) {
                    let moves = getPseudoMoves(oppPiece, testPieces);
                    for (let m of moves) {
                        // Test move
                        let oldR = oppPiece.r, oldC = oppPiece.c;
                        let capIdx = testPieces.findIndex(t => t.r === m.r && t.c === m.c);
                        let capPiece = null;
                        if (capIdx !== -1) { capPiece = testPieces[capIdx]; testPieces.splice(capIdx, 1); }
                        oppPiece.r = m.r; oppPiece.c = m.c;
                        let safe = !isKingInCheck(opponentSide, testPieces);
                        oppPiece.r = oldR; oppPiece.c = oldC;
                        if (capPiece) testPieces.splice(capIdx, 0, capPiece);
                        if (safe) {
                            hasValidMove = true;
                            break;
                        }
                    }
                    if (hasValidMove) break;
                }
                if (!hasValidMove) {
                    score += 10000; // Chi·∫øu b√≠ - ƒëi·ªÉm cao nh·∫•t
                } else {
                    score += 500; // Chi·∫øu - ƒëi·ªÉm cao
                }
            }
            
            // 2. ƒÇn qu√¢n ƒë·ªëi th·ªß - t√≠nh theo gi√° tr·ªã
            if (targetPiece && targetPiece.side !== botSide) {
                const captureValue = getPieceValue(targetPiece);
                const attackerValue = getPieceValue(piece);
                // ∆Øu ti√™n ƒÉn qu√¢n gi√° tr·ªã cao, nh∆∞ng tr√°nh ƒë·ªïi qu√¢n gi√° tr·ªã cao h∆°n
                if (captureValue >= attackerValue) {
                    score += captureValue * 100; // ƒÇn qu√¢n c√≥ gi√° tr·ªã b·∫±ng ho·∫∑c cao h∆°n
                } else {
                    score += captureValue * 50; // ƒÇn qu√¢n c√≥ gi√° tr·ªã th·∫•p h∆°n
                }
            }
            
            // 3. Tr√°nh ƒë·ªÉ qu√¢n b·ªã ƒÉn - ki·ªÉm tra sau khi ƒëi
            const wouldBeAttacked = isSquareAttacked(move.r, move.c, botSide, testPieces);
            if (wouldBeAttacked) {
                score -= getPieceValue(piece) * 30; // Tr·ª´ ƒëi·ªÉm n·∫øu qu√¢n c√≥ th·ªÉ b·ªã ƒÉn
            }
            
            // 4. Ki·ªÉm so√°t trung t√¢m - ƒëi·ªÉm bonus
            const centerBonus = getCenterControl(move.r, move.c);
            score += centerBonus;
            
            // 5. Ph√°t tri·ªÉn qu√¢n - di chuy·ªÉn qu√¢n t·ª´ h√†ng ƒë·∫ßu
            if (piece.side === "chess") {
                if (piece.r === 0 || piece.r === 1) {
                    score += 10; // Ph√°t tri·ªÉn qu√¢n c·ªù Vua
                }
            } else {
                if (piece.r === 9 || piece.r === 8 || piece.r === 7) {
                    score += 10; // Ph√°t tri·ªÉn qu√¢n c·ªù T∆∞·ªõng
                }
            }
            
            // 6. T·∫•n c√¥ng qu√¢n ƒë·ªëi th·ªß - ƒëi·ªÉm bonus
            const attackScore = getAttackScore(move.r, move.c, opponentSide, testPieces);
            score += attackScore * 5;
            
            // 7. B·∫£o v·ªá qu√¢n c·ªßa m√¨nh - ƒëi·ªÉm bonus
            const defenseScore = getDefenseScore(move.r, move.c, botSide, testPieces);
            score += defenseScore * 3;
            
            // 8. ƒê√°nh gi√° ƒëi·ªÉm v·ªã tr√≠ c·ªßa qu√¢n sau khi di chuy·ªÉn
            const positionScore = getPositionScore(piece, move.r, move.c);
            score += positionScore * 10;
            
            // 9. ƒê√°nh gi√° t·ªïng th·ªÉ b√†n c·ªù sau n∆∞·ªõc ƒëi (heuristic evaluation)
            const boardEvaluation = evaluateBoard(testPieces, botSide);
            score += boardEvaluation * 0.1; // Th√™m ƒëi·ªÉm ƒë√°nh gi√° t·ªïng th·ªÉ
            
            return { piece, move, score };
        });
        
        // S·∫Øp x·∫øp theo ƒëi·ªÉm s·ªë gi·∫£m d·∫ßn
        scoredMoves.sort((a, b) => b.score - a.score);
        
        // Ch·ªçn n∆∞·ªõc ƒëi d·ª±a tr√™n ƒë·ªô kh√≥ bot
        let chosenMove;
        if (botDifficulty === 'easy') {
            // D·ªÖ: ch·ªçn ng·∫´u nhi√™n t·ª´ top 50% n∆∞·ªõc ƒëi (c√≥ th·ªÉ ch·ªçn n∆∞·ªõc ƒëi kh√¥ng t·ªët)
            const randomIndex = Math.floor(Math.random() * Math.min(scoredMoves.length, Math.max(1, Math.floor(scoredMoves.length * 0.5))));
            chosenMove = scoredMoves[randomIndex];
        } else if (botDifficulty === 'medium') {
            // Trung b√¨nh: ch·ªçn ng·∫´u nhi√™n t·ª´ top 3-5 n∆∞·ªõc ƒëi t·ªët nh·∫•t
            const topMoves = scoredMoves.filter(m => m.score >= scoredMoves[0].score - 100);
            const randomIndex = Math.floor(Math.random() * Math.min(topMoves.length, 5));
            chosenMove = topMoves[randomIndex];
        } else {
            // Kh√≥: ch·ªçn n∆∞·ªõc ƒëi t·ªët nh·∫•t ho·∫∑c g·∫ßn t·ªët nh·∫•t
            const topMoves = scoredMoves.filter(m => m.score >= scoredMoves[0].score - 50);
            if (topMoves.length > 1 && scoredMoves[0].score < 500) {
                chosenMove = topMoves[Math.floor(Math.random() * Math.min(topMoves.length, 3))];
            } else {
                chosenMove = scoredMoves[0]; // Ch·ªçn n∆∞·ªõc ƒëi t·ªët nh·∫•t
            }
        }
        
        // Th·ª±c hi·ªán n∆∞·ªõc ƒëi
        const { piece, move } = chosenMove;
        selectedPiece = piece;
        
        // T√¨m qu√¢n b·ªã ƒÉn (n·∫øu c√≥)
        const targetIdx = pieces.findIndex(p => p.r === move.r && p.c === move.c);
        let captured = null;
        if (targetIdx !== -1) {
            captured = pieces[targetIdx];
            
            pieces.splice(targetIdx, 1);
            if (captured.side === "chess") deadChess.push(captured.type);
            else deadXQ.push(captured.type);
            playSound('capture');
        } else {
            playSound('move');
        }
        
        // X·ª≠ l√Ω nh·∫≠p th√†nh (castling) cho c·ªù Vua
        if (move.isCastle) {
            if (move.c === 6) {
                const rook = pieces.find(p => p.r === (botSide === "chess" ? 0 : 9) && p.c === 7);
                if (rook) { rook.c = 5; rook.hasMoved = true; }
            }
            if (move.c === 2) {
                const rook = pieces.find(p => p.r === (botSide === "chess" ? 0 : 9) && p.c === 0);
                if (rook) { rook.c = 3; rook.hasMoved = true; }
            }
        }
        
        // X·ª≠ l√Ω ƒÉn en passant cho BOT
        if (move.isEnPassantCapture && move.enPassantTarget) {
            const enPassantPieceIdx = pieces.findIndex(p => 
                p.r === move.enPassantTarget.r && 
                p.c === move.enPassantTarget.c &&
                p.type === "pawn" &&
                p.side !== piece.side
            );
            if (enPassantPieceIdx !== -1) {
                let captured = pieces[enPassantPieceIdx];
                pieces.splice(enPassantPieceIdx, 1);
                if (captured.side === "chess") deadChess.push(captured.type);
                else deadXQ.push(captured.type);
                playSound('capture');
            }
        }
        
        // C·∫≠p nh·∫≠t v·ªã tr√≠ qu√¢n c·ªù
        lastMove = { from: {r: piece.r, c: piece.c}, to: {r: move.r, c: move.c} };
        piece.r = move.r;
        piece.c = move.c;
        if (piece.type === "king" || piece.type === "rook") piece.hasMoved = true;
        
        // X√≥a khi√™n c·ªßa t·ªët c·ªù vua khi di chuy·ªÉn
        if (piece.type === "pawn" && piece.side === "chess") {
            piece.hasMoved = true;
            piece.hasShield = false; // M·∫•t khi√™n khi di chuy·ªÉn
        }
        
        // L∆∞u th√¥ng tin en passant target n·∫øu t·ªët ƒëi 2 √¥
        if (piece.side === "chess" && piece.type === "pawn" && move.isEnPassantMove) {
            enPassantTarget = {r: 3, c: move.c};
        } else {
            enPassantTarget = null;
        }
        
        // X·ª≠ l√Ω phong c·∫•p t·ªët c·ªù Vua
        if (piece.side === "chess" && piece.type === "pawn" && move.r === 9) {
            // BOT t·ª± ƒë·ªông ch·ªçn H·∫≠u
            piece.type = "queen";
        }
        
        // C·∫≠p nh·∫≠t lastMove
        lastMove = { from: {r: piece.r, c: piece.c}, to: {r: move.r, c: move.c} };
        
        // V·∫Ω l·∫°i b√†n c·ªù tr∆∞·ªõc khi k·∫øt th√∫c l∆∞·ª£t
        drawBoard();
        
        // K·∫øt th√∫c l∆∞·ª£t
        finishTurn();
    }
    
    // ========== BOT DIFFICULTY ==========
    let botDifficulty = 'medium'; // 'easy', 'medium', 'hard'
    
    function getPieceValue(piece) {
        if (!piece) return 0;
        const values = {
            // C·ªù Vua
            "pawn": 1, "knight": 3, "bishop": 3, "rook": 5, "queen": 9, "king": 100,
            // C·ªù T∆∞·ªõng
            "t·ªët": 1, "m√£": 4, "t∆∞·ª£ng": 2, "sƒ©": 2, "xe": 9, "ph√°o": 4.5, "t∆∞·ªõng": 100
        };
        return values[piece.type] || 0;
    }
    
    // H√†m ƒë√°nh gi√° ƒëi·ªÉm theo v·ªã tr√≠ c·ªßa t·ª´ng qu√¢n c·ªù
    function getPositionScore(piece, r, c) {
        if (!piece) return 0;
        let score = 0;
        
        // B·∫£ng ƒëi·ªÉm v·ªã tr√≠ cho c·ªù Vua
        if (piece.side === "chess") {
            if (piece.type === "pawn") {
                // T·ªët c·ªù vua: t·ªët nh·∫•t ·ªü h√†ng 6-7 (g·∫ßn phong c·∫•p)
                const pawnTable = [
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [5, 5, 5, 5, 5, 5, 5, 5, 5],
                    [1, 1, 2, 3, 3, 3, 2, 1, 1],
                    [0.5, 0.5, 1, 2.5, 2.5, 2.5, 1, 0.5, 0.5],
                    [0, 0, 0, 2, 2, 2, 0, 0, 0],
                    [0.5, -0.5, -1, 0, 0, 0, -1, -0.5, 0.5],
                    [0.5, 1, 1, -2, -2, -2, 1, 1, 0.5],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0]
                ];
                score += pawnTable[r] ? (pawnTable[r][c] || 0) : 0;
            } else if (piece.type === "knight") {
                // M√£: t·ªët nh·∫•t ·ªü trung t√¢m
                const knightTable = [
                    [-5, -4, -3, -3, -3, -3, -3, -4, -5],
                    [-4, -2, 0, 0, 0, 0, 0, -2, -4],
                    [-3, 0, 1, 1.5, 1.5, 1.5, 1, 0, -3],
                    [-3, 0.5, 1.5, 2, 2, 2, 1.5, 0.5, -3],
                    [-3, 0, 1.5, 2, 2, 2, 1.5, 0, -3],
                    [-3, 0.5, 1, 1.5, 1.5, 1.5, 1, 0.5, -3],
                    [-4, -2, 0, 0.5, 0.5, 0.5, 0, -2, -4],
                    [-5, -4, -3, -3, -3, -3, -3, -4, -5],
                    [-5, -4, -3, -3, -3, -3, -3, -4, -5],
                    [-5, -4, -3, -3, -3, -3, -3, -4, -5]
                ];
                score += knightTable[r] ? (knightTable[r][c] || 0) : 0;
            } else if (piece.type === "bishop") {
                // T∆∞·ª£ng: t·ªët nh·∫•t ·ªü ƒë∆∞·ªùng ch√©o trung t√¢m
                const bishopTable = [
                    [-2, -1, -1, -1, -1, -1, -1, -1, -2],
                    [-1, 0, 0, 0, 0, 0, 0, 0, -1],
                    [-1, 0, 0.5, 1, 1, 1, 0.5, 0, -1],
                    [-1, 0.5, 0.5, 1, 1, 1, 0.5, 0.5, -1],
                    [-1, 0, 1, 1, 1, 1, 1, 0, -1],
                    [-1, 1, 1, 1, 1, 1, 1, 1, -1],
                    [-1, 0.5, 0, 0, 0, 0, 0, 0.5, -1],
                    [-2, -1, -1, -1, -1, -1, -1, -1, -2],
                    [-2, -1, -1, -1, -1, -1, -1, -1, -2],
                    [-2, -1, -1, -1, -1, -1, -1, -1, -2]
                ];
                score += bishopTable[r] ? (bishopTable[r][c] || 0) : 0;
            } else if (piece.type === "rook") {
                // Xe: t·ªët nh·∫•t ·ªü h√†ng/c·ªôt m·ªü
                const rookTable = [
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0.5, 1, 1, 1, 1, 1, 1, 1, 0.5],
                    [-0.5, 0, 0, 0, 0, 0, 0, 0, -0.5],
                    [-0.5, 0, 0, 0, 0, 0, 0, 0, -0.5],
                    [-0.5, 0, 0, 0, 0, 0, 0, 0, -0.5],
                    [-0.5, 0, 0, 0, 0, 0, 0, 0, -0.5],
                    [-0.5, 0, 0, 0, 0, 0, 0, 0, -0.5],
                    [0, 0, 0, 0.5, 0.5, 0.5, 0, 0, 0],
                    [0, 0, 0, 0.5, 0.5, 0.5, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0]
                ];
                score += rookTable[r] ? (rookTable[r][c] || 0) : 0;
            } else if (piece.type === "queen") {
                // H·∫≠u: t·ªët nh·∫•t ·ªü trung t√¢m
                const queenTable = [
                    [-2, -1, -1, -0.5, -0.5, -0.5, -1, -1, -2],
                    [-1, 0, 0, 0, 0, 0, 0, 0, -1],
                    [-1, 0, 0.5, 0.5, 0.5, 0.5, 0.5, 0, -1],
                    [-0.5, 0, 0.5, 0.5, 0.5, 0.5, 0.5, 0, -0.5],
                    [0, 0, 0.5, 0.5, 0.5, 0.5, 0.5, 0, 0],
                    [-0.5, 0, 0.5, 0.5, 0.5, 0.5, 0.5, 0, -0.5],
                    [-1, 0, 0.5, 0.5, 0.5, 0.5, 0.5, 0, -1],
                    [-1, 0, 0, 0, 0, 0, 0, 0, -1],
                    [-2, -1, -1, -0.5, -0.5, -0.5, -1, -1, -2],
                    [-2, -1, -1, -0.5, -0.5, -0.5, -1, -1, -2]
                ];
                score += queenTable[r] ? (queenTable[r][c] || 0) : 0;
            } else if (piece.type === "king") {
                // Vua: t·ªët nh·∫•t ·ªü g√≥c khi m·ªü ƒë·∫ßu, ·ªü gi·ªØa khi t√†n cu·ªôc
                const kingTable = [
                    [-3, -4, -4, -5, -5, -5, -4, -4, -3],
                    [-3, -4, -4, -5, -5, -5, -4, -4, -3],
                    [-3, -4, -4, -5, -5, -5, -4, -4, -3],
                    [-3, -4, -4, -5, -5, -5, -4, -4, -3],
                    [-2, -3, -3, -4, -4, -4, -3, -3, -2],
                    [-1, -2, -2, -2, -2, -2, -2, -2, -1],
                    [2, 2, 0, 0, 0, 0, 0, 2, 2],
                    [2, 3, 1, 0, 0, 0, 1, 3, 2],
                    [3, 4, 2, 0, 0, 0, 2, 4, 3],
                    [3, 4, 2, 0, 0, 0, 2, 4, 3]
                ];
                score += kingTable[r] ? (kingTable[r][c] || 0) : 0;
            }
        } else if (piece.side === "xiangqi") {
            // B·∫£ng ƒëi·ªÉm v·ªã tr√≠ cho c·ªù T∆∞·ªõng
            if (piece.type === "t·ªët") {
                // T·ªët c·ªù t∆∞·ªõng: t·ªët nh·∫•t khi qua s√¥ng v√† ti·∫øn v·ªÅ ph√≠a ƒë·ªëi th·ªß
                const xqPawnTable = [
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0]
                ];
                // T·ªët qua s√¥ng (r < 5) c√≥ gi√° tr·ªã cao h∆°n
                if (r < 5) {
                    score += 2; // Qua s√¥ng
                    if (r < 3) score += 1; // G·∫ßn ƒë·ªëi th·ªß
                }
            } else if (piece.type === "m√£") {
                // M√£ c·ªù t∆∞·ªõng: t·ªët nh·∫•t ·ªü trung t√¢m v√† g·∫ßn ƒë·ªëi th·ªß
                const xqKnightTable = [
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 1, 1, 1, 1, 1, 0, 0],
                    [0, 0, 1, 2, 2, 2, 1, 0, 0],
                    [0, 0, 1, 2, 2, 2, 1, 0, 0],
                    [0, 0, 1, 2, 2, 2, 1, 0, 0],
                    [0, 0, 1, 1, 1, 1, 1, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0]
                ];
                score += xqKnightTable[r] ? (xqKnightTable[r][c] || 0) : 0;
            } else if (piece.type === "xe") {
                // Xe c·ªù t∆∞·ªõng: t·ªët nh·∫•t ·ªü h√†ng/c·ªôt m·ªü v√† g·∫ßn ƒë·ªëi th·ªß
                const xqRookTable = [
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 1, 1, 1, 1, 1, 0, 0],
                    [0, 0, 1, 1, 1, 1, 1, 0, 0],
                    [0, 0, 1, 1, 1, 1, 1, 0, 0],
                    [0, 0, 1, 1, 1, 1, 1, 0, 0],
                    [0, 0, 1, 1, 1, 1, 1, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0]
                ];
                score += xqRookTable[r] ? (xqRookTable[r][c] || 0) : 0;
            } else if (piece.type === "ph√°o") {
                // Ph√°o: t·ªët nh·∫•t ·ªü h√†ng sau v√† trung t√¢m
                const xqCannonTable = [
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0]
                ];
                // Ph√°o t·ªët nh·∫•t ·ªü h√†ng sau (r >= 7) v√† trung t√¢m
                if (r >= 7 && c >= 3 && c <= 5) score += 1;
            }
        }
        
        return score;
    }
    
    // H√†m ƒë√°nh gi√° t·ªïng th·ªÉ cho m·ªôt tr·∫°ng th√°i b√†n c·ªù
    function evaluateBoard(_pieces = pieces, side = botSide) {
        let totalScore = 0;
        const opponentSide = side === "chess" ? "xiangqi" : "chess";
        
        // T√≠nh ƒëi·ªÉm cho t·ª´ng qu√¢n c·ªù
        for (const piece of _pieces) {
            if (piece.side === side) {
                // ƒêi·ªÉm gi√° tr·ªã qu√¢n c·ªù
                totalScore += getPieceValue(piece) * 100;
                // ƒêi·ªÉm v·ªã tr√≠
                totalScore += getPositionScore(piece, piece.r, piece.c) * 10;
            } else if (piece.side === opponentSide) {
                // Tr·ª´ ƒëi·ªÉm c·ªßa ƒë·ªëi th·ªß
                totalScore -= getPieceValue(piece) * 100;
                totalScore -= getPositionScore(piece, piece.r, piece.c) * 10;
            }
        }
        
        return totalScore;
    }
    
    // H√†m helper ƒë·ªÉ ki·ªÉm tra √¥ c√≥ b·ªã t·∫•n c√¥ng kh√¥ng
    // H√†m t√≠nh ƒëi·ªÉm ki·ªÉm so√°t trung t√¢m
    function getCenterControl(r, c) {
        // Trung t√¢m b√†n c·ªù l√† c√°c √¥ quanh v·ªã tr√≠ (4-5, 4-5)
        const centerRows = [4, 5];
        const centerCols = [3, 4, 5, 6];
        
        if (centerRows.includes(r) && centerCols.includes(c)) {
            return 15; // √î trung t√¢m ch√≠nh
        } else if (Math.abs(r - 4.5) <= 2 && Math.abs(c - 4.5) <= 2) {
            return 8; // √î g·∫ßn trung t√¢m
        }
        return 0;
    }
    
    // H√†m t√≠nh ƒëi·ªÉm t·∫•n c√¥ng (s·ªë qu√¢n ƒë·ªëi th·ªß c√≥ th·ªÉ b·ªã t·∫•n c√¥ng t·ª´ √¥ n√†y)
    function getAttackScore(r, c, opponentSide, _pieces = pieces) {
        let score = 0;
        const testPieces = JSON.parse(JSON.stringify(_pieces));
        
        // T·∫°o m·ªôt qu√¢n c·ªù t·∫°m t·∫°i v·ªã tr√≠ n√†y ƒë·ªÉ ki·ªÉm tra
        const tempPiece = { r, c, side: botSide, type: "queen" }; // D√πng queen ƒë·ªÉ ki·ªÉm tra nhi·ªÅu h∆∞·ªõng
        testPieces.push(tempPiece);
        
        const moves = getPseudoMoves(tempPiece, testPieces);
        for (const move of moves) {
            const targetPiece = _pieces.find(p => p.r === move.r && p.c === move.c && p.side === opponentSide);
            if (targetPiece) {
                score += getPieceValue(targetPiece);
            }
        }
        
        return score;
    }
    
    // H√†m t√≠nh ƒëi·ªÉm ph√≤ng th·ªß (s·ªë qu√¢n c·ªßa m√¨nh ƒë∆∞·ª£c b·∫£o v·ªá t·ª´ √¥ n√†y)
    function getDefenseScore(r, c, mySide, _pieces = pieces) {
        let score = 0;
        const testPieces = JSON.parse(JSON.stringify(_pieces));
        
        // T·∫°o m·ªôt qu√¢n c·ªù t·∫°m t·∫°i v·ªã tr√≠ n√†y ƒë·ªÉ ki·ªÉm tra
        const tempPiece = { r, c, side: mySide, type: "queen" };
        testPieces.push(tempPiece);
        
        const moves = getPseudoMoves(tempPiece, testPieces);
        for (const move of moves) {
            const targetPiece = _pieces.find(p => p.r === move.r && p.c === move.c && p.side === mySide);
            if (targetPiece) {
                score += getPieceValue(targetPiece) * 0.5; // B·∫£o v·ªá qu√¢n c√≥ gi√° tr·ªã
            }
        }
        
        return score;
    }
    

    // --- HISTORY ---
    // T·∫°o hash t·ª´ tr·∫°ng th√°i b√†n c·ªù ƒë·ªÉ ki·ªÉm tra l·∫∑p l·∫°i
    function getBoardHash(_pieces = pieces, _currentTurn = currentTurn) {
        // S·∫Øp x·∫øp c√°c qu√¢n c·ªù theo th·ª© t·ª± ƒë·ªÉ ƒë·∫£m b·∫£o hash nh·∫•t qu√°n
        const sortedPieces = JSON.parse(JSON.stringify(_pieces)).sort((a, b) => {
            if (a.r !== b.r) return a.r - b.r;
            if (a.c !== b.c) return a.c - b.c;
            if (a.side !== b.side) return a.side.localeCompare(b.side);
            return a.type.localeCompare(b.type);
        });
        
        // T·∫°o hash t·ª´ v·ªã tr√≠ v√† lo·∫°i qu√¢n c·ªù
        const hash = sortedPieces.map(p => `${p.side}-${p.type}-${p.r}-${p.c}`).join('|') + `|turn:${_currentTurn}`;
        return hash;
    }
    
    // Ki·ªÉm tra xem tr·∫°ng th√°i hi·ªán t·∫°i ƒë√£ l·∫∑p l·∫°i bao nhi√™u l·∫ßn
    function checkThreefoldRepetition() {
        const currentHash = getBoardHash();
        
        // ƒê·∫øm s·ªë l·∫ßn tr·∫°ng th√°i n√†y xu·∫•t hi·ªán trong l·ªãch s·ª≠
        let count = 0;
        for (let i = 0; i < positionHistory.length; i++) {
            if (positionHistory[i] === currentHash) {
                count++;
            }
        }
        
        // N·∫øu tr·∫°ng th√°i xu·∫•t hi·ªán 4 l·∫ßn (bao g·ªìm l·∫ßn hi·ªán t·∫°i), h√≤a c·ªù
        if (count >= 3) { // count >= 3 nghƒ©a l√† ƒë√£ c√≥ 4 l·∫ßn (3 l·∫ßn tr∆∞·ªõc + 1 l·∫ßn hi·ªán t·∫°i)
            return true;
        }
        
        return false;
    }
    
    function saveState() {
        const state = {
            pieces: JSON.parse(JSON.stringify(pieces)),
            deadChess: [...deadChess], deadXQ: [...deadXQ],
            turn: currentTurn, lastMove: lastMove ? {...lastMove} : null, isGameOver: isGameOver
        };
        gameHistory.push(state);
        viewIndex = gameHistory.length - 1;
        
        // L∆∞u hash c·ªßa tr·∫°ng th√°i hi·ªán t·∫°i v√†o l·ªãch s·ª≠
        const currentHash = getBoardHash();
        positionHistory.push(currentHash);
        
        updateControls();
    }

    function reviewMove(step) {
        // T·∫°m d·ª´ng timer khi review
        timerPaused = true;
        
        let newIndex = viewIndex + step;
        if (newIndex >= 0 && newIndex < gameHistory.length) {
            viewIndex = newIndex; isReviewing = (viewIndex !== gameHistory.length - 1);
            drawBoard(gameHistory[viewIndex]); updateControls();
        }
    }

    function returnToLive() {
        viewIndex = gameHistory.length - 1; isReviewing = false;
        timerPaused = false; // Ti·∫øp t·ª•c timer khi quay l·∫°i live
        drawBoard(gameHistory[viewIndex]); updateControls();
        updateStatusUI(currentTurn, pieces);
    }
    
    // ========== UNDO FUNCTION (for bot mode) ==========
    function undoMove() {
        if (isReviewing || isGameOver || pendingPromotion) return;
        
        // Ch·ªâ cho ph√©p undo trong ch·∫ø ƒë·ªô bot v√† khi kh√¥ng ph·∫£i l∆∞·ª£t bot
        if (!isBotMode || currentTurn === botSide) {
            if (msgEl) {
                msgEl.innerText = 'Ch·ªâ c√≥ th·ªÉ ƒëi l·∫°i khi ƒë·∫øn l∆∞·ª£t b·∫°n!';
                msgEl.style.color = '#e74c3c';
                setTimeout(() => {
                    if (msgEl) {
                        msgEl.innerText = '';
                        msgEl.style.color = '';
                    }
                }, 2000);
            }
            return;
        }
        
        // C·∫ßn √≠t nh·∫•t 2 tr·∫°ng th√°i ƒë·ªÉ undo (hi·ªán t·∫°i v√† tr∆∞·ªõc ƒë√≥)
        if (gameHistory.length < 2) {
            if (msgEl) {
                msgEl.innerText = 'Kh√¥ng th·ªÉ ƒëi l·∫°i!';
                msgEl.style.color = '#e74c3c';
                setTimeout(() => {
                    if (msgEl) {
                        msgEl.innerText = '';
                        msgEl.style.color = '';
                    }
                }, 2000);
            }
            return;
        }
        
        // X√≥a 2 tr·∫°ng th√°i cu·ªëi (n∆∞·ªõc ƒëi c·ªßa bot v√† c·ªßa ng∆∞·ªùi ch∆°i)
        gameHistory.pop(); // X√≥a tr·∫°ng th√°i hi·ªán t·∫°i
        gameHistory.pop(); // X√≥a tr·∫°ng th√°i tr∆∞·ªõc ƒë√≥
        
        // Rebuild positionHistory t·ª´ gameHistory ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh nh·∫•t qu√°n
        positionHistory = [];
        for (let i = 0; i < gameHistory.length; i++) {
            const state = gameHistory[i];
            // T·∫°m th·ªùi set pieces v√† currentTurn ƒë·ªÉ t√≠nh hash
            const tempPieces = pieces;
            const tempTurn = currentTurn;
            pieces = state.pieces;
            currentTurn = state.turn;
            positionHistory.push(getBoardHash());
            pieces = tempPieces;
            currentTurn = tempTurn;
        }
        
        if (gameHistory.length > 0) {
            // Kh√¥i ph·ª•c v·ªÅ tr·∫°ng th√°i tr∆∞·ªõc ƒë√≥
            const previousState = gameHistory[gameHistory.length - 1];
            pieces = JSON.parse(JSON.stringify(previousState.pieces));
            deadChess = [...previousState.deadChess];
            deadXQ = [...previousState.deadXQ];
            currentTurn = previousState.turn;
            lastMove = previousState.lastMove;
            isGameOver = previousState.isGameOver;
            selectedPiece = null;
            validMoves = [];
            viewIndex = gameHistory.length - 1;
            isReviewing = false;
            
            drawBoard();
            updateControls();
            updateStatusUI();
            
            if (msgEl) {
                msgEl.innerText = 'ƒê√£ ƒëi l·∫°i!';
                msgEl.style.color = '#2ecc71';
                setTimeout(() => {
                    if (msgEl) {
                        msgEl.innerText = '';
                        msgEl.style.color = '';
                    }
                }, 2000);
            }
        } else {
            // N·∫øu kh√¥ng c√≤n l·ªãch s·ª≠, reset v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu
            pieces = JSON.parse(JSON.stringify(INITIAL_SETUP));
            deadChess = [];
            deadXQ = [];
            currentTurn = 'chess';
            lastMove = null;
            isGameOver = false;
            selectedPiece = null;
            validMoves = [];
            gameHistory = [];
            positionHistory = []; // Reset position history
            viewIndex = -1;
            isReviewing = false;
            
            drawBoard();
            updateControls();
            updateStatusUI();
        }
    }
    
    // ========== KEYBOARD SHORTCUTS ==========
    document.addEventListener('keydown', function(event) {
        // Ch·ªâ x·ª≠ l√Ω khi kh√¥ng ƒëang nh·∫≠p text
        const activeElement = document.activeElement;
        if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
            return;
        }
        
        const key = event.key.toLowerCase();
        
        // Z - Undo (ƒëi l·∫°i) - ch·ªâ trong ch·∫ø ƒë·ªô bot
        if (key === 'z' && !event.ctrlKey && !event.metaKey && !event.shiftKey && !event.altKey) {
            event.preventDefault();
            undoMove();
        }
        
        // R - Reset game
        if (key === 'r' && !event.ctrlKey && !event.metaKey && !event.shiftKey && !event.altKey) {
            event.preventDefault();
            if (!isReviewing && !pendingPromotion) {
                if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën reset l·∫°i game kh√¥ng?')) {
                    resetToMenu();
                }
            }
        }
        
        // S - Surrender (ƒë·∫ßu h√†ng)
        if (key === 's' && !event.ctrlKey && !event.metaKey && !event.shiftKey && !event.altKey) {
            event.preventDefault();
            if (!isReviewing && !pendingPromotion && !isGameOver) {
                resignGame();
            }
        }
        
        // D - Draw (xin h√≤a)
        if (key === 'd' && !event.ctrlKey && !event.metaKey && !event.shiftKey && !event.altKey) {
            event.preventDefault();
            if (!isReviewing && !pendingPromotion && !isGameOver) {
                offerDraw();
            }
        }
    });

    function updateControls() {
        btnPrev.disabled = viewIndex <= 0; btnNext.disabled = viewIndex >= gameHistory.length - 1;
        if (isReviewing) {
            btnLive.classList.remove("active-live"); btnLive.innerText = "QUAY L·∫†I"; boardEl.style.borderColor = "#f1c40f";
        } else {
            btnLive.classList.add("active-live"); btnLive.innerText = "LIVE"; boardEl.style.borderColor = "#333";
        }
    }

    // --- DRAWING ---
    function drawBoard(state = null) {
        if (!state) state = { pieces, deadChess, deadXQ, turn: currentTurn, lastMove };
        const { pieces: rPieces, turn: rTurn, deadChess: rDC, deadXQ: rDX, lastMove: rLM } = state;

        boardEl.innerHTML = "";
        
        if (isReviewing) {
            turnBadge.innerText = `XEM L·∫†I (${viewIndex}/${gameHistory.length-1})`;
            turnBadge.style.background = "#555"; turnBadge.style.color = "#ccc";
        } else {
            updateStatusUI(rTurn, rPieces);
        }

        // Draw Grid v·ªõi c√°c marker v√† styling m·ªõi
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                let square = document.createElement("div"); 
                square.className = "square";
                
                // Dark squares cho ph·∫ßn tr√™n (C·ªù Vua)
                if (r < 4 && (r + c) % 2 === 1) square.classList.add("dark");
                
                // River ·ªü gi·ªØa (h√†ng 4)
                if (r === 4) { 
                    square.classList.add("river"); 
                    square.innerHTML = "<span>S·ªû H√Ä - H√ÅN GI·ªöI</span>"; 
                }
                
                // Dark squares cho ph·∫ßn d∆∞·ªõi (C·ªù T∆∞·ªõng)
                if (r > 4 && (r + c) % 2 === 1) square.classList.add("dark");
                
                // Marker "L" cho Cannon (h√†ng 1 v√† 8, c·ªôt 1 v√† 7)
                if ((r === 1 || r === 8) && (c === 1 || c === 7)) {
                    if (r === 1 && c === 1) square.classList.add("marker", "marker-top-left");
                    else if (r === 1 && c === 7) square.classList.add("marker", "marker-top-right");
                    else if (r === 8 && c === 1) square.classList.add("marker", "marker-bottom-left");
                    else if (r === 8 && c === 7) square.classList.add("marker", "marker-bottom-right");
                }
                
                // Marker "L" cho Pawn (h√†ng 3 v√† 6, c√°c c·ªôt l·∫ª)
                if ((r === 3 || r === 6) && [0, 2, 4, 6, 8].includes(c)) {
                    if (r === 3 && c === 0) square.classList.add("marker", "marker-top-left");
                    else if (r === 3 && c === 8) square.classList.add("marker", "marker-top-right");
                    else if (r === 6 && c === 0) square.classList.add("marker", "marker-bottom-left");
                    else if (r === 6 && c === 8) square.classList.add("marker", "marker-bottom-right");
                    else if (r === 3) square.classList.add("marker", c < 4 ? "marker-top-left" : "marker-top-right");
                    else if (r === 6) square.classList.add("marker", c < 4 ? "marker-bottom-left" : "marker-bottom-right");
                }
                
                // Highlight last move
                if (rLM && ((r===rLM.from.r && c===rLM.from.c) || (r===rLM.to.r && c===rLM.to.c))) {
                    square.classList.add("last-move");
                }
                
                // Special Tile Marking - √î i9 v·ªõi m√†u xanh da tr·ªùi ph√°t s√°ng
                if (r === SPECIAL_TILE.r && c === SPECIAL_TILE.c) {
                    // Ki·ªÉm tra n·∫øu c·∫£ 2 b√™n ƒë√£ k√≠ch ho·∫°t -> t·∫Øt glow
                    if (specialTileState.activatedByChess && specialTileState.activatedByXiangqi) {
                        square.classList.add("special-tile-destroyed");
                        square.title = "√î ƒë·∫∑c bi·ªát ƒë√£ h·∫øt ch·ª©c nƒÉng (c·∫£ 2 b√™n ƒë√£ s·ª≠ d·ª•ng)";
                    } else {
                        square.classList.add("special-tile");
                        if (specialTileState.activatedByChess) {
                            square.title = "ƒê√£ k√≠ch ho·∫°t b·ªüi C·ªù Vua - C·ªù T∆∞·ªõng c√≥ th·ªÉ k√≠ch ho·∫°t";
                        } else if (specialTileState.activatedByXiangqi) {
                            square.title = "ƒê√£ k√≠ch ho·∫°t b·ªüi C·ªù T∆∞·ªõng - Vua C·ªù Vua c√≥ th·ªÉ k√≠ch ho·∫°t";
                        } else {
                            square.title = "√î Ch·ª©c NƒÉng ƒê·∫∑c Bi·ªát - Ch·∫°m v√†o ƒë·ªÉ k√≠ch ho·∫°t!";
                        }
                    }
                }
                
                if (!isReviewing) square.onclick = () => handleSquareClick(r, c);
                boardEl.appendChild(square);
            }
        }
        
        // Th√™m palace cho b√™n d∆∞·ªõi (C·ªù T∆∞·ªõng)
        let palaceBottom = document.createElement("div");
        palaceBottom.className = "palace-bottom";
        boardEl.appendChild(palaceBottom);
        
        // Th√™m nh√£n s·ªë v√† ch·ªØ cho b√†n c·ªù - ch·ªâ h√†ng d∆∞·ªõi v√† c·ªôt ph·∫£i
        const boardContainer = document.getElementById('board-container');
        
        // X√≥a c√°c nh√£n c≈© n·∫øu c√≥
        const oldLabels = boardContainer.querySelectorAll('.board-label');
        oldLabels.forEach(label => label.remove());
        
        // T·∫°o nh√£n s·ªë h√†ng b√™n ph·∫£i (1-10 t·ª´ tr√™n xu·ªëng) - ra ngo√†i r√¨a
        const rowLabelRight = document.createElement("div");
        rowLabelRight.className = "board-label row-label-right";
        for (let r = 0; r < ROWS; r++) {
            const labelItem = document.createElement("div");
            labelItem.className = "board-label-item";
            labelItem.textContent = (ROWS - r).toString(); // 10, 9, 8, ..., 1
            rowLabelRight.appendChild(labelItem);
        }
        boardContainer.appendChild(rowLabelRight);
        
        // T·∫°o nh√£n ch·ªØ c·ªôt ph√≠a d∆∞·ªõi (a-i) - ra ngo√†i r√¨a
        const colLabelBottom = document.createElement("div");
        colLabelBottom.className = "board-label col-label-bottom";
        const colLetters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'];
        for (let c = 0; c < COLS; c++) {
            const labelItem = document.createElement("div");
            labelItem.className = "board-label-item";
            labelItem.textContent = colLetters[c]; // a, b, c, ..., i
            colLabelBottom.appendChild(labelItem);
        }
        boardContainer.appendChild(colLabelBottom);

        // Draw Pieces
        let kingInCheck = isKingInCheck(rTurn, rPieces);
        rPieces.forEach(p => {
            let idx = p.r * COLS + p.c; if(idx >= boardEl.children.length) return;
            let square = boardEl.children[idx]; let el = createPieceEl(p);
            if (!isReviewing && selectedPiece && selectedPiece.r === p.r && selectedPiece.c === p.c) el.classList.add("selected");
            if (kingInCheck && (p.type === "king" || p.type === "t∆∞·ªõng") && p.side === rTurn) el.classList.add("in-check");
            
            // Overlay cho T∆∞·ªõng ƒë√£ unlock
            if (p.type === "t∆∞·ªõng" && p.side === "xiangqi" && p.unlocked) {
                el.classList.add("unlocked-general");
                el.title = "T∆∞·ªõng: ƒê√£ m·ªü kh√≥a - C√≥ th·ªÉ ƒëi ngang ho·∫∑c d·ªçc 1 √¥, ra kh·ªèi cung th√†nh!";
            }
            
            if (!isReviewing) el.onclick = (e) => { e.stopPropagation(); handlePieceClick(p); }; else el.style.cursor = "default";
            square.appendChild(el);
        });

        // Draw Hint Dots
        if (!isReviewing && selectedPiece && !isGameOver) {
            getSafeMoves(selectedPiece).forEach(m => {
                let idx = m.r * COLS + m.c;
                if(boardEl.children[idx]) {
                    let dot = document.createElement("div"); dot.className = "move-dot";
                    if (m.isCastle) dot.style.background = "gold";
                    boardEl.children[idx].appendChild(dot);
                }
            });
        }
        
        // Render Graveyards
        renderGraveyards(rDC, rDX);
        
        // Re-append Modal if cleared
        if(!isReviewing) boardEl.appendChild(promoModal); 
    }

    function createPieceEl(p) {
        let el = document.createElement("div"); el.className = "piece";
        if (p.side === "chess") { 
            el.classList.add("chess-side"); 
            el.innerHTML = getChessIcon(p.type);
            // Th√™m icon khi√™n cho t·ªët c·ªù vua ch∆∞a ƒëi
            if (p.type === "pawn" && p.hasShield !== false) {
                let shieldEl = document.createElement("span");
                shieldEl.className = "pawn-shield";
                shieldEl.innerHTML = "üõ°Ô∏è";
                shieldEl.style.position = "absolute";
                shieldEl.style.top = "-5px";
                shieldEl.style.right = "-5px";
                shieldEl.style.fontSize = "12px";
                shieldEl.title = "T·ªët c√≥ khi√™n - Ph√°o kh√¥ng th·ªÉ b·∫Øc c·∫ßu";
                el.style.position = "relative";
                el.appendChild(shieldEl);
            }
        }
        else { 
            el.classList.add("xq-side"); 
            el.innerText = XQ_CHARS[p.type] || p.type;
        }
        return el;
    }

    function renderGraveyards(dChess, dXQ) {
        graveTop.innerHTML = '<div class="grave-label">Qu√¢n Tr·∫Øng<br>B·ªã B·∫Øt</div>';
        graveBot.innerHTML = '<div class="grave-label">Qu√¢n ƒê·ªè<br>B·ªã B·∫Øt</div>';
        
        // Nh√≥m v√† ƒë·∫øm qu√¢n Tr·∫Øng b·ªã b·∫Øt
        let chessCount = {};
        dChess.forEach(p => {
            chessCount[p] = (chessCount[p] || 0) + 1;
        });
        
        Object.keys(chessCount).forEach(type => {
            let count = chessCount[type];
            let el = document.createElement("div");
            el.classList.add("captured-piece", "chess-side");
            
            let iconEl = document.createElement("div");
            iconEl.className = "piece-icon";
            iconEl.innerHTML = getChessIcon(type);
            el.appendChild(iconEl);
            
            if (count > 1) {
                let countEl = document.createElement("span");
                countEl.className = "count";
                countEl.textContent = `x${count}`;
                el.appendChild(countEl);
            }
            
            graveTop.appendChild(el);
        });

        // Nh√≥m v√† ƒë·∫øm qu√¢n ƒê·ªè b·ªã b·∫Øt
        let xqCount = {};
        dXQ.forEach(p => {
            xqCount[p] = (xqCount[p] || 0) + 1;
        });
        
        Object.keys(xqCount).forEach(type => {
            let count = xqCount[type];
            let el = document.createElement("div");
            el.classList.add("captured-piece", "xq-side");
            
            let iconEl = document.createElement("div");
            iconEl.className = "piece-icon";
            iconEl.innerText = XQ_CHARS[type] || type;
            el.appendChild(iconEl);
            
            if (count > 1) {
                let countEl = document.createElement("span");
                countEl.className = "count";
                countEl.textContent = `x${count}`;
                el.appendChild(countEl);
            }
            
            graveBot.appendChild(el);
        });
    }

    // ========== TIMER FUNCTIONS ==========
    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    
    function updateTimerDisplay() {
        if (chessTimerTextEl) {
            chessTimerTextEl.textContent = formatTime(chessTimer);
            // C·∫£nh b√°o khi c√≤n √≠t th·ªùi gian
            if (chessTimer <= 30) {
                chessTimerEl.classList.add('danger');
                chessTimerEl.classList.remove('warning', 'active');
            } else if (chessTimer <= 60) {
                chessTimerEl.classList.add('warning');
                chessTimerEl.classList.remove('danger', 'active');
            } else {
                chessTimerEl.classList.remove('warning', 'danger');
            }
        }
        
        if (xiangqiTimerTextEl) {
            xiangqiTimerTextEl.textContent = formatTime(xiangqiTimer);
            // C·∫£nh b√°o khi c√≤n √≠t th·ªùi gian
            if (xiangqiTimer <= 30) {
                xiangqiTimerEl.classList.add('danger');
                xiangqiTimerEl.classList.remove('warning', 'active');
            } else if (xiangqiTimer <= 60) {
                xiangqiTimerEl.classList.add('warning');
                xiangqiTimerEl.classList.remove('danger', 'active');
            } else {
                xiangqiTimerEl.classList.remove('warning', 'danger');
            }
        }
    }
    
    function startTimer() {
        // D·ª´ng timer c≈© n·∫øu c√≥
        stopTimer();
        
        // Timer ch·ªâ b·∫Øt ƒë·∫ßu sau khi c√≥ n∆∞·ªõc ƒëi ƒë·∫ßu ti√™n
        if (!firstMoveMade) {
            return;
        }
        
        // Ch·ªâ ch·∫°y timer khi game ƒëang di·ªÖn ra v√† kh√¥ng ph·∫£i ƒëang review
        if (isGameOver || isReviewing || pendingPromotion) {
            return;
        }
        
        // B·∫Øt ƒë·∫ßu timer cho l∆∞·ª£t hi·ªán t·∫°i
        timerInterval = setInterval(() => {
            if (isGameOver || isReviewing || pendingPromotion || timerPaused || !firstMoveMade) {
                return;
            }
            
            // Gi·∫£m th·ªùi gian c·ªßa b√™n ƒëang ƒëi
            if (currentTurn === "chess") {
                chessTimer--;
                if (chessTimer <= 0) {
                    chessTimer = 0;
                    handleTimeOut("chess");
                }
            } else {
                xiangqiTimer--;
                if (xiangqiTimer <= 0) {
                    xiangqiTimer = 0;
                    handleTimeOut("xiangqi");
                }
            }
            
            updateTimerDisplay();
        }, 1000); // C·∫≠p nh·∫≠t m·ªói gi√¢y
    }
    
    function stopTimer() {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
    }
    
    function handleTimeOut(side) {
        stopTimer();
        isGameOver = true;
        
        const winner = side === "chess" ? "xiangqi" : "chess";
        const winnerText = document.getElementById('winner-text');
        if (winnerText) {
            if (isBotMode) {
                winnerText.innerText = (winner === playerSide ? "B·∫†N" : "BOT") + " TH·∫ÆNG!\n(" + (side === "chess" ? "C·ªù Vua" : "C·ªù T∆∞·ªõng") + " h·∫øt th·ªùi gian)";
            } else {
                winnerText.innerText = (winner === playerSide ? "B·∫†N" : "ƒê·ªêI TH·ª¶") + " TH·∫ÆNG!\n(" + (side === "chess" ? "C·ªù Vua" : "C·ªù T∆∞·ªõng") + " h·∫øt th·ªùi gian)";
            }
        }
        
        const gameOverEl = document.getElementById('game-over');
        if (gameOverEl) {
            gameOverEl.style.display = 'flex';
        }
        
        if (msgEl) {
            msgEl.innerText = (side === "chess" ? "C·ªù Vua" : "C·ªù T∆∞·ªõng") + " h·∫øt th·ªùi gian!";
            msgEl.style.color = '#e74c3c';
        }
        
        drawBoard();
    }
    
    function resetTimers() {
        chessTimer = TIMER_DURATION;
        xiangqiTimer = TIMER_DURATION;
        firstMoveMade = false; // Reset flag n∆∞·ªõc ƒëi ƒë·∫ßu ti√™n
        stopTimer();
        updateTimerDisplay();
        
        // Hi·ªÉn th·ªã timer khi game b·∫Øt ƒë·∫ßu
        if (chessTimerEl) chessTimerEl.style.display = 'flex';
        if (xiangqiTimerEl) xiangqiTimerEl.style.display = 'flex';
    }
    
    function updateStatusUI(turn, _pieces) {
        turnBadge.innerText = turn === "chess" ? "L∆∞·ª£t: C·ªù Vua" : "L∆∞·ª£t: C·ªù T∆∞·ªõng";
        turnBadge.style.background = turn === "chess" ? "#fff" : "#cc0000";
        turnBadge.style.color = turn === "chess" ? "#000" : "#fff";
        
        // C·∫≠p nh·∫≠t timer display v√† highlight timer ƒëang active
        updateTimerDisplay();
        if (chessTimerEl && xiangqiTimerEl) {
            if (turn === "chess") {
                chessTimerEl.classList.add('active');
                xiangqiTimerEl.classList.remove('active');
            } else {
                xiangqiTimerEl.classList.add('active');
                chessTimerEl.classList.remove('active');
            }
        }
        
        // Lu√¥n ki·ªÉm tra v√† hi·ªÉn th·ªã th√¥ng b√°o chi·∫øu cho c·∫£ 2 b√™n
        const chessInCheck = isKingInCheck("chess", _pieces);
        const xiangqiInCheck = isKingInCheck("xiangqi", _pieces);
        
        if (chessInCheck && turn === "chess") {
            msgEl.innerText = "‚ö†Ô∏è CHI·∫æU VUA!";
            msgEl.style.color = "#ff0000";
            msgEl.style.fontWeight = "bold";
        } else if (xiangqiInCheck && turn === "xiangqi") {
            msgEl.innerText = "‚ö†Ô∏è CHI·∫æU T∆Ø·ªöNG!";
            msgEl.style.color = "#ff0000";
            msgEl.style.fontWeight = "bold";
        } else if (chessInCheck) {
            msgEl.innerText = "‚ö†Ô∏è C·ªù Vua ƒëang b·ªã chi·∫øu!";
            msgEl.style.color = "#ffaa00";
            msgEl.style.fontWeight = "normal";
        } else if (xiangqiInCheck) {
            msgEl.innerText = "‚ö†Ô∏è C·ªù T∆∞·ªõng ƒëang b·ªã chi·∫øu!";
            msgEl.style.color = "#ffaa00";
            msgEl.style.fontWeight = "normal";
        } else {
            msgEl.innerText = "";
        }
        
        // Enable/disable action buttons based on game state
        const btnResign = document.getElementById('btn-resign');
        const btnDraw = document.getElementById('btn-draw');
        if (btnResign) {
            btnResign.disabled = isGameOver || isReviewing;
        }
        if (btnDraw) {
            btnDraw.disabled = isGameOver || isReviewing;
        }
    }

    // --- INTERACTION ---
    function handlePieceClick(p) {
        if (isGameOver || isReviewing || pendingPromotion) return;
        
        // N·∫øu ƒë√£ ch·ªçn qu√¢n v√† click v√†o qu√¢n ƒë·ªëi th·ªß, th·ª≠ di chuy·ªÉn/ƒÉn
        if (selectedPiece && selectedPiece.side !== p.side) {
            // Ki·ªÉm tra l∆∞·ª£t ch∆°i n·∫øu ƒëang online
            if (isOnlineGame) {
                if (currentTurn !== playerSide) {
                    msgEl.innerText = "Kh√¥ng ph·∫£i l∆∞·ª£t c·ªßa b·∫°n!";
                    setTimeout(() => msgEl.innerText = "", 2000);
                    return;
                }
                if (selectedPiece.side !== playerSide) {
                    msgEl.innerText = "B·∫°n ch·ªâ c√≥ th·ªÉ di chuy·ªÉn qu√¢n c·ªßa m√¨nh!";
                    setTimeout(() => msgEl.innerText = "", 2000);
                    return;
                }
            }
            // Cho ph√©p ƒÉn qu√¢n ƒë·ªëi th·ªß
            tryMoveTo(p.r, p.c);
            return;
        }
        
        // Ki·ªÉm tra l∆∞·ª£t ch∆°i - ch·ªâ ƒë∆∞·ª£c ch·ªçn qu√¢n c·ªßa m√¨nh khi ƒë·∫øn l∆∞·ª£t m√¨nh
        if (isOnlineGame) {
            // Ki·ªÉm tra l∆∞·ª£t ch∆°i tr∆∞·ªõc
            if (currentTurn !== playerSide) {
                msgEl.innerText = "Kh√¥ng ph·∫£i l∆∞·ª£t c·ªßa b·∫°n!";
                setTimeout(() => msgEl.innerText = "", 2000);
                return;
            }
            // Ch·ªâ cho ph√©p ch·ªçn qu√¢n c·ªßa m√¨nh (kh√¥ng cho ch·ªçn qu√¢n ƒë·ªëi th·ªß khi ch∆∞a ch·ªçn qu√¢n)
            if (p.side !== playerSide) {
                msgEl.innerText = "B·∫°n ch·ªâ c√≥ th·ªÉ ch·ªçn qu√¢n c·ªßa m√¨nh!";
                setTimeout(() => msgEl.innerText = "", 2000);
                return;
            }
        }
        
        // Ki·ªÉm tra l∆∞·ª£t ch∆°i (cho c·∫£ offline v√† online)
        if (p.side !== currentTurn) {
            if (!isOnlineGame && !isBotMode) {
                msgEl.innerText = "Kh√¥ng ph·∫£i l∆∞·ª£t c·ªßa b·∫°n!";
                setTimeout(() => msgEl.innerText = "", 2000);
            }
            return;
        }
        
        // Trong ch·∫ø ƒë·ªô BOT, ch·ªâ cho ph√©p ch·ªçn qu√¢n c·ªßa m√¨nh
        if (isBotMode && p.side !== playerSide) {
            msgEl.innerText = "B·∫°n ch·ªâ c√≥ th·ªÉ ch·ªçn qu√¢n c·ªßa m√¨nh!";
            setTimeout(() => msgEl.innerText = "", 2000);
            return;
        }
        
        // Ch·ªçn qu√¢n c·ªù c·ªßa m√¨nh
        selectedPiece = p;
        drawBoard();
    }

    function handleSquareClick(r, c) {
        if (isGameOver || isReviewing || pendingPromotion || !selectedPiece) return;
        // Ki·ªÉm tra l∆∞·ª£t ch∆°i n·∫øu ƒëang online
        if (isOnlineGame && currentTurn !== playerSide) {
            msgEl.innerText = "ƒêang ch·ªù ƒë·ªëi th·ªß...";
            setTimeout(() => msgEl.innerText = "", 2000);
            return;
        }
        // Ki·ªÉm tra l∆∞·ª£t ch∆°i n·∫øu ƒëang ch∆°i v·ªõi BOT
        if (isBotMode && currentTurn !== playerSide) {
            msgEl.innerText = "ƒêang ch·ªù BOT...";
            setTimeout(() => msgEl.innerText = "", 2000);
            return;
        }
        tryMoveTo(r, c);
    }

    function tryMoveTo(r, c) {
        if (!selectedPiece) return;
        
        // Ki·ªÉm tra l∆∞·ª£t ch∆°i v√† qu√¢n c·ªù tr∆∞·ªõc khi di chuy·ªÉn
        if (isOnlineGame) {
            if (currentTurn !== playerSide) {
                msgEl.innerText = "Kh√¥ng ph·∫£i l∆∞·ª£t c·ªßa b·∫°n!";
                setTimeout(() => msgEl.innerText = "", 2000);
                selectedPiece = null;
                drawBoard();
                return;
            }
            if (selectedPiece.side !== playerSide) {
                msgEl.innerText = "B·∫°n ch·ªâ c√≥ th·ªÉ di chuy·ªÉn qu√¢n c·ªßa m√¨nh!";
                setTimeout(() => msgEl.innerText = "", 2000);
                selectedPiece = null;
                drawBoard();
                return;
            }
        }
        
        let moves = getSafeMoves(selectedPiece);
        let move = moves.find(m => m.r === r && m.c === c);

        if (move) {
            lastMove = { from: {r: selectedPiece.r, c: selectedPiece.c}, to: {r: r, c: c} };
            let targetIdx = pieces.findIndex(p => p.r === r && p.c === c);
            
            // X·ª≠ l√Ω ƒÉn en passant
            if (move.isEnPassantCapture && move.enPassantTarget) {
                // T√¨m v√† ƒÉn t·ªët ƒë·ªëi th·ªß ·ªü v·ªã tr√≠ en passant target
                const enPassantPieceIdx = pieces.findIndex(p => 
                    p.r === move.enPassantTarget.r && 
                    p.c === move.enPassantTarget.c &&
                    p.type === "pawn" &&
                    p.side !== selectedPiece.side
                );
                if (enPassantPieceIdx !== -1) {
                    let captured = pieces[enPassantPieceIdx];
                    pieces.splice(enPassantPieceIdx, 1);
                    if (captured.side === "chess") deadChess.push(captured.type);
                    else deadXQ.push(captured.type);
                    playSound('capture');
                }
            } else if (targetIdx !== -1) {
                // ƒÇn qu√¢n b√¨nh th∆∞·ªùng
                let captured = pieces[targetIdx];
                pieces.splice(targetIdx, 1);
                if (captured.side === "chess") deadChess.push(captured.type); else deadXQ.push(captured.type);
                playSound('capture');
            } else {
                playSound('move');
            }

            if (move.isCastle) {
                if (c === 6) { let rook = pieces.find(p => p.r===0 && p.c===7); if (rook) { rook.c = 5; rook.hasMoved = true; } }
                if (c === 2) { let rook = pieces.find(p => p.r===0 && p.c===0); if (rook) { rook.c = 3; rook.hasMoved = true; } }
            }

            selectedPiece.r = r; selectedPiece.c = c;
            if (selectedPiece.type === "king" || selectedPiece.type === "rook") selectedPiece.hasMoved = true;
            
            // X√≥a khi√™n c·ªßa t·ªët c·ªù vua khi di chuy·ªÉn
            if (selectedPiece.type === "pawn" && selectedPiece.side === "chess") {
                selectedPiece.hasMoved = true;
                selectedPiece.hasShield = false; // M·∫•t khi√™n khi di chuy·ªÉn
            }

            // L∆∞u th√¥ng tin en passant target n·∫øu t·ªët ƒëi 2 √¥
            if (selectedPiece.side === "chess" && selectedPiece.type === "pawn" && move.isEnPassantMove) {
                // T·ªët v·ª´a ƒëi 2 √¥ t·ª´ h√†ng 1 ƒë·∫øn h√†ng 3, ƒë·ªëi th·ªß c√≥ th·ªÉ ƒÉn en passant ·ªü h√†ng 3
                enPassantTarget = {r: 3, c: c};
            } else {
                // X√≥a en passant target sau m·ªói l∆∞·ª£t (ch·ªâ c√≥ th·ªÉ ƒÉn en passant ·ªü l∆∞·ª£t ti·∫øp theo)
                enPassantTarget = null;
            }

            // CHECK PROMOTION (T·ªët c·ªù vua ƒë·∫øn h√†ng cu·ªëi)
            if (selectedPiece.side === "chess" && selectedPiece.type === "pawn" && r === 9) {
                pendingPromotion = selectedPiece;
                // Hi·ªÉn th·ªã modal phong c·∫•p v√† D·ª™NG L·∫†I, ch∆∞a ƒë·ªïi l∆∞·ª£t
                promoModal.style.display = 'flex';
                drawBoard(); // V·∫Ω l·∫°i ƒë·ªÉ th·∫•y qu√¢n t·ªët ƒë√£ ƒëi xu·ªëng
                return; // THO√ÅT H√ÄM, ch·ªù ng∆∞·ªùi ch∆°i ch·ªçn
            }
            
            // ========== SPECIAL TILE ACTIVATION CHECK ==========
            // Ki·ªÉm tra n·∫øu di chuy·ªÉn ƒë·∫øn √¥ ƒë·∫∑c bi·ªát
            if (r === SPECIAL_TILE.r && c === SPECIAL_TILE.c) {
                handleSpecialTileActivation(selectedPiece);
            }

            // ƒê√°nh d·∫•u ƒë√£ c√≥ n∆∞·ªõc ƒëi ƒë·∫ßu ti√™n ƒë·ªÉ b·∫Øt ƒë·∫ßu timer
            if (!firstMoveMade) {
                firstMoveMade = true;
                // B·∫Øt ƒë·∫ßu timer sau n∆∞·ªõc ƒëi ƒë·∫ßu ti√™n
                setTimeout(() => startTimer(), 100);
            }

            finishTurn();
        } else {
            // N·∫øu kh√¥ng c√≥ n∆∞·ªõc ƒëi h·ª£p l·ªá
            msgEl.innerText = "N∆∞·ªõc ƒëi kh√¥ng h·ª£p l·ªá!";
            setTimeout(() => msgEl.innerText = "", 2000);
        }
    }

    // --- LOGIC MOVES ---
    function inside(r, c) { return r >= 0 && r < ROWS && c >= 0 && c < COLS; }
    function isOccupied(r, c, _pieces = pieces) { return _pieces.some(p => p.r === r && p.c === c); }
    function isAlly(r, c, side, _pieces = pieces) { return _pieces.some(p => p.r === r && p.c === c && p.side === side); }
    function isInPalace(r, c) { return r >= 7 && r <= 9 && c >= 3 && c <= 5; }

    function isSquareAttacked(r, c, sideBeingAttacked, _pieces = pieces) {
        let enemySide = sideBeingAttacked === "chess" ? "xiangqi" : "chess";
        let enemies = _pieces.filter(p => p.side === enemySide);
        for (let enemy of enemies) { 
            // Ki·ªÉm tra n·∫øu l√† Vua/T∆∞·ªõng ƒë·ªãch ƒë·ª©ng c·∫°nh - kh√¥ng t√≠nh l√† t·∫•n c√¥ng (v√¨ hai Vua kh√¥ng th·ªÉ ƒë·ª©ng c·∫°nh nhau)
            if (enemy.type === "king" || enemy.type === "t∆∞·ªõng") {
                let dr = Math.abs(enemy.r - r);
                let dc = Math.abs(enemy.c - c);
                if (dr <= 1 && dc <= 1 && (dr + dc > 0)) {
                    continue; // B·ªè qua Vua/T∆∞·ªõng ƒë·ªãch ·ªü c·∫°nh
                }
            }
            if (getPseudoMoves(enemy, _pieces).some(m => m.r === r && m.c === c)) return true; 
        }
        return false;
    }
    
    // Ki·ªÉm tra xem c√≥ Vua/T∆∞·ªõng ƒë·ªãch ·ªü c·∫°nh √¥ (r, c) kh√¥ng
    function hasEnemyKingAdjacent(r, c, side, _pieces = pieces) {
        let enemySide = side === "chess" ? "xiangqi" : "chess";
        let enemyKingType = enemySide === "chess" ? "king" : "t∆∞·ªõng";
        let enemyKing = _pieces.find(p => p.side === enemySide && p.type === enemyKingType);
        if (!enemyKing) return false;
        let dr = Math.abs(enemyKing.r - r);
        let dc = Math.abs(enemyKing.c - c);
        return dr <= 1 && dc <= 1 && (dr + dc > 0); // C·∫°nh nhau (kh√¥ng c√πng √¥)
    }

    function isKingInCheck(side, _pieces = pieces) {
        let kingType = side === "chess" ? "king" : "t∆∞·ªõng";
        let king = _pieces.find(p => p.side === side && p.type === kingType);
        if (!king) return true; 
        return isSquareAttacked(king.r, king.c, side, _pieces);
    }

    function isCheckmate(side) {
        if (!isKingInCheck(side)) return false;
        let myPieces = pieces.filter(p => p.side === side);
        for (let p of myPieces) { if (getSafeMoves(p).length > 0) return false; }
        return true;
    }

    function getSafeMoves(p) {
        // Ki·ªÉm tra n·∫øu vua ƒëang b·ªã chi·∫øu - ch·ªâ cho ph√©p n∆∞·ªõc ƒëi gi·∫£i chi·∫øu
        const kingInCheck = isKingInCheck(p.side);
        
        let moves = getPseudoMoves(p, pieces);
        return moves.filter(m => {
            // L∆∞u tr·∫°ng th√°i hi·ªán t·∫°i
            let oldR = p.r, oldC = p.c;
            let capIdx = pieces.findIndex(t => t.r === m.r && t.c === m.c);
            let capPiece = null;
            
            // T·∫°m th·ªùi di chuy·ªÉn qu√¢n ƒë·ªÉ ki·ªÉm tra
            if (capIdx !== -1) { 
                capPiece = pieces[capIdx]; 
                pieces.splice(capIdx, 1); 
            }
            p.r = m.r; 
            p.c = m.c;
            
            // Ki·ªÉm tra sau khi ƒëi, vua c√≥ c√≤n b·ªã chi·∫øu kh√¥ng
            let safe = !isKingInCheck(p.side, pieces);
            
            // N·∫øu vua ƒëang b·ªã chi·∫øu, ch·ªâ cho ph√©p n∆∞·ªõc ƒëi gi·∫£i chi·∫øu
            if (kingInCheck && !safe) {
                // N∆∞·ªõc ƒëi n√†y kh√¥ng gi·∫£i chi·∫øu - kh√¥ng h·ª£p l·ªá
                safe = false;
            }
            
            // Restore tr·∫°ng th√°i
            p.r = oldR; 
            p.c = oldC;
            if (capPiece) {
                pieces.splice(capIdx, 0, capPiece);
            }
            
            return safe;
        });
    }

    function getPseudoMoves(p, _pieces) {
        if (p.side === "chess") return getChessMoves(p, _pieces);
        return getXQMoves(p, _pieces);
    }

    function getChessMoves(p, _pieces) {
        let moves = [];
        const dirs = { rook: [[1,0],[-1,0],[0,1],[0,-1]], bishop: [[1,1],[1,-1],[-1,1],[-1,-1]], queen: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]] };
        if (p.type === "pawn") {
            // ƒêi th·∫≥ng 1 √¥
            if (!isOccupied(p.r+1, p.c, _pieces) && inside(p.r+1, p.c)) moves.push({r: p.r+1, c: p.c});
            // ƒêi th·∫≥ng 2 √¥ t·ª´ h√†ng ban ƒë·∫ßu
            if (p.r === 1 && !isOccupied(p.r+1, p.c, _pieces) && !isOccupied(p.r+2, p.c, _pieces)) {
                moves.push({r: p.r+2, c: p.c, isEnPassantMove: true});
            }
            // ƒÇn ch√©o b√¨nh th∆∞·ªùng
            [[1,1], [1,-1]].forEach(([dr, dc]) => {
                let nr = p.r+dr, nc = p.c+dc;
                if (inside(nr, nc) && isOccupied(nr, nc, _pieces) && !isAlly(nr, nc, p.side, _pieces)) {
                    moves.push({r: nr, c: nc});
                }
            });
            // ƒÇn en passant
            if (enPassantTarget && p.r === 3) { // T·ªët ·ªü h√†ng 3 (sau khi ƒë·ªëi th·ªß ƒëi 2 √¥)
                // Ki·ªÉm tra n·∫øu t·ªët ƒë·ªëi th·ªß ·ªü c·ªôt b√™n c·∫°nh v√† v·ª´a ƒëi 2 √¥
                if (enPassantTarget.c === p.c - 1 || enPassantTarget.c === p.c + 1) {
                    // C√≥ th·ªÉ ƒÉn en passant v√†o √¥ ph√≠a sau t·ªët ƒë·ªëi th·ªß
                    moves.push({r: enPassantTarget.r + 1, c: enPassantTarget.c, isEnPassantCapture: true, enPassantTarget: enPassantTarget});
                }
            }
        }
        else if (p.type === "knight") {
            [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dr,dc]) => {
                let nr = p.r+dr, nc = p.c+dc; if (inside(nr, nc) && !isAlly(nr, nc, p.side, _pieces)) moves.push({r: nr, c: nc});
            });
        }
        else if (p.type === "king") {
            [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc]) => {
                let nr = p.r+dr, nc = p.c+dc; 
                if (inside(nr, nc) && !isAlly(nr, nc, p.side, _pieces)) {
                    // Kh√¥ng cho ph√©p Vua di chuy·ªÉn ƒë·∫øn √¥ c·∫°nh Vua/T∆∞·ªõng ƒë·ªãch
                    if (!hasEnemyKingAdjacent(nr, nc, p.side, _pieces)) {
                        moves.push({r: nr, c: nc});
                    }
                }
            });
            if (_pieces === pieces && !p.hasMoved && !isKingInCheck("chess")) {
                if (!isOccupied(0, 5) && !isOccupied(0, 6)) {
                    let rook = _pieces.find(rp => rp.r===0 && rp.c===7 && rp.type==="rook" && !rp.hasMoved);
                    if (rook && !isSquareAttacked(0,5,"chess") && !isSquareAttacked(0,6,"chess")) moves.push({r: 0, c: 6, isCastle: true});
                }
                if (!isOccupied(0, 1) && !isOccupied(0, 2) && !isOccupied(0, 3)) {
                    let rook = _pieces.find(rp => rp.r===0 && rp.c===0 && rp.type==="rook" && !rp.hasMoved);
                    if (rook && !isSquareAttacked(0,3,"chess") && !isSquareAttacked(0,2,"chess")) moves.push({r: 0, c: 2, isCastle: true});
                }
            }
        }
        else if (dirs[p.type]) {
            dirs[p.type].forEach(([dr, dc]) => {
                let nr = p.r+dr, nc = p.c+dc;
                while (inside(nr, nc)) {
                    if (isAlly(nr, nc, p.side, _pieces)) break; moves.push({r: nr, c: nc}); if (isOccupied(nr, nc, _pieces)) break; nr += dr; nc += dc;
                }
            });
        }
        return moves;
    }

    function getXQMoves(p, _pieces) {
        let moves = [];
        const checkLine = (dirs, isCannon=false) => {
             dirs.forEach(([dr, dc]) => {
                let nr = p.r+dr, nc = p.c+dc; let hurdle=false; 
                while (inside(nr, nc)) {
                    let targetIdx = _pieces.findIndex(t => t.r === nr && t.c === nc);
                    let targetPiece = targetIdx !== -1 ? _pieces[targetIdx] : null;

                    if (!hurdle) {
                        if (!targetPiece) moves.push({r: nr, c: nc});
                        else {
                            if (!isCannon) {
                                if (targetPiece.side !== p.side) moves.push({r: nr, c: nc});
                                break;
                            } else {
                                // Ph√°o b·∫Øc c·∫ßu: c·∫ßn c√≥ 1 qu√¢n l√†m c·∫ßu
                                // N·∫øu g·∫∑p t·ªët c·ªù vua ch∆∞a ƒëi (c√≥ khi√™n) ‚Üí kh√¥ng th·ªÉ b·∫Øc c·∫ßu
                                if (targetPiece.side === "chess" && targetPiece.type === "pawn") {
                                    // Ki·ªÉm tra n·∫øu t·ªët c√≥ khi√™n (ch∆∞a ƒëi) ‚Üí kh√¥ng th·ªÉ b·∫Øc c·∫ßu
                                    if (targetPiece.hasShield !== false) {
                                        break; // Kh√¥ng th·ªÉ b·∫Øc c·∫ßu qua t·ªët c√≥ khi√™n
                                    } else {
                                        hurdle = true; // T·ªët ƒë√£ ƒëi ‚Üí c√≥ th·ªÉ b·∫Øc c·∫ßu
                                    }
                                } else {
                                    hurdle = true; // Qu√¢n kh√°c ‚Üí c√≥ th·ªÉ b·∫Øc c·∫ßu
                                }
                            }
                        }
                    } else {
                        if (targetPiece) {
                            if (targetPiece.side !== p.side) moves.push({r: nr, c: nc});
                            break;
                        }
                    }
                    nr += dr; nc += dc;
                }
            });
        }

        if (p.type==="xe") checkLine([[1,0],[-1,0],[0,1],[0,-1]]);
        if (p.type==="ph√°o") checkLine([[1,0],[-1,0],[0,1],[0,-1]], true);
        if (p.type==="m√£") {
            // M√£ ƒëi ch·ªØ L v·ªõi 8 h∆∞·ªõng: (2,1), (2,-1), (-2,1), (-2,-1), (1,2), (1,-2), (-1,2), (-1,-2)
            // M·ªói h∆∞·ªõng c√≥ 1 ƒëi·ªÉm ch·∫∑n (ƒëi·ªÉm ƒë·∫ßu ti√™n tr√™n ƒë∆∞·ªùng ƒëi)
            // N·∫øu ƒëi·ªÉm ch·∫∑n c√≥ qu√¢n ‚Üí kh√¥ng th·ªÉ ƒëi h∆∞·ªõng ƒë√≥ (lu·∫≠t c·∫£n m√£)
            const maMoves = [
                { dr: 2, dc: 1, blockR: 1, blockC: 0 },   // ƒêi xu·ªëng ph·∫£i ‚Üí ch·∫∑n ·ªü (1,0)
                { dr: 2, dc: -1, blockR: 1, blockC: 0 },  // ƒêi xu·ªëng tr√°i ‚Üí ch·∫∑n ·ªü (1,0)
                { dr: -2, dc: 1, blockR: -1, blockC: 0 }, // ƒêi l√™n ph·∫£i ‚Üí ch·∫∑n ·ªü (-1,0)
                { dr: -2, dc: -1, blockR: -1, blockC: 0 },// ƒêi l√™n tr√°i ‚Üí ch·∫∑n ·ªü (-1,0)
                { dr: 1, dc: 2, blockR: 0, blockC: 1 },    // ƒêi ph·∫£i xu·ªëng ‚Üí ch·∫∑n ·ªü (0,1)
                { dr: 1, dc: -2, blockR: 0, blockC: -1 }, // ƒêi tr√°i xu·ªëng ‚Üí ch·∫∑n ·ªü (0,-1)
                { dr: -1, dc: 2, blockR: 0, blockC: 1 },    // ƒêi ph·∫£i l√™n ‚Üí ch·∫∑n ·ªü (0,1)
                { dr: -1, dc: -2, blockR: 0, blockC: -1 }  // ƒêi tr√°i l√™n ‚Üí ch·∫∑n ·ªü (0,-1)
            ];
            
            maMoves.forEach(({dr, dc, blockR, blockC}) => {
                // Ki·ªÉm tra ƒëi·ªÉm ch·∫∑n (ƒëi·ªÉm ƒë·∫ßu ti√™n tr√™n ƒë∆∞·ªùng ƒëi)
                let blockRPos = p.r + blockR;
                let blockCPos = p.c + blockC;
                
                // N·∫øu ƒëi·ªÉm ch·∫∑n c√≥ qu√¢n ‚Üí kh√¥ng th·ªÉ ƒëi h∆∞·ªõng n√†y (b·ªã c·∫£n m√£)
                // NH∆ØNG: N·∫øu qu√¢n ch·∫∑n l√† t·ªët c·ªù vua (pawn) th√¨ KH√îNG ch·∫∑n m√£ c·ªù t∆∞·ªõng
                if (isOccupied(blockRPos, blockCPos, _pieces)) {
                    const blockingPiece = _pieces.find(piece => piece.r === blockRPos && piece.c === blockCPos);
                    // N·∫øu qu√¢n ch·∫∑n l√† t·ªët c·ªù vua v√† m√£ l√† c·ªù t∆∞·ªõng ‚Üí kh√¥ng b·ªã ch·∫∑n
                    if (blockingPiece && blockingPiece.type === 'pawn' && blockingPiece.side === 'chess' && p.side === 'xiangqi') {
                        // Kh√¥ng b·ªã ch·∫∑n, ti·∫øp t·ª•c ƒëi
                    } else {
                        return; // B·ªè qua h∆∞·ªõng n√†y (b·ªã ch·∫∑n)
                    }
                }
                
                // N·∫øu ƒëi·ªÉm ch·∫∑n kh√¥ng c√≥ qu√¢n ‚Üí c√≥ th·ªÉ ƒëi
                let nr = p.r + dr;
                let nc = p.c + dc;
                
                if (inside(nr, nc) && !isAlly(nr, nc, p.side, _pieces)) {
                    moves.push({r: nr, c: nc});
                }
            });
        }
        if (p.type==="t·ªët") {
             let nr=p.r-1; if(inside(nr,p.c) && !isAlly(nr,p.c,p.side, _pieces)) moves.push({r:nr, c:p.c});
             if(p.r<5) { if(inside(p.r,p.c-1)&&!isAlly(p.r,p.c-1,p.side, _pieces)) moves.push({r:p.r,c:p.c-1}); if(inside(p.r,p.c+1)&&!isAlly(p.r,p.c+1,p.side, _pieces)) moves.push({r:p.r,c:p.c+1}); }
        }
        if (p.type==="t∆∞·ªõng"||p.type==="sƒ©") {
            if (p.type === "t∆∞·ªõng" && p.unlocked) {
                // T∆∞·ªõng ƒë√£ ƒë∆∞·ª£c unlock - c√≥ th·ªÉ ƒëi ngang ho·∫∑c d·ªçc 1 √¥, ra kh·ªèi cung th√†nh
                const dirs = [[1,0],[-1,0],[0,1],[0,-1]]; // ƒêi ngang ho·∫∑c d·ªçc
                dirs.forEach(([dr,dc]) => {
                    let nr = p.r + dr, nc = p.c + dc;
                    // Ch·ªâ ƒëi 1 √¥
                    if (inside(nr, nc) && !isAlly(nr, nc, p.side, _pieces)) {
                        // Kh√¥ng cho ph√©p T∆∞·ªõng di chuy·ªÉn ƒë·∫øn √¥ c·∫°nh Vua ƒë·ªãch
                        if (!hasEnemyKingAdjacent(nr, nc, p.side, _pieces)) {
                            moves.push({r: nr, c: nc});
                        }
                    }
                });
            } else {
                // Logic b√¨nh th∆∞·ªùng: ch·ªâ ƒëi 1 √¥ trong cung th√†nh
                let dirs = p.type==="t∆∞·ªõng" ? [[1,0],[-1,0],[0,1],[0,-1]] : [[1,1],[1,-1],[-1,1],[-1,-1]];
                dirs.forEach(([dr,dc]) => {
                    let nr=p.r+dr, nc=p.c+dc; 
                    if(inside(nr,nc) && isInPalace(nr,nc) && !isAlly(nr,nc,p.side, _pieces)) {
                        // Kh√¥ng cho ph√©p T∆∞·ªõng di chuy·ªÉn ƒë·∫øn √¥ c·∫°nh Vua ƒë·ªãch
                        if (!hasEnemyKingAdjacent(nr, nc, p.side, _pieces)) {
                            moves.push({r:nr, c:nc});
                        }
                    }
                });
            }
        }
        if (p.type==="t∆∞·ª£ng") {
             [[2,2],[2,-2],[-2,2],[-2,-2]].forEach(([dr,dc]) => {
                let nr=p.r+dr, nc=p.c+dc;
                if(inside(nr,nc) && nr>=5 && !isAlly(nr,nc,p.side, _pieces)) {
                    let er=p.r+dr/2, ec=p.c+dc/2; if(!isOccupied(er,ec, _pieces)) moves.push({r:nr, c:nc});
                }
            });
        }
        return moves;
    }

    function getChessIcon(type) {
        switch (type) {
            case "king": return "‚ôö"; case "queen": return "‚ôõ"; case "rook": return "‚ôú";
            case "bishop": return "‚ôù"; case "knight": return "‚ôû"; case "pawn": return "‚ôü"; default: return "?";
        }
    }
    
    // Kh·ªüi t·∫°o ƒë·ªô kh√≥ m·∫∑c ƒë·ªãnh v√† ch·∫ø ƒë·ªô bot khi DOM ƒë√£ s·∫µn s√†ng
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            selectBotDifficulty('medium');
            // ƒê·∫£m b·∫£o menu bot ƒë∆∞·ª£c hi·ªÉn th·ªã n·∫øu n√∫t bot ƒë√£ active
            const btnBot = document.getElementById('btn-bot');
            if (btnBot && btnBot.classList.contains('active')) {
                selectGameMode('bot');
            }
        });
    } else {
        // DOM ƒë√£ s·∫µn s√†ng
        setTimeout(function() {
            selectBotDifficulty('medium');
            // ƒê·∫£m b·∫£o menu bot ƒë∆∞·ª£c hi·ªÉn th·ªã n·∫øu n√∫t bot ƒë√£ active
            const btnBot = document.getElementById('btn-bot');
            if (btnBot && btnBot.classList.contains('active')) {
                selectGameMode('bot');
            }
        }, 100);
    }
</script>
</body>
</html>